./iterateq.cpp:185:				Arrptr->initHtm[ptr] = (NULLVAL);
./iterateq.cpp:196:				if (Arrptr->H[ptr] > Solverptr->DepthThresh)
./iterateq.cpp:198:					if (Arrptr->initHtm[ptr] == NULLVAL /*&& (Arrptr->H[ptr]>C(0.01)*/)
./iterateq.cpp:199:						Arrptr->initHtm[ptr] = Solverptr->t / C(3600.0);
./iterateq.cpp:200:					//if (Arrptr->H[ptr]>C(0.01)) 
./iterateq.cpp:201:					Arrptr->totalHtm[ptr] += Solverptr->Tstep / C(3600.0);
./iterateq.cpp:203:					if (Arrptr->H[ptr] > Arrptr->maxH[ptr])
./iterateq.cpp:205:						Arrptr->maxH[ptr] = Arrptr->H[ptr];
./iterateq.cpp:206:						Arrptr->maxHtm[ptr] = Solverptr->t / C(3600.0);
./iterateq.cpp:242:				if (Statesptr->latlong == ON) dA = Arrptr->dA[ptr]; // if latlong is on change dA to local cell area
./iterateq.cpp:245:					if (Arrptr->H[ptr]>C(0.01)) FloodArea += dA*Arrptr->paerial[ptr]; // If porosity used, scale flooded area by porosity (TJF)
./iterateq.cpp:249:					if (Arrptr->H[ptr] - Arrptr->SGCbfH[ptr] > Solverptr->DepthThresh)
./iterateq.cpp:254:					if (Arrptr->H[ptr] > C(0.01)) FloodArea += dA; // standard area calculation
./iterateq.cpp:274:					if (Locptr->stage_check[i] == 1) fprintf(Fptr->stage_fp, "%10.4" NUM_FMT"", Arrptr->H[index]);
./iterateq.cpp:286:						if (Locptr->stage_check[i] == 1) fprintf(Fptr->vel_fp, "%10.4" NUM_FMT"", sqrt(pow(getmax(fabs(Arrptr->Vx[index]), fabs(Arrptr->Vx[index + 1])), 2) + pow(getmax(fabs(Arrptr->Vy[index]), fabs(Arrptr->Vy[index + (Parptr->xsz + 1)])), 2)));
./iterateq.cpp:301:					discharge = CalcVirtualGauge(i, Parptr->xsz + 1, Arrptr->Qx, Arrptr->Qy, Locptr);
./iterateq.cpp:357:			if (Statesptr->binary_out == ON) write_binrasterfile(Fnameptr->resrootname, -1, ".opb", Arrptr->H, Arrptr->DEM, 0, Statesptr, Parptr);
./iterateq.cpp:358:			else write_ascfile(Fnameptr->resrootname, -1, ".op", Arrptr->H, Arrptr->DEM, 0, Statesptr, Parptr);
./iterateq.cpp:368:					if (Statesptr->binary_out == ON) write_binrasterfile(Fnameptr->resrootname, -1, ".opelevb", Arrptr->H, Arrptr->SGCz, 3, Statesptr, Parptr, Solverptr->DepthThresh);
./iterateq.cpp:369:					else write_ascfile(Fnameptr->resrootname, -1, ".opelev", Arrptr->H, Arrptr->SGCz, 3, Statesptr, Parptr, Solverptr->DepthThresh);
./iterateq.cpp:373:					if (Statesptr->binary_out == ON) write_binrasterfile(Fnameptr->resrootname, -1, ".opelevb", Arrptr->H, Arrptr->DEM, 3, Statesptr, Parptr, Solverptr->DepthThresh);
./iterateq.cpp:374:					else write_ascfile(Fnameptr->resrootname, -1, ".opelev", Arrptr->H, Arrptr->DEM, 3, Statesptr, Parptr, Solverptr->DepthThresh);
./iterateq.cpp:387:					if (Statesptr->binary_out == ON) write_binrasterfile(Fnameptr->resrootname, i, "-T.opb", Arrptr->H, Arrptr->DEM, 0, Statesptr, Parptr);
./iterateq.cpp:388:					else write_ascfile(Fnameptr->resrootname, i, "-T.op", Arrptr->H, Arrptr->DEM, 0, Statesptr, Parptr);
./iterateq.cpp:399:							if (Statesptr->binary_out == ON) write_binrasterfile(Fnameptr->resrootname, i, "-T.opelevb", Arrptr->H, Arrptr->SGCz, 3, Statesptr, Parptr, Solverptr->DepthThresh);
./iterateq.cpp:400:							else write_ascfile(Fnameptr->resrootname, i, "-T.opelev", Arrptr->H, Arrptr->SGCz, 3, Statesptr, Parptr, Solverptr->DepthThresh);
./iterateq.cpp:404:							if (Statesptr->binary_out == ON) write_binrasterfile(Fnameptr->resrootname, i, "-T.opelevb", Arrptr->H, Arrptr->DEM, 3, Statesptr, Parptr, Solverptr->DepthThresh);
./iterateq.cpp:405:							else write_ascfile(Fnameptr->resrootname, i, "-T.opelev", Arrptr->H, Arrptr->DEM, 3, Statesptr, Parptr, Solverptr->DepthThresh);
./iterateq.cpp:459:			if (Arrptr->maxH[ptr]>1e-3) Arrptr->maxH[ptr] += Arrptr->SGCz[ptr]; else Arrptr->maxH[ptr] = NULLVAL;
./iterateq.cpp:461:		if (Statesptr->binary_out == ON) write_binrasterfile(Fnameptr->resrootname, -1, ".mxeb", Arrptr->maxH, Arrptr->SGCz, 0, Statesptr, Parptr);
./iterateq.cpp:462:		else write_ascfile(Fnameptr->resrootname, -1, ".mxe", Arrptr->maxH, Arrptr->SGCz, 0, Statesptr, Parptr);
./iterateq.cpp:469:			if (Arrptr->maxH[ptr]>1e-3) Arrptr->maxH[ptr] += Arrptr->DEM[ptr]; else Arrptr->maxH[ptr] = NULLVAL;
./iterateq.cpp:471:		if (Statesptr->binary_out == ON) write_binrasterfile(Fnameptr->resrootname, -1, ".mxeb", Arrptr->maxH, Arrptr->DEM, 0, Statesptr, Parptr);
./iterateq.cpp:472:		else write_ascfile(Fnameptr->resrootname, -1, ".mxe", Arrptr->maxH, Arrptr->DEM, 0, Statesptr, Parptr);
./iterateq.cpp:500:			Arrptr->H[BCptr->xpi[ps_index] + BCptr->ypi[ps_index] * Parptr->xsz] += BCptr->PS_Val[ps_index] * Parptr->dx*Solverptr->Tstep / Parptr->dA;
./iterateq.cpp:508:			Arrptr->H[BCptr->xpi[ps_index] + BCptr->ypi[ps_index] * Parptr->xsz] += qtmp*Parptr->dx*Solverptr->Tstep / Parptr->dA;
./iterateq.cpp:519:		qxptr0 = Arrptr->Qx + j*(Parptr->xsz + 1);
./iterateq.cpp:520:		qyptr0 = Arrptr->Qy + j*(Parptr->xsz + 1);
./iterateq.cpp:521:		qyptr1 = Arrptr->Qy + (j + 1)*(Parptr->xsz + 1);
./iterateq.cpp:522:		hptr = Arrptr->H + j*Parptr->xsz;
./iterateq.cpp:523:		mptr = Arrptr->ChanMask + j*Parptr->xsz;
./iterateq.cpp:557:			himp = BCptr->PS_Val[ps_index] - Arrptr->DEM[BCptr->xpi[ps_index] + BCptr->ypi[ps_index] * Parptr->xsz];
./iterateq.cpp:560:			Qpnt = (himp - Arrptr->H[BCptr->xpi[ps_index] + BCptr->ypi[ps_index] * Parptr->xsz])*Parptr->dA / Solverptr->Tstep;
./iterateq.cpp:564:			Arrptr->H[BCptr->xpi[ps_index] + BCptr->ypi[ps_index] * Parptr->xsz] = himp;
./iterateq.cpp:568:			himp = InterpolateTimeSeries(BCptr->PS_TimeSeries[ps_index], Solverptr->t) - Arrptr->DEM[BCptr->xpi[ps_index] + BCptr->ypi[ps_index] * Parptr->xsz];
./iterateq.cpp:571:			Qpnt = (himp - Arrptr->H[BCptr->xpi[ps_index] + BCptr->ypi[ps_index] * Parptr->xsz])*Parptr->dA / Solverptr->Tstep;
./iterateq.cpp:575:			Arrptr->H[BCptr->xpi[ps_index] + BCptr->ypi[ps_index] * Parptr->xsz] = himp;
./iterateq.cpp:588:	for (int i=0; i<Arrptr->protection_count; i++)
./iterateq.cpp:590:        if (Arrptr->Protection_pf[i] == 0)
./iterateq.cpp:592:		p0=Arrptr->Protection_pbounds[(8*i)];
./iterateq.cpp:593:		p1=Arrptr->Protection_pbounds[(8*i)+1];
./iterateq.cpp:594:		p2=Arrptr->Protection_pbounds[(8*i)+1];
./iterateq.cpp:595:		p3=Arrptr->Protection_pbounds[(8*i)+1];
./iterateq.cpp:596:		p4=Arrptr->Protection_pbounds[(8*i)+1];
./iterateq.cpp:597:		p5=Arrptr->Protection_pbounds[(8*i)+1];
./iterateq.cpp:598:		p6=Arrptr->Protection_pbounds[(8*i)+1];
./iterateq.cpp:599:		p7=Arrptr->Protection_pbounds[(8*i)+1];
./iterateq.cpp:600:		if (Arrptr->DEM[p0] >= Arrptr->Protection_pfh[i] || Arrptr->DEM[p1] >= Arrptr->Protection_pfh[i] || Arrptr->DEM[p2] >= Arrptr->Protection_pfh[i] || Arrptr->DEM[p3] >= Arrptr->Protection_pfh[i] || Arrptr->DEM[p4] >= Arrptr->Protection_pfh[i] || Arrptr->DEM[p5] >= Arrptr->Protection_pfh[i] || Arrptr->DEM[p6] >= Arrptr->Protection_pfh[i] || Arrptr->DEM[p7] >= Arrptr->Protection_pfh[i]) 
./iterateq.cpp:602:                        	Arrptr->Protection_pf[i] = 1;
./iterateq.cpp:603:				ppos= Arrptr->Protection_pos[i];
./iterateq.cpp:604:				Arrptr->DEM[ppos] = Arrptr->DEM[ppos]-Arrptr->Protection_ph[i];
./por_flow.cpp:36:  z0=Arrptr->DEM[p0];
./por_flow.cpp:37:  z1=Arrptr->DEM[p1];
./por_flow.cpp:38:  h0=Arrptr->H[p0];
./por_flow.cpp:39:  h1=Arrptr->H[p1];
./por_flow.cpp:42:  if(Arrptr->Manningsn!=NULL) fn=C(0.5)*(Arrptr->Manningsn[p0]+Arrptr->Manningsn[p1]);
./por_flow.cpp:52:    if(MaskTest(Arrptr->ChanMask[p0],Arrptr->ChanMask[p1]) && hflow>Solverptr->DepthThresh) 
./por_flow.cpp:62:        por0=Arrptr->paerial[p0];
./por_flow.cpp:63:        por1=Arrptr->paerial[p1];
./por_flow.cpp:73:        por0=Arrptr->paerial[i+j*Parptr->xsz+pH0*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:74:        por1=Arrptr->paerial[i+j*Parptr->xsz+pH1*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:80:        por0=Arrptr->pbound[i+j*Parptr->xsz+1*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:81:        por1=Arrptr->pbound[i+1+j*Parptr->xsz+3*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:91:        por0=Arrptr->pbound[i+j*Parptr->xsz+pH0*Parptr->xsz*Parptr->ysz+1*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:92:        por1=Arrptr->pbound[i+1+j*Parptr->xsz+pH0*Parptr->xsz*Parptr->ysz+3*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:101:        Arrptr->TRecx[p0]=Solverptr->Tstep;
./por_flow.cpp:112:          Arrptr->LimQx[p0]=Q;
./por_flow.cpp:127:    if(MaskTest(Arrptr->ChanMask[p0],Arrptr->ChanMask[p1]) && hflow>Solverptr->DepthThresh) 
./por_flow.cpp:137:        por0=Arrptr->paerial[p0];
./por_flow.cpp:138:        por1=Arrptr->paerial[p1];
./por_flow.cpp:148:        por0=Arrptr->paerial[i+j*Parptr->xsz+pH0*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:149:        por1=Arrptr->paerial[i+j*Parptr->xsz+pH1*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:155:        por0=Arrptr->pbound[i+j*Parptr->xsz+1*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:156:        por1=Arrptr->pbound[i+1+j*Parptr->xsz+3*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:166:        por0=Arrptr->pbound[i+j*Parptr->xsz+pH0*Parptr->xsz*Parptr->ysz+1*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:167:        por1=Arrptr->pbound[i+1+j*Parptr->xsz+pH0*Parptr->xsz*Parptr->ysz+3*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:176:        Arrptr->TRecx[p0]=Solverptr->Tstep;
./por_flow.cpp:187:          Arrptr->LimQx[p0]=Q;
./por_flow.cpp:217:  z0=Arrptr->DEM[p0];
./por_flow.cpp:218:  z1=Arrptr->DEM[p1];
./por_flow.cpp:219:  h0=Arrptr->H[p0];
./por_flow.cpp:220:  h1=Arrptr->H[p1];
./por_flow.cpp:222:  if(Arrptr->Manningsn!=NULL) fn=C(0.5)*(Arrptr->Manningsn[p0]+Arrptr->Manningsn[p1]);
./por_flow.cpp:234:    if(MaskTest(Arrptr->ChanMask[p0],Arrptr->ChanMask[p1]) && hflow>Solverptr->DepthThresh) 
./por_flow.cpp:244:        por0=Arrptr->paerial[p0];
./por_flow.cpp:245:        por1=Arrptr->paerial[p1];
./por_flow.cpp:255:        por0=Arrptr->paerial[i+j*Parptr->xsz+pH0*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:256:        por1=Arrptr->paerial[i+j*Parptr->xsz+pH1*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:262:        por0=Arrptr->pbound[i+j*Parptr->xsz+2*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:263:        por1=Arrptr->pbound[i+1+j*Parptr->xsz+0*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:273:        por0=Arrptr->pbound[i+j*Parptr->xsz+pH0*Parptr->xsz*Parptr->ysz+2*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:274:        por1=Arrptr->pbound[i+1+j*Parptr->xsz+pH0*Parptr->xsz*Parptr->ysz+0*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:283:        Arrptr->TRecy[p0]=Solverptr->Tstep;
./por_flow.cpp:295:          Arrptr->LimQy[p0]=Q;
./por_flow.cpp:310:    if(MaskTest(Arrptr->ChanMask[p0],Arrptr->ChanMask[p1]) && hflow>Solverptr->DepthThresh) 
./por_flow.cpp:320:        por0=Arrptr->paerial[p0];
./por_flow.cpp:321:        por1=Arrptr->paerial[p1];
./por_flow.cpp:331:        por0=Arrptr->paerial[i+j*Parptr->xsz+pH0*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:332:        por1=Arrptr->paerial[i+j*Parptr->xsz+pH1*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:338:        por0=Arrptr->pbound[i+j*Parptr->xsz+0*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:339:        por1=Arrptr->pbound[i+1+j*Parptr->xsz+2*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:349:        por0=Arrptr->pbound[i+j*Parptr->xsz+pH0*Parptr->xsz*Parptr->ysz+0*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:350:        por1=Arrptr->pbound[i+1+j*Parptr->xsz+pH0*Parptr->xsz*Parptr->ysz+2*Parptr->xsz*Parptr->ysz];
./por_flow.cpp:359:        Arrptr->TRecy[p0]=Solverptr->Tstep;
./por_flow.cpp:370:          Arrptr->LimQy[p0]=Q;
./por_flow.cpp:397:  h0=Arrptr->H[p0];
./por_flow.cpp:403:    por0=Arrptr->paerial[p0];
./por_flow.cpp:410:    por0=Arrptr->paerial[i+j*Parptr->xsz+pH0*Parptr->xsz*Parptr->ysz];
./util.cpp:27:		hptr = Arrptr->H + j*Parptr->xsz;
./util.cpp:30:			q1 = Arrptr->Qx + j*(Parptr->xsz + 1) + i;
./util.cpp:31:			q2 = Arrptr->Qx + j*(Parptr->xsz + 1) + i + 1;
./util.cpp:32:			q3 = Arrptr->Qy + j*(Parptr->xsz + 1) + i;
./util.cpp:33:			q4 = Arrptr->Qy + (j + 1)*(Parptr->xsz + 1) + i;
./util.cpp:93:					por0 = Arrptr->paerial[p0];
./util.cpp:95:					if (Arrptr->ChanMask[p0] == -1) vol += Arrptr->H[p0] * dAPor;
./util.cpp:99:					pH0 = (int)(Arrptr->H[p0] / Parptr->zlev);
./util.cpp:101:					por0 = Arrptr->paerial[i + j*Parptr->xsz + pH0*Parptr->xsz*Parptr->ysz];
./util.cpp:103:					if (Arrptr->ChanMask[p0] == -1) vol += Arrptr->H[p0] * dAPor;
./util.cpp:109:				vol += Arrptr->SGCVol[p0];
./util.cpp:113:				if (Arrptr->ChanMask[p0] == -1) vol += Arrptr->H[p0] * Parptr->dA;
./util.cpp:127:				vol += Arrptr->H[pi + pj*Parptr->xsz] * csp->ChanWidth[i] * csp->Chandx[i];
./util.cpp:129:				HeightOverBank = Arrptr->DEM[pi + pj*Parptr->xsz] + Arrptr->H[pi + pj*Parptr->xsz] - csp->BankZ[i];
./util.cpp:160:			zchan = Arrptr->DEM[pi + pj*Parptr->xsz];
./util.cpp:166:							if (Arrptr->ChanMask[pi + di + (pj + dj)*Parptr->xsz] == -1){
./util.cpp:167:								if (Arrptr->DEM[pi + di + (pj + dj)*Parptr->xsz] < (zchan + Solverptr->htol)){
./util.cpp:168:									Arrptr->DEM[pi + di + (pj + dj)*Parptr->xsz] = zchan + Solverptr->htol;
./util.cpp:207:			Xv = getmax(fabs(Arrptr->Vx[pxy0]), fabs(Arrptr->Vx[px1]));
./util.cpp:208:			Yv = getmax(fabs(Arrptr->Vy[pxy0]), fabs(Arrptr->Vy[pyl]));
./util.cpp:211:			Haz = Arrptr->H[p0] * (Vc + C(1.5)); // Changed to equation from DEFRA 2006 (ALD)
./util.cpp:212:			Arrptr->maxHaz[p0] = getmax(Arrptr->maxHaz[p0], Haz);
./util.cpp:213:			if (Vc > Arrptr->maxVc[p0])
./util.cpp:215:				Arrptr->maxVc[p0] = Vc;
./util.cpp:216:				Arrptr->maxVcH[p0] = Arrptr->H[p0];
./util.cpp:280:				Arrptr->dx[p0] = Parptr->dx;
./util.cpp:281:				Arrptr->dy[p0] = Parptr->dy;
./util.cpp:282:				Arrptr->dA[p0] = Parptr->dA;
./util.cpp:333:				Arrptr->dx[p0] = dx;
./util.cpp:339:				Arrptr->dy[p0] = dy;
./util.cpp:342:				Arrptr->dA[p0] = Arrptr->dx[p0] * Arrptr->dy[p0];
./input_orig.cpp:137:	Arrptr->weir_count = nw;
./input_orig.cpp:139:	Arrptr->Weir_hc = memory_allocate_numeric_legacy(nw);
./input_orig.cpp:140:	Arrptr->Weir_Cd = memory_allocate_numeric_legacy(nw);
./input_orig.cpp:141:	Arrptr->Weir_m = memory_allocate_numeric_legacy(nw);
./input_orig.cpp:142:	Arrptr->Weir_w = memory_allocate_numeric_legacy(nw);
./input_orig.cpp:143:	Arrptr->Weir_Typ = new EWeirType[nw]; // type of structure... weir = 0, bridge = 1;
./input_orig.cpp:145:	Arrptr->Weir_Fixdir = new EDirection[nw];   // Fixed flow directions
./input_orig.cpp:146:	Arrptr->Weir_Identx = new int[(Parptr->xsz + 1)*(Parptr->ysz + 1)];
./input_orig.cpp:147:	Arrptr->Weir_Identy = new int[(Parptr->xsz + 1)*(Parptr->ysz + 1)];
./input_orig.cpp:150:	SetArrayValue(Arrptr->Weir_Identx, -1, (Parptr->xsz + 1) * (Parptr->ysz + 1));
./input_orig.cpp:151:	SetArrayValue(Arrptr->Weir_Identy, -1, (Parptr->xsz + 1) * (Parptr->ysz + 1));
./input_orig.cpp:162:			&x, &y, char_tmp, Arrptr->Weir_Cd + i, Arrptr->Weir_hc + i, Arrptr->Weir_m + i, Arrptr->Weir_w + i) != 7)
./input_orig.cpp:163:			Arrptr->Weir_w[i] = Parptr->dx;
./input_orig.cpp:177:			Arrptr->Weir_Identx[xi + 1 + yi*(Parptr->xsz + 1)] = i;
./input_orig.cpp:178:			Arrptr->Weir_Fixdir[i] = DirectionNA;
./input_orig.cpp:179:			Arrptr->Weir_Typ[i] = EWeir_Weir;
./input_orig.cpp:183:			Arrptr->Weir_Identx[xi + yi*(Parptr->xsz + 1)] = i;
./input_orig.cpp:184:			Arrptr->Weir_Fixdir[i] = DirectionNA;
./input_orig.cpp:185:			Arrptr->Weir_Typ[i] = EWeir_Weir;
./input_orig.cpp:189:			Arrptr->Weir_Identy[xi + yi*(Parptr->xsz + 1)] = i;
./input_orig.cpp:190:			Arrptr->Weir_Fixdir[i] = DirectionNA;
./input_orig.cpp:191:			Arrptr->Weir_Typ[i] = EWeir_Weir;
./input_orig.cpp:195:			Arrptr->Weir_Identy[xi + (yi + 1)*(Parptr->xsz + 1)] = i;
./input_orig.cpp:196:			Arrptr->Weir_Fixdir[i] = DirectionNA;
./input_orig.cpp:197:			Arrptr->Weir_Typ[i] = EWeir_Weir;
./input_orig.cpp:203:			Arrptr->Weir_Identx[xi + 1 + yi*(Parptr->xsz + 1)] = i;
./input_orig.cpp:204:			Arrptr->Weir_Fixdir[i] = West;
./input_orig.cpp:205:			Arrptr->Weir_Typ[i] = EWeir_Weir;
./input_orig.cpp:209:			Arrptr->Weir_Identx[xi + yi*(Parptr->xsz + 1)] = i;
./input_orig.cpp:210:			Arrptr->Weir_Fixdir[i] = East;
./input_orig.cpp:211:			Arrptr->Weir_Typ[i] = EWeir_Weir;
./input_orig.cpp:215:			Arrptr->Weir_Identy[xi + yi*(Parptr->xsz + 1)] = i;
./input_orig.cpp:216:			Arrptr->Weir_Fixdir[i] = South;
./input_orig.cpp:217:			Arrptr->Weir_Typ[i] = EWeir_Weir;
./input_orig.cpp:221:			Arrptr->Weir_Identy[xi + (yi + 1)*(Parptr->xsz + 1)] = i;
./input_orig.cpp:222:			Arrptr->Weir_Fixdir[i] = North;
./input_orig.cpp:223:			Arrptr->Weir_Typ[i] = EWeir_Weir;
./input_orig.cpp:228:			Arrptr->Weir_Identx[xi + 1 + yi*(Parptr->xsz + 1)] = i;
./input_orig.cpp:229:			Arrptr->Weir_Fixdir[i] = DirectionNA;
./input_orig.cpp:230:			Arrptr->Weir_Typ[i] = EWeir_Bridge;
./input_orig.cpp:234:			Arrptr->Weir_Identx[xi + yi*(Parptr->xsz + 1)] = i;
./input_orig.cpp:235:			Arrptr->Weir_Fixdir[i] = DirectionNA;
./input_orig.cpp:236:			Arrptr->Weir_Typ[i] = EWeir_Bridge;
./input_orig.cpp:240:			Arrptr->Weir_Identy[xi + yi*(Parptr->xsz + 1)] = i;
./input_orig.cpp:241:			Arrptr->Weir_Fixdir[i] = DirectionNA;
./input_orig.cpp:242:			Arrptr->Weir_Typ[i] = EWeir_Bridge;
./input_orig.cpp:246:			Arrptr->Weir_Identy[xi + (yi + 1)*(Parptr->xsz + 1)] = i;
./input_orig.cpp:247:			Arrptr->Weir_Fixdir[i] = DirectionNA;
./input_orig.cpp:248:			Arrptr->Weir_Typ[i] = EWeir_Bridge;
./input_orig.cpp:251:		// now a check to make sure that Arrptr->Weir_hc is greater than the ground elevation,
./input_orig.cpp:256:		if (Statesptr->SGC == ON && Arrptr->SGCwidth[p0] > C(0.0)) z0 = Arrptr->SGCz[p0];
./input_orig.cpp:257:		else z0 = Arrptr->DEM[p0];
./input_orig.cpp:275:		if (Statesptr->SGC == ON && Arrptr->SGCwidth[p1] > C(0.0)) z1 = Arrptr->SGCz[p1];
./input_orig.cpp:276:		else z1 = Arrptr->DEM[p1];
./input_orig.cpp:279:		if (Arrptr->Weir_hc[i] < z0 || Arrptr->Weir_hc[i] < z1)
./input_orig.cpp:283:				if (Arrptr->Weir_Typ[i] == EWeir_Weir)
./input_orig.cpp:289:					Arrptr->Weir_hc[i] = getmax(z0, z1);
./input_orig.cpp:290:					if (verbose == ON) printf("Weir number %i crest height increased to %.3" NUM_FMT" m\n", i, Arrptr->Weir_hc[i]);
./input_orig.cpp:296:				//Arrptr->Weir_Typ[i] = 0;
./input_orig.cpp:558:						Arrptr->ChanMask[ni + nj*Parptr->xsz] = 1; // mark mask with value of 1 - will renumber later in order
./input_orig.cpp:563:						if (Arrptr->ChanMask[ni + nj*Parptr->xsz] == -1)   // channel mask not set
./input_orig.cpp:567:							Arrptr->ChanMask[ni + nj*Parptr->xsz] = 1; // mark mask with value of 1 - will renumber later in order
./input_orig.cpp:637:			Arrptr->ChanMask[pi + pj*Parptr->xsz] = i;
./input_orig.cpp:639:			csp->BankZ[i] = Arrptr->DEM[pi + pj*Parptr->xsz];
./input_orig.cpp:641:			Arrptr->SegMask[pi + pj*Parptr->xsz] = chseg;
./input_orig.cpp:698:						Arrptr->DEM[pi + pj*Parptr->xsz] = hp[i1] + (hp[i2] - hp[i1])*(csp->Chainage[i] - cp[i1]) / (cp[i2] - cp[i1]);
./input_orig.cpp:715:					grad = (Arrptr->DEM[csp->ChanX[i] + csp->ChanY[i] * Parptr->xsz] - Arrptr->DEM[csp->ChanX[i - 1] + csp->ChanY[i - 1] * Parptr->xsz])
./input_orig.cpp:720:					grad = (Arrptr->DEM[csp->ChanX[i + 1] + csp->ChanY[i + 1] * Parptr->xsz] - Arrptr->DEM[csp->ChanX[i] + csp->ChanY[i] * Parptr->xsz])
./input_orig.cpp:729:					grad = (csp->JunctionDEM - Arrptr->DEM[csp->ChanX[i] + csp->ChanY[i] * Parptr->xsz])
./input_orig.cpp:735:					grad = (csp->JunctionDEM - Arrptr->DEM[csp->ChanX[i - 1] + csp->ChanY[i - 1] * Parptr->xsz])
./input_orig.cpp:740:					grad = (Arrptr->DEM[csp->ChanX[i + 1] + csp->ChanY[i + 1] * Parptr->xsz] - Arrptr->DEM[csp->ChanX[i] + csp->ChanY[i] * Parptr->xsz])
./input_orig.cpp:897:	Arrptr->dist_infiltration = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:900:		fscanf(fp, "%" NUM_FMT"", Arrptr->dist_infiltration + i + j * Parptr->xsz);
./input_orig.cpp:901:		if (AreEqual(Arrptr->dist_infiltration[i + j * Parptr->xsz], no_data_value))
./input_orig.cpp:902:			Arrptr->dist_infiltration[i + j * Parptr->xsz] = 0.0;
./input_orig.cpp:904:		Arrptr->dist_infiltration[i + j * Parptr->xsz] = Arrptr->dist_infiltration[i + j * Parptr->xsz] / 60 / 60 / 1000;
./input_orig.cpp:929:	Arrptr->Manningsn = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:932:		fscanf(fp, "%" NUM_FMT"", Arrptr->Manningsn + i + j*Parptr->xsz);
./input_orig.cpp:933:		if (AreEqual(Arrptr->Manningsn[i + j*Parptr->xsz], no_data_value))
./input_orig.cpp:934:			Arrptr->Manningsn[i + j*Parptr->xsz] = Parptr->FPn;
./input_orig.cpp:956:	Arrptr->SGCManningsn = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:959:		fscanf(fp, "%" NUM_FMT"", Arrptr->SGCManningsn + i + j*Parptr->xsz);
./input_orig.cpp:960:		if (AreEqual(Arrptr->SGCManningsn[i + j*Parptr->xsz], no_data_value))
./input_orig.cpp:961:			Arrptr->SGCManningsn[i + j*Parptr->xsz] = Parptr->SGC_n;
./input_orig.cpp:1023:		Arrptr->paerial = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1026:			fscanf(fp, "%" NUM_FMT"", Arrptr->paerial + i + j*Parptr->xsz);
./input_orig.cpp:1027:			if (AreEqual(Arrptr->paerial[i + j*Parptr->xsz], no_data_value))
./input_orig.cpp:1028:				Arrptr->paerial[i + j*Parptr->xsz] = 1;
./input_orig.cpp:1040:		Arrptr->paerial = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz*Parptr->zsz);
./input_orig.cpp:1047:				fscanf(fp, "%" NUM_FMT"", Arrptr->paerial + i + j*Parptr->xsz + k*Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1048:				if (AreEqual(Arrptr->paerial[i + j*Parptr->xsz + k*Parptr->xsz*Parptr->ysz], no_data_value))
./input_orig.cpp:1049:					Arrptr->paerial[i + j*Parptr->xsz + k*Parptr->xsz*Parptr->ysz] = 1;
./input_orig.cpp:1061:		Arrptr->paerial = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1062:		Arrptr->pbound = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz * 4);
./input_orig.cpp:1066:			fscanf(fp, "%" NUM_FMT"", Arrptr->paerial + i + j*Parptr->xsz);
./input_orig.cpp:1067:			if (AreEqual(Arrptr->paerial[i + j*Parptr->xsz], no_data_value))
./input_orig.cpp:1068:				Arrptr->paerial[i + j*Parptr->xsz] = 1;
./input_orig.cpp:1077:				fscanf(fp, "%" NUM_FMT"", Arrptr->pbound + i + j*Parptr->xsz + k*Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1078:				if (AreEqual(Arrptr->pbound[i + j*Parptr->xsz + k*Parptr->xsz*Parptr->ysz], no_data_value))
./input_orig.cpp:1079:					Arrptr->pbound[i + j*Parptr->xsz + k*Parptr->xsz*Parptr->ysz] = 1;
./input_orig.cpp:1093:		Arrptr->paerial = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz*Parptr->zsz);
./input_orig.cpp:1094:		Arrptr->pbound = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz*Parptr->zsz * 4);
./input_orig.cpp:1101:				fscanf(fp, "%" NUM_FMT"", Arrptr->paerial + i + j*Parptr->xsz + k*Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1102:				if (AreEqual(Arrptr->paerial[i + j*Parptr->xsz + k*Parptr->xsz*Parptr->ysz], no_data_value))
./input_orig.cpp:1103:					Arrptr->paerial[i + j*Parptr->xsz + k*Parptr->xsz*Parptr->ysz] = 1;
./input_orig.cpp:1114:				fscanf(fp, "%" NUM_FMT"", Arrptr->pbound + i + j*Parptr->xsz + m*Parptr->xsz*Parptr->ysz + k*Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1115:				if (AreEqual(Arrptr->pbound[i + j*Parptr->xsz + m*Parptr->xsz*Parptr->ysz + k*Parptr->xsz*Parptr->ysz], no_data_value))
./input_orig.cpp:1117:					Arrptr->pbound[i + j*Parptr->xsz + m*Parptr->xsz*Parptr->ysz + k*Parptr->xsz*Parptr->ysz] = 1;
./input_orig.cpp:1137:			//fscanf(fp, "%" NUM_FMT"", Arrptr->H + i + j*Parptr->xsz);
./input_orig.cpp:1139:			if (AreEqual(Arrptr->H[i + j*Parptr->xsz], no_data_value)) Arrptr->H[i + j*Parptr->xsz] = C(0.0);
./input_orig.cpp:1145:					gr = Arrptr->SGCgroup[i + j*Parptr->xsz]; // channel group number
./input_orig.cpp:1147:					Arrptr->H[i + j*Parptr->xsz] = getmax(Arrptr->H[i + j*Parptr->xsz] - Arrptr->SGCz[i + j*Parptr->xsz], C(0.0));
./input_orig.cpp:1149:					if (Arrptr->H[i + j*Parptr->xsz] <= Arrptr->SGCbfH[i + j*Parptr->xsz])
./input_orig.cpp:1150:						Arrptr->SGCVol[i + j*Parptr->xsz] = CalcSGC_UpV(SGCptr->SGCchantype[gr], Arrptr->H[i + j*Parptr->xsz], SGCptr->SGCs[gr], Arrptr->SGCc[i + j*Parptr->xsz]);
./input_orig.cpp:1151:					else if (Arrptr->SGCwidth[i + j*Parptr->xsz] >= C(0.5)*(Arrptr->dx[i + j*Parptr->xsz] + Arrptr->dy[i + j*Parptr->xsz]))
./input_orig.cpp:1152:						Arrptr->SGCVol[i + j*Parptr->xsz] = CalcSGC_UpV(SGCptr->SGCchantype[gr], Arrptr->H[i + j*Parptr->xsz], SGCptr->SGCs[gr], Arrptr->SGCc[i + j*Parptr->xsz]);
./input_orig.cpp:1154:						Arrptr->SGCVol[i + j*Parptr->xsz] = Arrptr->SGCbfV[i + j*Parptr->xsz] + (Arrptr->H[i + j*Parptr->xsz] 
./input_orig.cpp:1155:							- Arrptr->SGCbfH[i + j*Parptr->xsz])*(Arrptr->dx[i + j*Parptr->xsz] * Arrptr->dy[i + j*Parptr->xsz]); // out of bank level * cell area
./input_orig.cpp:1158:					Arrptr->H[i + j*Parptr->xsz] = getmax(Arrptr->H[i + j*Parptr->xsz] - Arrptr->DEM[i + j*Parptr->xsz], C(0.0));
./input_orig.cpp:1163:				gr = Arrptr->SGCgroup[i + j*Parptr->xsz]; // channel group number
./input_orig.cpp:1164:				if (Arrptr->H[i + j*Parptr->xsz] <= Arrptr->SGCbfH[i + j*Parptr->xsz])
./input_orig.cpp:1165:					Arrptr->SGCVol[i + j*Parptr->xsz] = CalcSGC_UpV(SGCptr->SGCchantype[gr], Arrptr->H[i + j*Parptr->xsz], SGCptr->SGCs[gr], Arrptr->SGCc[i + j*Parptr->xsz]);
./input_orig.cpp:1166:				else if (Arrptr->SGCwidth[i + j*Parptr->xsz] >= C(0.5)*(Arrptr->dx[i + j*Parptr->xsz] + Arrptr->dy[i + j*Parptr->xsz]))
./input_orig.cpp:1167:					Arrptr->SGCVol[i + j*Parptr->xsz] = CalcSGC_UpV(SGCptr->SGCchantype[gr], Arrptr->H[i + j*Parptr->xsz], SGCptr->SGCs[gr], Arrptr->SGCc[i + j*Parptr->xsz]);
./input_orig.cpp:1169:					Arrptr->SGCVol[i + j*Parptr->xsz] = Arrptr->SGCbfV[i + j*Parptr->xsz] + (Arrptr->H[i + j*Parptr->xsz] - Arrptr->SGCbfH[i + j*Parptr->xsz])*(Arrptr->dx[i + j*Parptr->xsz] * Arrptr->dy[i + j*Parptr->xsz]); // out of bank level
./input_orig.cpp:1192:			fscanf(fp, "%" NUM_FMT"", Arrptr->H + i + j*Parptr->xsz);
./input_orig.cpp:1227:		fread(Arrptr->H + j*Parptr->xsz, sizeof(NUMERIC_TYPE), Parptr->xsz, fp);
./input_orig.cpp:1232:		//	if ((int)Arrptr->H[i + j*Parptr->xsz] == no_data_value) Arrptr->H[i + j*Parptr->xsz] = C(0.0);
./input_orig.cpp:1236:		//		if (Statesptr->SGC == ON) Arrptr->H[i + j*Parptr->xsz] = getmax(Arrptr->H[i + j*Parptr->xsz] - Arrptr->SGCz[i + j*Parptr->xsz], C(0.0));
./input_orig.cpp:1237:		//		else Arrptr->H[i + j*Parptr->xsz] = getmax(Arrptr->H[i + j*Parptr->xsz] - Arrptr->DEM[i + j*Parptr->xsz], C(0.0));
./input_orig.cpp:1276:			fscanf(fp, "%" NUM_FMT"", Arrptr->HU + i + j*Parptr->xsz);
./input_orig.cpp:1289:			fscanf(fp, "%" NUM_FMT"", Arrptr->HV + i + j*Parptr->xsz);
./input_orig.cpp:1310:	Arrptr->H = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1314:		Arrptr->HU = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1315:		Arrptr->HV = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1316:		Arrptr->LSHU = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1317:		Arrptr->RSHU = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1318:		Arrptr->BSHU = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1319:		Arrptr->TSHU = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1320:		Arrptr->LSHV = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1321:		Arrptr->RSHV = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1322:		Arrptr->BSHV = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1323:		Arrptr->TSHV = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1324:		Arrptr->FHx = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input_orig.cpp:1325:		Arrptr->FHUx = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input_orig.cpp:1326:		Arrptr->FHVx = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input_orig.cpp:1327:		Arrptr->FHy = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input_orig.cpp:1328:		Arrptr->FHUy = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input_orig.cpp:1329:		Arrptr->FHVy = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input_orig.cpp:1340:	Arrptr->maxH = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1341:	Arrptr->totalHtm = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1342:	Arrptr->Qx = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input_orig.cpp:1343:	Arrptr->Qy = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input_orig.cpp:1345:	//Arrptr->Hflowx=memory_allocate_zero_numeric_legacy((Parptr->xsz+1)*(Parptr->ysz+1));
./input_orig.cpp:1346:	//Arrptr->Hflowy=memory_allocate_zero_numeric_legacy((Parptr->xsz+1)*(Parptr->ysz+1));
./input_orig.cpp:1350:		Arrptr->Vx = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input_orig.cpp:1351:		Arrptr->Vy = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input_orig.cpp:1352:		Arrptr->maxVx = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input_orig.cpp:1353:		Arrptr->maxVy = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input_orig.cpp:1357:		Arrptr->maxVc = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1358:		Arrptr->maxVcH = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1359:		Arrptr->maxHaz = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1364:		Arrptr->SGCwidth = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1365:		Arrptr->SGCz = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1366:		Arrptr->SGCc = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1369:		Arrptr->QxSGold = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input_orig.cpp:1370:		Arrptr->QySGold = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input_orig.cpp:1372:		Arrptr->SGCbfH = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1373:		Arrptr->SGCbfV = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1375:		Arrptr->SGCVol = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1376:		Arrptr->SGCdVol = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1378:		Arrptr->SGCgroup = new int[Parptr->xsz*Parptr->ysz]();
./input_orig.cpp:1381:			Arrptr->SGCFlowWidth = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1385:	Arrptr->Qxold = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input_orig.cpp:1386:	Arrptr->Qyold = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input_orig.cpp:1391:	Arrptr->U = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input_orig.cpp:1392:	//Arrptr->V=memory_allocate_zero_numeric_legacy((Parptr->xsz+1)*(Parptr->ysz+1));
./input_orig.cpp:1395:	Arrptr->maxHtm = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1396:	Arrptr->initHtm = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1397:	Arrptr->TRecx = memory_allocate_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input_orig.cpp:1398:	Arrptr->TRecy = memory_allocate_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input_orig.cpp:1399:	Arrptr->LimQx = memory_allocate_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input_orig.cpp:1400:	Arrptr->LimQy = memory_allocate_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input_orig.cpp:1402:	Arrptr->ChanMask = new int[Parptr->xsz*Parptr->ysz];
./input_orig.cpp:1403:	Arrptr->SegMask = new int[Parptr->xsz*Parptr->ysz];
./input_orig.cpp:1405:	Arrptr->DEM = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1410:		Arrptr->FlowDir = new int[Parptr->xsz*Parptr->ysz]();
./input_orig.cpp:1411:		for (i = 0; i < Parptr->xsz*Parptr->ysz; i++) Arrptr->FlowDir[i] = (int)NULLVAL;
./input_orig.cpp:1415:	Arrptr->dx = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1416:	Arrptr->dy = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1417:	Arrptr->dA = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:1422:	for (i = 0; i < Parptr->xsz*Parptr->ysz; i++) Arrptr->maxHtm[i] = NULLVAL;
./input_orig.cpp:1423:	for (i = 0; i < Parptr->xsz*Parptr->ysz; i++) Arrptr->initHtm[i] = NULLVAL;
./input_orig.cpp:1424:	for (i = 0; i < (Parptr->xsz + 1)*(Parptr->ysz + 1); i++) Arrptr->TRecx[i] = NULLVAL;
./input_orig.cpp:1425:	for (i = 0; i < (Parptr->xsz + 1)*(Parptr->ysz + 1); i++) Arrptr->TRecy[i] = NULLVAL;
./input_orig.cpp:1426:	for (i = 0; i < (Parptr->xsz + 1)*(Parptr->ysz + 1); i++) Arrptr->LimQx[i] = NULLVAL;
./input_orig.cpp:1427:	for (i = 0; i < (Parptr->xsz + 1)*(Parptr->ysz + 1); i++) Arrptr->LimQy[i] = NULLVAL;
./input_orig.cpp:1430:	for (i = 0; i < Parptr->xsz*Parptr->ysz; i++) Arrptr->ChanMask[i] = -1;
./input_orig.cpp:1431:	for (i = 0; i < Parptr->xsz*Parptr->ysz; i++) Arrptr->SegMask[i] = -1;
./input_orig.cpp:1433:	LoadDEMData(Parptr, Arrptr->DEM, fp, no_data_value);
./input_orig.cpp:2088:	Arrptr->evap = LoadTimeSeries(Fnameptr->evapfilename, fp, ON);
./input_orig.cpp:2092:	for (i = 0; i < Arrptr->evap->count; i++)
./input_orig.cpp:2093:		Arrptr->evap->value[i] /= (1000 * 24 * 3600);
./input_orig.cpp:2108:	Arrptr->rain = LoadTimeSeries(Fnameptr->rainfilename, fp, ON);
./input_orig.cpp:2112:	for (i = 0; i < Arrptr->rain->count; i++)
./input_orig.cpp:2113:		Arrptr->rain->value[i] /= (1000 * 3600);
./input_orig.cpp:2140:	Arrptr->Rainmask = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input_orig.cpp:2144:		fscanf(fp, "%" NUM_FMT"", Arrptr->Rainmask + i + j*Parptr->xsz);
./input_orig.cpp:2145:		if (AreEqual(Arrptr->Rainmask[i + j*Parptr->xsz], no_data_value))
./input_orig.cpp:2146:			Arrptr->Rainmask[i + j*Parptr->xsz] = 0;
./input_orig.cpp:2166:		memset(Arrptr->SGCwidth, 0, sizeof(NUMERIC_TYPE)*(Parptr->xsz)*(Parptr->ysz));
./input_orig.cpp:2167:		memcpy(Arrptr->SGCz, Arrptr->DEM, sizeof(NUMERIC_TYPE)*(Parptr->xsz)*(Parptr->ysz));
./input_orig.cpp:2177:			fscanf(fp, "%" NUM_FMT"", Arrptr->SGCz + i + j*Parptr->xsz);
./input_orig.cpp:2178:			if (AreEqual(Arrptr->SGCz[i + j*Parptr->xsz], no_data_value))
./input_orig.cpp:2179:				Arrptr->SGCz[i + j*Parptr->xsz] = Arrptr->DEM[i + j*Parptr->xsz]; // In the case of no_data_value set the bank height to the DEM
./input_orig.cpp:2190:			fscanf(fp, "%" NUM_FMT"", Arrptr->SGCwidth + i + j*Parptr->xsz);
./input_orig.cpp:2191:			if (AreEqual( Arrptr->SGCwidth[i + j*Parptr->xsz], no_data_value))
./input_orig.cpp:2192:				Arrptr->SGCwidth[i + j*Parptr->xsz] = C(0.0); // In the case of no_data_value set the width to zero
./input_orig.cpp:2209:			Arrptr->SGCgroup[i + j*Parptr->xsz] = (int)tmp;
./input_orig.cpp:2210:			if (AreEqual(Arrptr->SGCgroup[i + j*Parptr->xsz], no_data_value) || Arrptr->SGCgroup[i + j*Parptr->xsz] < 0) 
./input_orig.cpp:2211:				Arrptr->SGCgroup[i + j*Parptr->xsz] = 0; // In the case of no_data_value set the chan group to zero
./input_orig.cpp:2219:		memset(Arrptr->ChanMask, 0, sizeof(int)*(Parptr->xsz)*(Parptr->ysz));
./input_orig.cpp:2229:			if (AreEqual(tmp, no_data_value)) Arrptr->ChanMask[i + j*Parptr->xsz] = 0; // In the case of no_data_value set the chan mask to zero
./input_orig.cpp:2230:			else if (tmp > C(0.0)) Arrptr->ChanMask[i + j*Parptr->xsz] = 1; // a positive number is a mask cell 1
./input_orig.cpp:2231:			else Arrptr->ChanMask[i + j*Parptr->xsz] = 0; // anything else is a no mask cell 0
./input_orig.cpp:2452:	read_file(Fnameptr->DamMaskfilename, no_data_value, &num_cols, &num_rows, &Arrptr->DamMask, &xllcorner, &yllcorner, &cell_size);
./input_orig.cpp:2457:		if (Arrptr->DamMask[i + j*Parptr->xsz] < C(0.0)) 
./input_orig.cpp:2459:			Arrptr->DEM[i + j*Parptr->xsz] = no_data_value;
./input_orig.cpp:2460:			if (AreEqual(Arrptr->DEM[i + j*Parptr->xsz], no_data_value))
./input_orig.cpp:2461:			Arrptr->DEM[i + j*Parptr->xsz] = DEM_NO_DATA;
./input_orig.cpp:2468:		if (Arrptr->DamMask[i + j*Parptr->xsz]== (n+1))
./swe/dg2.cpp:136:		NUMERIC_TYPE& H = Arrptr->H[j*Parptr->xsz + i];
./swe/dg2.cpp:142:				NUMERIC_TYPE Z = Arrptr->DEM[j*Parptr->xsz + i];
./swe/dg2.cpp:152:				NUMERIC_TYPE Z = Arrptr->DEM[j*Parptr->xsz + i];
./swe/dg2.cpp:199:		NUMERIC_TYPE Zstar = Arrptr->Zstar_x[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:201:		NUMERIC_TYPE H_inside = limit_pos(Arrptr->H, Arrptr->H1x, Parptr, i, j);
./swe/dg2.cpp:202:		NUMERIC_TYPE HU_inside = limit_pos(Arrptr->HU, Arrptr->HU1x,
./swe/dg2.cpp:204:		NUMERIC_TYPE HV_inside = limit_pos(Arrptr->HV, Arrptr->HV1x,
./swe/dg2.cpp:207:		NUMERIC_TYPE H_const = Arrptr->H[j*Parptr->xsz + i];
./swe/dg2.cpp:208:		NUMERIC_TYPE HU_const = Arrptr->HU[j*Parptr->xsz + i];
./swe/dg2.cpp:209:		NUMERIC_TYPE HV_const = Arrptr->HV[j*Parptr->xsz + i];
./swe/dg2.cpp:212:		NUMERIC_TYPE& H_outside = Arrptr->boundary.H[bc_i];
./swe/dg2.cpp:213:		NUMERIC_TYPE& HU_outside = Arrptr->boundary.HU[bc_i];
./swe/dg2.cpp:214:		NUMERIC_TYPE& HV_outside = Arrptr->boundary.HV[bc_i];
./swe/dg2.cpp:227:		NUMERIC_TYPE Zstar = Arrptr->Zstar_x[j*(Parptr->xsz+1) + i+1];
./swe/dg2.cpp:229:		NUMERIC_TYPE H_inside = limit_neg(Arrptr->H, Arrptr->H1x, Parptr, i, j);
./swe/dg2.cpp:230:		NUMERIC_TYPE HU_inside = limit_neg(Arrptr->HU, Arrptr->HU1x,
./swe/dg2.cpp:232:		NUMERIC_TYPE HV_inside = limit_neg(Arrptr->HV, Arrptr->HV1x,
./swe/dg2.cpp:235:		NUMERIC_TYPE H_const = Arrptr->H[j*Parptr->xsz + i];
./swe/dg2.cpp:236:		NUMERIC_TYPE HU_const = Arrptr->HU[j*Parptr->xsz + i];
./swe/dg2.cpp:237:		NUMERIC_TYPE HV_const = Arrptr->HV[j*Parptr->xsz + i];
./swe/dg2.cpp:240:		NUMERIC_TYPE& H_outside = Arrptr->boundary.H[bc_i];
./swe/dg2.cpp:241:		NUMERIC_TYPE& HU_outside = Arrptr->boundary.HU[bc_i];
./swe/dg2.cpp:242:		NUMERIC_TYPE& HV_outside = Arrptr->boundary.HV[bc_i];
./swe/dg2.cpp:255:		NUMERIC_TYPE Zstar = Arrptr->Zstar_y[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:257:		NUMERIC_TYPE H_inside = limit_neg(Arrptr->H, Arrptr->H1y, Parptr, i, j);
./swe/dg2.cpp:258:		NUMERIC_TYPE HU_inside = limit_neg(Arrptr->HU, Arrptr->HU1y,
./swe/dg2.cpp:260:		NUMERIC_TYPE HV_inside = limit_neg(Arrptr->HV, Arrptr->HV1y,
./swe/dg2.cpp:263:		NUMERIC_TYPE H_const = Arrptr->H[j*Parptr->xsz + i];
./swe/dg2.cpp:264:		NUMERIC_TYPE HU_const = Arrptr->HU[j*Parptr->xsz + i];
./swe/dg2.cpp:265:		NUMERIC_TYPE HV_const = Arrptr->HV[j*Parptr->xsz + i];
./swe/dg2.cpp:268:		NUMERIC_TYPE& H_outside = Arrptr->boundary.H[bc_i];
./swe/dg2.cpp:269:		NUMERIC_TYPE& HU_outside = Arrptr->boundary.HU[bc_i];
./swe/dg2.cpp:270:		NUMERIC_TYPE& HV_outside = Arrptr->boundary.HV[bc_i];
./swe/dg2.cpp:283:		NUMERIC_TYPE Zstar = Arrptr->Zstar_y[(j+1)*(Parptr->xsz+1) + i];
./swe/dg2.cpp:285:		NUMERIC_TYPE H_inside = limit_pos(Arrptr->H, Arrptr->H1y, Parptr, i, j);
./swe/dg2.cpp:286:		NUMERIC_TYPE HU_inside = limit_pos(Arrptr->HU, Arrptr->HU1y,
./swe/dg2.cpp:288:		NUMERIC_TYPE HV_inside = limit_pos(Arrptr->HV, Arrptr->HV1y,
./swe/dg2.cpp:291:		NUMERIC_TYPE H_const = Arrptr->H[j*Parptr->xsz + i];
./swe/dg2.cpp:292:		NUMERIC_TYPE HU_const = Arrptr->HU[j*Parptr->xsz + i];
./swe/dg2.cpp:293:		NUMERIC_TYPE HV_const = Arrptr->HV[j*Parptr->xsz + i];
./swe/dg2.cpp:296:		NUMERIC_TYPE& H_outside = Arrptr->boundary.H[bc_i];
./swe/dg2.cpp:297:		NUMERIC_TYPE& HU_outside = Arrptr->boundary.HU[bc_i];
./swe/dg2.cpp:298:		NUMERIC_TYPE& HV_outside = Arrptr->boundary.HV[bc_i];
./swe/dg2.cpp:344:                    Arrptr->H_int, Arrptr->H1x_int, Arrptr->H1y_int,
./swe/dg2.cpp:345:                    Arrptr->HU_int, Arrptr->HU1x_int, Arrptr->HU1y_int,
./swe/dg2.cpp:346:                    Arrptr->HV_int, Arrptr->HV1x_int, Arrptr->HV1y_int);
./swe/dg2.cpp:388:                    Arrptr->H, Arrptr->H1x, Arrptr->H1y,
./swe/dg2.cpp:389:                    Arrptr->HU, Arrptr->HU1x, Arrptr->HU1y,
./swe/dg2.cpp:390:                    Arrptr->HV, Arrptr->HV1x, Arrptr->HV1y);
./swe/dg2.cpp:408:			NUMERIC_TYPE H_neg = Arrptr->Hstar_neg_x[j*Parptr->xsz + i-1];
./swe/dg2.cpp:409:			NUMERIC_TYPE HU_neg = Arrptr->HUstar_neg_x[j*Parptr->xsz + i-1];
./swe/dg2.cpp:410:			NUMERIC_TYPE HV_neg = Arrptr->HVstar_neg_x[j*Parptr->xsz + i-1];
./swe/dg2.cpp:412:			NUMERIC_TYPE H_pos = Arrptr->Hstar_pos_x[j*Parptr->xsz + i];
./swe/dg2.cpp:413:			NUMERIC_TYPE HU_pos = Arrptr->HUstar_pos_x[j*Parptr->xsz + i];
./swe/dg2.cpp:414:			NUMERIC_TYPE HV_pos = Arrptr->HVstar_pos_x[j*Parptr->xsz + i];
./swe/dg2.cpp:416:			NUMERIC_TYPE& FHx = Arrptr->FHx[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:417:			NUMERIC_TYPE& FHUx = Arrptr->FHUx[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:418:			NUMERIC_TYPE& FHVx = Arrptr->FHVx[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:430:			NUMERIC_TYPE H_neg = Arrptr->Hstar_neg_y[j*Parptr->xsz + i];
./swe/dg2.cpp:431:			NUMERIC_TYPE HU_neg = Arrptr->HUstar_neg_y[j*Parptr->xsz + i];
./swe/dg2.cpp:432:			NUMERIC_TYPE HV_neg = Arrptr->HVstar_neg_y[j*Parptr->xsz + i];
./swe/dg2.cpp:434:			NUMERIC_TYPE H_pos = Arrptr->Hstar_pos_y[(j-1)*Parptr->xsz + i];
./swe/dg2.cpp:435:			NUMERIC_TYPE HU_pos = Arrptr->HUstar_pos_y[(j-1)*Parptr->xsz + i];
./swe/dg2.cpp:436:			NUMERIC_TYPE HV_pos = Arrptr->HVstar_pos_y[(j-1)*Parptr->xsz + i];
./swe/dg2.cpp:438:			NUMERIC_TYPE& FHy = Arrptr->FHy[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:439:			NUMERIC_TYPE& FHUy = Arrptr->FHUy[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:440:			NUMERIC_TYPE& FHVy = Arrptr->FHVy[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:462:		NUMERIC_TYPE Zstar = Arrptr->Zstar_x[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:464:		NUMERIC_TYPE H_inside = Arrptr->Hstar_pos_x[j*Parptr->xsz + i];
./swe/dg2.cpp:465:		NUMERIC_TYPE HU_inside = Arrptr->HUstar_pos_x[j*Parptr->xsz + i];
./swe/dg2.cpp:466:		NUMERIC_TYPE HV_inside = Arrptr->HVstar_pos_x[j*Parptr->xsz + i];
./swe/dg2.cpp:482:		NUMERIC_TYPE& FHx = Arrptr->FHx[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:483:		NUMERIC_TYPE& FHUx = Arrptr->FHUx[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:484:		NUMERIC_TYPE& FHVx = Arrptr->FHVx[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:495:		NUMERIC_TYPE Zstar = Arrptr->Zstar_x[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:497:		NUMERIC_TYPE H_inside = Arrptr->Hstar_neg_x[j*Parptr->xsz + i-1];
./swe/dg2.cpp:498:		NUMERIC_TYPE HU_inside = Arrptr->HUstar_neg_x[j*Parptr->xsz + i-1];
./swe/dg2.cpp:499:		NUMERIC_TYPE HV_inside = Arrptr->HVstar_neg_x[j*Parptr->xsz + i-1];
./swe/dg2.cpp:515:		NUMERIC_TYPE& FHx = Arrptr->FHx[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:516:		NUMERIC_TYPE& FHUx = Arrptr->FHUx[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:517:		NUMERIC_TYPE& FHVx = Arrptr->FHVx[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:528:		NUMERIC_TYPE Zstar = Arrptr->Zstar_y[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:530:		NUMERIC_TYPE H_inside = Arrptr->Hstar_neg_y[j*Parptr->xsz + i];
./swe/dg2.cpp:531:		NUMERIC_TYPE HU_inside = Arrptr->HUstar_neg_y[j*Parptr->xsz + i];
./swe/dg2.cpp:532:		NUMERIC_TYPE HV_inside = Arrptr->HVstar_neg_y[j*Parptr->xsz + i];
./swe/dg2.cpp:548:		NUMERIC_TYPE& FHy = Arrptr->FHy[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:549:		NUMERIC_TYPE& FHUy = Arrptr->FHUy[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:550:		NUMERIC_TYPE& FHVy = Arrptr->FHVy[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:561:		NUMERIC_TYPE Zstar = Arrptr->Zstar_y[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:563:		NUMERIC_TYPE H_inside = Arrptr->Hstar_pos_y[(j-1)*Parptr->xsz + i];
./swe/dg2.cpp:564:		NUMERIC_TYPE HU_inside = Arrptr->HUstar_pos_y[(j-1)*Parptr->xsz + i];
./swe/dg2.cpp:565:		NUMERIC_TYPE HV_inside = Arrptr->HVstar_pos_y[(j-1)*Parptr->xsz + i];
./swe/dg2.cpp:581:		NUMERIC_TYPE& FHy = Arrptr->FHy[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:582:		NUMERIC_TYPE& FHUy = Arrptr->FHUy[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:583:		NUMERIC_TYPE& FHVy = Arrptr->FHVy[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:666:			Arrptr->H, Arrptr->H_int, U_inc.H);
./swe/dg2.cpp:668:			Arrptr->H1x, Arrptr->H1x_int, U_inc.H1x);
./swe/dg2.cpp:670:			Arrptr->H1y, Arrptr->H1y_int, U_inc.H1y);
./swe/dg2.cpp:672:			Arrptr->HU, Arrptr->HU_int, U_inc.HU);
./swe/dg2.cpp:674:			Arrptr->HU1x, Arrptr->HU1x_int, U_inc.HU1x);
./swe/dg2.cpp:676:			Arrptr->HU1y, Arrptr->HU1y_int, U_inc.HU1y);
./swe/dg2.cpp:678:			Arrptr->HV, Arrptr->HV_int, U_inc.HV);
./swe/dg2.cpp:680:			Arrptr->HV1x, Arrptr->HV1x_int, U_inc.HV1x);
./swe/dg2.cpp:682:			Arrptr->HV1y, Arrptr->HV1y_int, U_inc.HV1y);
./swe/dg2.cpp:711:			Arrptr->H, Arrptr->H_int, U_inc.H);
./swe/dg2.cpp:713:			Arrptr->H1x, Arrptr->H1x_int, U_inc.H1x);
./swe/dg2.cpp:715:			Arrptr->H1y, Arrptr->H1y_int, U_inc.H1y);
./swe/dg2.cpp:717:			Arrptr->HU, Arrptr->HU_int, U_inc.HU);
./swe/dg2.cpp:719:			Arrptr->HU1x, Arrptr->HU1x_int, U_inc.HU1x);
./swe/dg2.cpp:721:			Arrptr->HU1y, Arrptr->HU1y_int, U_inc.HU1y);
./swe/dg2.cpp:723:			Arrptr->HV, Arrptr->HV_int, U_inc.HV);
./swe/dg2.cpp:725:			Arrptr->HV1x, Arrptr->HV1x_int, U_inc.HV1x);
./swe/dg2.cpp:727:			Arrptr->HV1y, Arrptr->HV1y_int, U_inc.HV1y);
./swe/dg2.cpp:751:	U.H = Arrptr->H;
./swe/dg2.cpp:752:	U.H1x = Arrptr->H1x;
./swe/dg2.cpp:753:	U.H1y = Arrptr->H1y;
./swe/dg2.cpp:754:	U.HU = Arrptr->HU;
./swe/dg2.cpp:755:	U.HU1x = Arrptr->HU1x;
./swe/dg2.cpp:756:	U.HU1y = Arrptr->HU1y;
./swe/dg2.cpp:757:	U.HV = Arrptr->HV;
./swe/dg2.cpp:758:	U.HV1x = Arrptr->HV1x;
./swe/dg2.cpp:759:	U.HV1y = Arrptr->HV1y;
./swe/dg2.cpp:768:	U_int.H = Arrptr->H_int;
./swe/dg2.cpp:769:	U_int.H1x = Arrptr->H1x_int;
./swe/dg2.cpp:770:	U_int.H1y = Arrptr->H1y_int;
./swe/dg2.cpp:771:	U_int.HU = Arrptr->HU_int;
./swe/dg2.cpp:772:	U_int.HU1x = Arrptr->HU1x_int;
./swe/dg2.cpp:773:	U_int.HU1y = Arrptr->HU1y_int;
./swe/dg2.cpp:774:	U_int.HV = Arrptr->HV_int;
./swe/dg2.cpp:775:	U_int.HV1x = Arrptr->HV1x_int;
./swe/dg2.cpp:776:	U_int.HV1y = Arrptr->HV1y_int;
./swe/dg2.cpp:818:	NUMERIC_TYPE H_w = Arrptr->FHx[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:819:	NUMERIC_TYPE H_e = Arrptr->FHx[j*(Parptr->xsz+1) + i+1];
./swe/dg2.cpp:820:	NUMERIC_TYPE H_n = Arrptr->FHy[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:821:	NUMERIC_TYPE H_s = Arrptr->FHy[(j+1)*(Parptr->xsz+1) + i];
./swe/dg2.cpp:825:	NUMERIC_TYPE HU_w = Arrptr->FHUx[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:826:	NUMERIC_TYPE HU_e = Arrptr->FHUx[j*(Parptr->xsz+1) + i+1];
./swe/dg2.cpp:827:	NUMERIC_TYPE HU_n = Arrptr->FHUy[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:828:	NUMERIC_TYPE HU_s = Arrptr->FHUy[(j+1)*(Parptr->xsz+1) + i];
./swe/dg2.cpp:833:	NUMERIC_TYPE HV_w = Arrptr->FHVx[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:834:	NUMERIC_TYPE HV_e = Arrptr->FHVx[j*(Parptr->xsz+1) + i+1];
./swe/dg2.cpp:835:	NUMERIC_TYPE HV_n = Arrptr->FHVy[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:836:	NUMERIC_TYPE HV_s = Arrptr->FHVy[(j+1)*(Parptr->xsz+1) + i];
./swe/dg2.cpp:853:	NUMERIC_TYPE H_w = Arrptr->FHx[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:854:	NUMERIC_TYPE H_e = Arrptr->FHx[j*(Parptr->xsz+1) + i+1];
./swe/dg2.cpp:855:	NUMERIC_TYPE HU_w = Arrptr->FHUx[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:856:	NUMERIC_TYPE HU_e = Arrptr->FHUx[j*(Parptr->xsz+1) + i+1];
./swe/dg2.cpp:857:	NUMERIC_TYPE HV_w = Arrptr->FHVx[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:858:	NUMERIC_TYPE HV_e = Arrptr->FHVx[j*(Parptr->xsz+1) + i+1];
./swe/dg2.cpp:908:	NUMERIC_TYPE H_n = Arrptr->FHy[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:909:	NUMERIC_TYPE H_s = Arrptr->FHy[(j+1)*(Parptr->xsz+1) + i];
./swe/dg2.cpp:910:	NUMERIC_TYPE HU_n = Arrptr->FHUy[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:911:	NUMERIC_TYPE HU_s = Arrptr->FHUy[(j+1)*(Parptr->xsz+1) + i];
./swe/dg2.cpp:912:	NUMERIC_TYPE HV_n = Arrptr->FHVy[j*(Parptr->xsz+1) + i];
./swe/dg2.cpp:913:	NUMERIC_TYPE HV_s = Arrptr->FHVy[(j+1)*(Parptr->xsz+1) + i];
./swe/dg2.cpp:1031:			H = FMAX(H, Arrptr->H[j*Parptr->xsz + i]);
./swe/dg2.cpp:1050:            if (thin_depth(Solverptr, Arrptr->H[j*Parptr->xsz + i]))
./swe/dg2.cpp:1052:				Arrptr->H1x[j*Parptr->xsz + i] = C(0.0);
./swe/dg2.cpp:1053:				Arrptr->H1y[j*Parptr->xsz + i] = C(0.0);
./swe/dg2.cpp:1054:				Arrptr->HU1x[j*Parptr->xsz + i] = C(0.0);
./swe/dg2.cpp:1055:				Arrptr->HU1y[j*Parptr->xsz + i] = C(0.0);
./swe/dg2.cpp:1056:				Arrptr->HV1x[j*Parptr->xsz + i] = C(0.0);
./swe/dg2.cpp:1057:				Arrptr->HV1y[j*Parptr->xsz + i] = C(0.0);
./swe/dg2.cpp:1088:            NUMERIC_TYPE H = Arrptr->H[j*Parptr->xsz + i];
./swe/dg2.cpp:1089:            NUMERIC_TYPE HU = Arrptr->HU[j*Parptr->xsz + i];
./swe/dg2.cpp:1090:            NUMERIC_TYPE HV = Arrptr->HV[j*Parptr->xsz + i];
./swe/dg2.cpp:1104:		NUMERIC_TYPE H = Arrptr->boundary.H[bc_i];
./swe/dg2.cpp:1105:		NUMERIC_TYPE HU = Arrptr->boundary.HU[bc_i];
./swe/dg2.cpp:1106:		NUMERIC_TYPE HV = Arrptr->boundary.HV[bc_i];
./swe/dg2.cpp:1119:		NUMERIC_TYPE H = Arrptr->boundary.H[bc_i];
./swe/dg2.cpp:1120:		NUMERIC_TYPE HU = Arrptr->boundary.HU[bc_i];
./swe/dg2.cpp:1121:		NUMERIC_TYPE HV = Arrptr->boundary.HV[bc_i];
./swe/dg2.cpp:1134:		NUMERIC_TYPE H = Arrptr->boundary.H[bc_i];
./swe/dg2.cpp:1135:		NUMERIC_TYPE HU = Arrptr->boundary.HU[bc_i];
./swe/dg2.cpp:1136:		NUMERIC_TYPE HV = Arrptr->boundary.HV[bc_i];
./swe/dg2.cpp:1149:		NUMERIC_TYPE H = Arrptr->boundary.H[bc_i];
./swe/dg2.cpp:1150:		NUMERIC_TYPE HU = Arrptr->boundary.HU[bc_i];
./swe/dg2.cpp:1151:		NUMERIC_TYPE HV = Arrptr->boundary.HV[bc_i];
./swe/fv1/modifiedvars.cpp:15:			NUMERIC_TYPE Z_neg = Arrptr->DEM[j*Parptr->xsz + i-1];
./swe/fv1/modifiedvars.cpp:16:			NUMERIC_TYPE Z_pos = Arrptr->DEM[j*Parptr->xsz + i];
./swe/fv1/modifiedvars.cpp:17:			NUMERIC_TYPE& Zstar_x = Arrptr->Zstar_x[j*(Parptr->xsz+1) + i];
./swe/fv1/modifiedvars.cpp:29:			NUMERIC_TYPE Z_neg = Arrptr->DEM[j*Parptr->xsz + i];
./swe/fv1/modifiedvars.cpp:30:			NUMERIC_TYPE Z_pos = Arrptr->DEM[(j-1)*Parptr->xsz + i];
./swe/fv1/modifiedvars.cpp:31:			NUMERIC_TYPE& Zstar_y = Arrptr->Zstar_y[j*(Parptr->xsz+1) + i];
./swe/fv1/modifiedvars.cpp:42:		NUMERIC_TYPE Z = Arrptr->DEM[j*Parptr->xsz + i];
./swe/fv1/modifiedvars.cpp:43:		NUMERIC_TYPE& Zstar_x = Arrptr->Zstar_x[j*(Parptr->xsz+1) + i];
./swe/fv1/modifiedvars.cpp:52:		NUMERIC_TYPE Z = Arrptr->DEM[j*Parptr->xsz + i-1];
./swe/fv1/modifiedvars.cpp:53:		NUMERIC_TYPE& Zstar_x = Arrptr->Zstar_x[j*(Parptr->xsz+1) + i];
./swe/fv1/modifiedvars.cpp:62:		NUMERIC_TYPE Z = Arrptr->DEM[j*Parptr->xsz + i];
./swe/fv1/modifiedvars.cpp:63:		NUMERIC_TYPE& Zstar_y = Arrptr->Zstar_y[j*(Parptr->xsz+1) + i];
./swe/fv1/modifiedvars.cpp:72:		NUMERIC_TYPE Z = Arrptr->DEM[(j-1)*Parptr->xsz + i];
./swe/fv1/modifiedvars.cpp:73:		NUMERIC_TYPE& Zstar_y = Arrptr->Zstar_y[j*(Parptr->xsz+1) + i];
./swe/fv1/modifiedvars.cpp:90:			NUMERIC_TYPE Zstar_x = Arrptr->Zstar_x[j*(Parptr->xsz+1) + i+1];
./swe/fv1/modifiedvars.cpp:91:			NUMERIC_TYPE& Hstar_neg_x = Arrptr->Hstar_neg_x[j*Parptr->xsz + i];
./swe/fv1/modifiedvars.cpp:103:			NUMERIC_TYPE Zstar_x = Arrptr->Zstar_x[j*(Parptr->xsz+1) + i];
./swe/fv1/modifiedvars.cpp:104:			NUMERIC_TYPE& Hstar_pos_x = Arrptr->Hstar_pos_x[j*Parptr->xsz + i];
./swe/fv1/modifiedvars.cpp:116:			NUMERIC_TYPE Zstar_y = Arrptr->Zstar_y[j*(Parptr->xsz+1) + i];
./swe/fv1/modifiedvars.cpp:117:			NUMERIC_TYPE& Hstar_neg_y = Arrptr->Hstar_neg_y[j*Parptr->xsz + i];
./swe/fv1/modifiedvars.cpp:129:			NUMERIC_TYPE Zstar_y = Arrptr->Zstar_y[(j+1)*(Parptr->xsz+1) + i];
./swe/fv1/modifiedvars.cpp:130:			NUMERIC_TYPE& Hstar_pos_y = Arrptr->Hstar_pos_y[j*Parptr->xsz + i];
./swe/fv1/modifiedvars.cpp:147:			Arrptr->Hstar_neg_x, Arrptr->HU, Parptr, Solverptr, Arrptr, i, j);
./swe/fv1/modifiedvars.cpp:160:			Arrptr->Hstar_pos_x, Arrptr->HU, Parptr, Solverptr, Arrptr, i, j);
./swe/fv1/modifiedvars.cpp:173:			Arrptr->Hstar_neg_y, Arrptr->HU, Parptr, Solverptr, Arrptr, i, j);
./swe/fv1/modifiedvars.cpp:186:			Arrptr->Hstar_pos_y, Arrptr->HU, Parptr, Solverptr, Arrptr, i, j);
./swe/fv1/modifiedvars.cpp:199:			Arrptr->Hstar_neg_x, Arrptr->HV, Parptr, Solverptr, Arrptr, i, j);
./swe/fv1/modifiedvars.cpp:212:			Arrptr->Hstar_pos_x, Arrptr->HV, Parptr, Solverptr, Arrptr, i, j);
./swe/fv1/modifiedvars.cpp:225:			Arrptr->Hstar_neg_y, Arrptr->HV, Parptr, Solverptr, Arrptr, i, j);
./swe/fv1/modifiedvars.cpp:238:			Arrptr->Hstar_pos_y, Arrptr->HV, Parptr, Solverptr, Arrptr, i, j);
./swe/fv1/modifiedvars.cpp:267:	return Zdagger(Parptr, Arrptr, Arrptr->Zstar_x, i+1, j, i, j);
./swe/fv1/modifiedvars.cpp:278:	return Zdagger(Parptr, Arrptr, Arrptr->Zstar_x, i, j, i, j);
./swe/fv1/modifiedvars.cpp:289:	return Zdagger(Parptr, Arrptr, Arrptr->Zstar_y, i, j, i, j);
./swe/fv1/modifiedvars.cpp:300:	return Zdagger(Parptr, Arrptr, Arrptr->Zstar_y, i, j+1, i, j);
./swe/fv1/modifiedvars.cpp:328:	NUMERIC_TYPE Z = Arrptr->DEM[j*Parptr->xsz + i];
./swe/fv1/modifiedvars.cpp:329:	NUMERIC_TYPE H = Arrptr->H[j*Parptr->xsz + i];
./swe/fv1/modifiedvars.cpp:344:	NUMERIC_TYPE H = Arrptr->H[j*Parptr->xsz + i];
./swe/fields.cpp:10:	Arrptr->HU = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/fields.cpp:11:	Arrptr->HV = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/fields.cpp:12:	Arrptr->FHx = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./swe/fields.cpp:13:	Arrptr->FHUx = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./swe/fields.cpp:14:	Arrptr->FHVx = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./swe/fields.cpp:15:	Arrptr->FHy = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./swe/fields.cpp:16:	Arrptr->FHUy = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./swe/fields.cpp:17:	Arrptr->FHVy = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./swe/fields.cpp:18:	Arrptr->Zstar_x = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./swe/fields.cpp:19:	Arrptr->Zstar_y = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./swe/fields.cpp:20:	Arrptr->Hstar_neg_x = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/fields.cpp:21:	Arrptr->Hstar_pos_x = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/fields.cpp:22:	Arrptr->Hstar_neg_y = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/fields.cpp:23:	Arrptr->Hstar_pos_y = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/fields.cpp:28:	memory_free_legacy(&Arrptr->HU);
./swe/fields.cpp:29:	memory_free_legacy(&Arrptr->HV);
./swe/fields.cpp:30:	memory_free_legacy(&Arrptr->FHx);
./swe/fields.cpp:31:	memory_free_legacy(&Arrptr->FHUx);
./swe/fields.cpp:32:	memory_free_legacy(&Arrptr->FHVx);
./swe/fields.cpp:33:	memory_free_legacy(&Arrptr->FHy);
./swe/fields.cpp:34:	memory_free_legacy(&Arrptr->FHUy);
./swe/fields.cpp:35:	memory_free_legacy(&Arrptr->FHVy);
./swe/fields.cpp:36:	memory_free_legacy(&Arrptr->Zstar_x);
./swe/fields.cpp:37:	memory_free_legacy(&Arrptr->Zstar_y);
./swe/fields.cpp:38:	memory_free_legacy(&Arrptr->Hstar_neg_x);
./swe/fields.cpp:39:	memory_free_legacy(&Arrptr->Hstar_pos_x);
./swe/fields.cpp:40:	memory_free_legacy(&Arrptr->Hstar_neg_y);
./swe/fields.cpp:41:	memory_free_legacy(&Arrptr->Hstar_pos_y);
./swe/dg2/dg2_output.cpp:15:		write_field(Arrptr->H1x, ".wd1x", ".wd1xb", Fnameptr, Statesptr, Parptr);
./swe/dg2/dg2_output.cpp:16:		write_field(Arrptr->H1y, ".wd1y", ".wd1yb", Fnameptr, Statesptr, Parptr);
./swe/dg2/dg2_output.cpp:21:		write_field(Arrptr->HU1x, ".Qx1x", ".Qx1xb", Fnameptr, Statesptr, Parptr);
./swe/dg2/dg2_output.cpp:22:		write_field(Arrptr->HU1y, ".Qx1y", ".Qx1yb", Fnameptr, Statesptr, Parptr);
./swe/dg2/dg2_output.cpp:23:		write_field(Arrptr->HV1x, ".Qy1x", ".Qy1xb", Fnameptr, Statesptr, Parptr);
./swe/dg2/dg2_output.cpp:24:		write_field(Arrptr->HV1y, ".Qy1y", ".Qy1yb", Fnameptr, Statesptr, Parptr);
./swe/dg2/modifiedvars.cpp:15:			NUMERIC_TYPE Z_neg = limit_neg(Arrptr->DEM, Arrptr->DEM1x,
./swe/dg2/modifiedvars.cpp:17:			NUMERIC_TYPE Z_pos = limit_pos(Arrptr->DEM, Arrptr->DEM1x,
./swe/dg2/modifiedvars.cpp:19:			NUMERIC_TYPE& Zstar_x = Arrptr->Zstar_x[j*(Parptr->xsz+1) + i];
./swe/dg2/modifiedvars.cpp:31:			NUMERIC_TYPE Z_neg = limit_neg(Arrptr->DEM, Arrptr->DEM1y,
./swe/dg2/modifiedvars.cpp:33:			NUMERIC_TYPE Z_pos = limit_pos(Arrptr->DEM, Arrptr->DEM1y,
./swe/dg2/modifiedvars.cpp:35:			NUMERIC_TYPE& Zstar_y = Arrptr->Zstar_y[j*(Parptr->xsz+1) + i];
./swe/dg2/modifiedvars.cpp:46:		NUMERIC_TYPE Z_pos = limit_pos(Arrptr->DEM, Arrptr->DEM1x, Parptr, i, j);
./swe/dg2/modifiedvars.cpp:47:		NUMERIC_TYPE& Zstar_x = Arrptr->Zstar_x[j*(Parptr->xsz+1) + i];
./swe/dg2/modifiedvars.cpp:56:		NUMERIC_TYPE Z_neg = limit_neg(Arrptr->DEM, Arrptr->DEM1x, Parptr, i-1, j);
./swe/dg2/modifiedvars.cpp:57:		NUMERIC_TYPE& Zstar_x = Arrptr->Zstar_x[j*(Parptr->xsz+1) + i];
./swe/dg2/modifiedvars.cpp:66:		NUMERIC_TYPE Z_pos = limit_pos(Arrptr->DEM, Arrptr->DEM1y, Parptr, i, j);
./swe/dg2/modifiedvars.cpp:67:		NUMERIC_TYPE& Zstar_y = Arrptr->Zstar_y[j*(Parptr->xsz+1) + i];
./swe/dg2/modifiedvars.cpp:76:		NUMERIC_TYPE Z_neg = limit_neg(Arrptr->DEM, Arrptr->DEM1y, Parptr, i, j-1);
./swe/dg2/modifiedvars.cpp:77:		NUMERIC_TYPE& Zstar_y = Arrptr->Zstar_y[j*(Parptr->xsz+1) + i];
./swe/dg2/modifiedvars.cpp:95:			NUMERIC_TYPE Zstar_x = Arrptr->Zstar_x[j*(Parptr->xsz+1) + i+1];
./swe/dg2/modifiedvars.cpp:96:			NUMERIC_TYPE& Hstar_neg_x = Arrptr->Hstar_neg_x[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:108:			NUMERIC_TYPE Zstar_x = Arrptr->Zstar_x[j*(Parptr->xsz+1) + i];
./swe/dg2/modifiedvars.cpp:109:			NUMERIC_TYPE& Hstar_pos_x = Arrptr->Hstar_pos_x[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:121:			NUMERIC_TYPE Zstar_y = Arrptr->Zstar_y[j*(Parptr->xsz+1) + i];
./swe/dg2/modifiedvars.cpp:122:			NUMERIC_TYPE& Hstar_neg_y = Arrptr->Hstar_neg_y[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:134:			NUMERIC_TYPE Zstar_y = Arrptr->Zstar_y[(j+1)*(Parptr->xsz+1) + i];
./swe/dg2/modifiedvars.cpp:135:			NUMERIC_TYPE& Hstar_pos_y = Arrptr->Hstar_pos_y[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:151:			Arrptr->HUstar_neg_x, Arrptr->HUstar_pos_x,
./swe/dg2/modifiedvars.cpp:152:			Arrptr->HUstar_neg_y, Arrptr->HUstar_pos_y);
./swe/dg2/modifiedvars.cpp:164:			Arrptr->HVstar_neg_x, Arrptr->HVstar_pos_x,
./swe/dg2/modifiedvars.cpp:165:			Arrptr->HVstar_neg_y, Arrptr->HVstar_pos_y);
./swe/dg2/modifiedvars.cpp:191:			NUMERIC_TYPE Hstar_neg_x = Arrptr->Hstar_neg_x[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:196:			NUMERIC_TYPE Hstar_pos_x = Arrptr->Hstar_pos_x[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:201:			NUMERIC_TYPE Hstar_neg_y = Arrptr->Hstar_neg_y[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:206:			NUMERIC_TYPE Hstar_pos_y = Arrptr->Hstar_pos_y[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:247:	NUMERIC_TYPE Hstar_neg_x = Arrptr->Hstar_neg_x[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:248:	NUMERIC_TYPE Hstar_pos_x = Arrptr->Hstar_pos_x[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:260:	NUMERIC_TYPE Hstar_neg_y = Arrptr->Hstar_neg_y[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:261:	NUMERIC_TYPE Hstar_pos_y = Arrptr->Hstar_pos_y[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:273:	NUMERIC_TYPE Hstar_neg_x = Arrptr->Hstar_neg_x[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:274:	NUMERIC_TYPE Hstar_pos_x = Arrptr->Hstar_pos_x[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:286:	NUMERIC_TYPE Hstar_neg_y = Arrptr->Hstar_neg_y[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:287:	NUMERIC_TYPE Hstar_pos_y = Arrptr->Hstar_pos_y[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:299:	NUMERIC_TYPE HUstar_neg_x = Arrptr->HUstar_neg_x[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:300:	NUMERIC_TYPE HUstar_pos_x = Arrptr->HUstar_pos_x[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:312:	NUMERIC_TYPE HUstar_neg_y = Arrptr->HUstar_neg_y[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:313:	NUMERIC_TYPE HUstar_pos_y = Arrptr->HUstar_pos_y[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:325:	NUMERIC_TYPE HUstar_neg_x = Arrptr->HUstar_neg_x[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:326:	NUMERIC_TYPE HUstar_pos_x = Arrptr->HUstar_pos_x[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:338:	NUMERIC_TYPE HUstar_neg_y = Arrptr->HUstar_neg_y[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:339:	NUMERIC_TYPE HUstar_pos_y = Arrptr->HUstar_pos_y[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:351:	NUMERIC_TYPE HVstar_neg_x = Arrptr->HVstar_neg_x[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:352:	NUMERIC_TYPE HVstar_pos_x = Arrptr->HVstar_pos_x[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:364:	NUMERIC_TYPE HVstar_neg_y = Arrptr->HVstar_neg_y[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:365:	NUMERIC_TYPE HVstar_pos_y = Arrptr->HVstar_pos_y[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:377:	NUMERIC_TYPE HVstar_neg_x = Arrptr->HVstar_neg_x[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:378:	NUMERIC_TYPE HVstar_pos_x = Arrptr->HVstar_pos_x[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:390:	NUMERIC_TYPE HVstar_neg_y = Arrptr->HVstar_neg_y[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:391:	NUMERIC_TYPE HVstar_pos_y = Arrptr->HVstar_pos_y[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:434:	NUMERIC_TYPE Zstar = Arrptr->Zstar_x[j*(Parptr->xsz+1) + i+1];
./swe/dg2/modifiedvars.cpp:449:	NUMERIC_TYPE Zstar = Arrptr->Zstar_x[j*(Parptr->xsz+1) + i];
./swe/dg2/modifiedvars.cpp:464:	NUMERIC_TYPE Zstar = Arrptr->Zstar_y[j*(Parptr->xsz+1) + i];
./swe/dg2/modifiedvars.cpp:479:	NUMERIC_TYPE Zstar = Arrptr->Zstar_y[(j+1)*(Parptr->xsz+1) + i];
./swe/dg2/modifiedvars.cpp:495:    NUMERIC_TYPE DEM1x = Arrptr->DEM1x[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:510:    NUMERIC_TYPE DEM1x = Arrptr->DEM1x[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:525:    NUMERIC_TYPE DEM1y = Arrptr->DEM1y[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:540:    NUMERIC_TYPE DEM1y = Arrptr->DEM1y[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:554:	NUMERIC_TYPE Z = Arrptr->DEM[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:569:	NUMERIC_TYPE Z1x = Arrptr->DEM1x[j*Parptr->xsz + i];
./swe/dg2/modifiedvars.cpp:584:	NUMERIC_TYPE Z1y = Arrptr->DEM1y[j*Parptr->xsz + i];
./swe/dg2/fields.cpp:67:			NUMERIC_TYPE Z = Arrptr->DEM[j*Parptr->xsz + i];
./swe/dg2/fields.cpp:68:			NUMERIC_TYPE Z1x = Arrptr->DEM1x[j*Parptr->xsz + i];
./swe/dg2/fields.cpp:69:			NUMERIC_TYPE Z1y = Arrptr->DEM1y[j*Parptr->xsz + i];
./swe/dg2/fields.cpp:71:			NUMERIC_TYPE& H = Arrptr->H[j*Parptr->xsz + i];
./swe/dg2/fields.cpp:72:			NUMERIC_TYPE& H1x = Arrptr->H1x[j*Parptr->xsz + i];
./swe/dg2/fields.cpp:73:			NUMERIC_TYPE& H1y = Arrptr->H1y[j*Parptr->xsz + i];
./swe/dg2/fields.cpp:96:	read_ascfile(dem1x, Parptr, Arrptr->DEM1x, "Loading DEM1x\n", verbose);
./swe/dg2/fields.cpp:97:	read_ascfile(dem1y, Parptr, Arrptr->DEM1y, "Loading DEM1y\n", verbose);
./swe/dg2/fields.cpp:111:			Arrptr->DEM1x[j*Parptr->xsz + i] = 0;
./swe/dg2/fields.cpp:117:			Arrptr->DEM1x[j*Parptr->xsz + i] = 0;
./swe/dg2/fields.cpp:126:			Arrptr->DEM1y[j*Parptr->xsz + i] = 0;
./swe/dg2/fields.cpp:132:			Arrptr->DEM1y[j*Parptr->xsz + i] = 0;
./swe/dg2/fields.cpp:151:	read_ascfile(h1x, Parptr, Arrptr->H1x, "Loading startfile 1x\n", verbose);
./swe/dg2/fields.cpp:152:	read_ascfile(h1y, Parptr, Arrptr->H1y, "Loading startfile 1y\n", verbose);
./swe/dg2/fields.cpp:175:	read_ascfile(hu1x, Parptr, Arrptr->HU1x, "Loading startfile Qx1x\n", verbose);
./swe/dg2/fields.cpp:176:	read_ascfile(hu1y, Parptr, Arrptr->HU1y, "Loading startfile Qx1y\n", verbose);
./swe/dg2/fields.cpp:177:	read_ascfile(hv1x, Parptr, Arrptr->HV1x, "Loading startfile Qy1x\n", verbose);
./swe/dg2/fields.cpp:178:	read_ascfile(hv1y, Parptr, Arrptr->HV1y, "Loading startfile Qy1y\n", verbose);
./swe/dg2/fields.cpp:192:	write_ascfile(root, -1, "", Arrptr->DEM, nullptr, 0,
./swe/dg2/fields.cpp:194:	write_ascfile(root, -1, "1x", Arrptr->DEM1x, nullptr, 0,
./swe/dg2/fields.cpp:196:	write_ascfile(root, -1, "1y", Arrptr->DEM1y, nullptr, 0,
./swe/dg2/fields.cpp:211:	write_ascfile(root, -1, "", Arrptr->H, nullptr, 0, &states, Parptr, C(-9999.0), "%.17");
./swe/dg2/fields.cpp:212:	write_ascfile(root, -1, "1x", Arrptr->H1x, nullptr, 0, &states, Parptr, C(-9999.0), "%.17");
./swe/dg2/fields.cpp:213:	write_ascfile(root, -1, "1y", Arrptr->H1y, nullptr, 0, &states, Parptr, C(-9999.0), "%.17");
./swe/dg2/fields.cpp:223:	allocate(Arrptr->boundary, Parptr);
./swe/dg2/fields.cpp:225:	Arrptr->DEM1x = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:226:	Arrptr->DEM1y = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:227:	Arrptr->H1x = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:228:	Arrptr->H1y = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:229:	Arrptr->HU1x = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:230:	Arrptr->HU1y = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:231:	Arrptr->HV1x = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:232:	Arrptr->HV1y = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:234:	Arrptr->H_int = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:235:	Arrptr->H1x_int = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:236:	Arrptr->H1y_int = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:237:	Arrptr->HU_int = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:238:	Arrptr->HU1x_int = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:239:	Arrptr->HU1y_int = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:240:	Arrptr->HV_int = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:241:	Arrptr->HV1x_int = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:242:	Arrptr->HV1y_int = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:246:        Arrptr->ETA1x_slopelim = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:247:        Arrptr->ETA1y_slopelim = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:248:        Arrptr->HU1x_slopelim = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:249:        Arrptr->HU1y_slopelim = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:250:        Arrptr->HV1x_slopelim = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:251:        Arrptr->HV1y_slopelim = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:254:	Arrptr->HUstar_neg_x = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:255:	Arrptr->HUstar_pos_x = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:256:	Arrptr->HUstar_neg_y = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:257:	Arrptr->HUstar_pos_y = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:258:	Arrptr->HVstar_neg_x = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:259:	Arrptr->HVstar_pos_x = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:260:	Arrptr->HVstar_neg_y = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:261:	Arrptr->HVstar_pos_y = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./swe/dg2/fields.cpp:283:	deallocate(Arrptr->boundary);
./swe/dg2/fields.cpp:285:	memory_free_legacy(&Arrptr->DEM1x);
./swe/dg2/fields.cpp:286:	memory_free_legacy(&Arrptr->DEM1y);
./swe/dg2/fields.cpp:287:	memory_free_legacy(&Arrptr->H1x);
./swe/dg2/fields.cpp:288:	memory_free_legacy(&Arrptr->H1y);
./swe/dg2/fields.cpp:289:	memory_free_legacy(&Arrptr->HU1x);
./swe/dg2/fields.cpp:290:	memory_free_legacy(&Arrptr->HU1y);
./swe/dg2/fields.cpp:291:	memory_free_legacy(&Arrptr->HV1x);
./swe/dg2/fields.cpp:292:	memory_free_legacy(&Arrptr->HV1y);
./swe/dg2/fields.cpp:294:	memory_free_legacy(&Arrptr->H_int);
./swe/dg2/fields.cpp:295:	memory_free_legacy(&Arrptr->H1x_int);
./swe/dg2/fields.cpp:296:	memory_free_legacy(&Arrptr->H1y_int);
./swe/dg2/fields.cpp:297:	memory_free_legacy(&Arrptr->HU_int);
./swe/dg2/fields.cpp:298:	memory_free_legacy(&Arrptr->HU1x_int);
./swe/dg2/fields.cpp:299:	memory_free_legacy(&Arrptr->HU1y_int);
./swe/dg2/fields.cpp:300:	memory_free_legacy(&Arrptr->HV_int);
./swe/dg2/fields.cpp:301:	memory_free_legacy(&Arrptr->HV1x_int);
./swe/dg2/fields.cpp:302:	memory_free_legacy(&Arrptr->HV1y_int);
./swe/dg2/fields.cpp:306:        memory_free_legacy(&Arrptr->ETA1x_slopelim);
./swe/dg2/fields.cpp:307:        memory_free_legacy(&Arrptr->ETA1y_slopelim);
./swe/dg2/fields.cpp:308:        memory_free_legacy(&Arrptr->HU1x_slopelim);
./swe/dg2/fields.cpp:309:        memory_free_legacy(&Arrptr->HU1y_slopelim);
./swe/dg2/fields.cpp:310:        memory_free_legacy(&Arrptr->HV1x_slopelim);
./swe/dg2/fields.cpp:311:        memory_free_legacy(&Arrptr->HV1y_slopelim);
./swe/dg2/fields.cpp:314:	memory_free_legacy(&Arrptr->HUstar_neg_x);
./swe/dg2/fields.cpp:315:	memory_free_legacy(&Arrptr->HUstar_pos_x);
./swe/dg2/fields.cpp:316:	memory_free_legacy(&Arrptr->HUstar_neg_y);
./swe/dg2/fields.cpp:317:	memory_free_legacy(&Arrptr->HUstar_pos_y);
./swe/dg2/fields.cpp:318:	memory_free_legacy(&Arrptr->HVstar_neg_x);
./swe/dg2/fields.cpp:319:	memory_free_legacy(&Arrptr->HVstar_pos_x);
./swe/dg2/fields.cpp:320:	memory_free_legacy(&Arrptr->HVstar_neg_y);
./swe/dg2/fields.cpp:321:	memory_free_legacy(&Arrptr->HVstar_pos_y);
./swe/dg2/friction.cpp:11:	if (Arrptr->Manningsn == nullptr && Parptr->FPn <= C(0.0)) return;
./swe/dg2/friction.cpp:18:			NUMERIC_TYPE H = Arrptr->H[j*Parptr->xsz + i];
./swe/dg2/friction.cpp:19:			NUMERIC_TYPE& HU = Arrptr->HU[j*Parptr->xsz + i];
./swe/dg2/friction.cpp:20:            NUMERIC_TYPE& HV = Arrptr->HV[j*Parptr->xsz + i];
./swe/dg2/friction.cpp:22:            NUMERIC_TYPE n = (Arrptr->Manningsn == nullptr)
./swe/dg2/friction.cpp:23:                ? Parptr->FPn : Arrptr->Manningsn[j*Parptr->xsz + i];
./swe/dg2/friction.cpp:30:                NUMERIC_TYPE H_x_lower = gauss_lower(Arrptr->H, Arrptr->H1x,
./swe/dg2/friction.cpp:32:                NUMERIC_TYPE H_x_upper = gauss_upper(Arrptr->H, Arrptr->H1x,
./swe/dg2/friction.cpp:34:                NUMERIC_TYPE HU_x_lower = gauss_lower(Arrptr->HU, Arrptr->HU1x,
./swe/dg2/friction.cpp:36:                NUMERIC_TYPE HU_x_upper = gauss_upper(Arrptr->HU, Arrptr->HU1x,
./swe/dg2/friction.cpp:38:                NUMERIC_TYPE HV_x_lower = gauss_lower(Arrptr->HV, Arrptr->HV1x,
./swe/dg2/friction.cpp:40:                NUMERIC_TYPE HV_x_upper = gauss_upper(Arrptr->HV, Arrptr->HV1x,
./swe/dg2/friction.cpp:42:                NUMERIC_TYPE H_y_lower = gauss_lower(Arrptr->H, Arrptr->H1y,
./swe/dg2/friction.cpp:44:                NUMERIC_TYPE H_y_upper = gauss_upper(Arrptr->H, Arrptr->H1y,
./swe/dg2/friction.cpp:46:                NUMERIC_TYPE HU_y_lower = gauss_lower(Arrptr->HU, Arrptr->HU1y,
./swe/dg2/friction.cpp:48:                NUMERIC_TYPE HU_y_upper = gauss_upper(Arrptr->HU, Arrptr->HU1y,
./swe/dg2/friction.cpp:50:                NUMERIC_TYPE HV_y_lower = gauss_lower(Arrptr->HV, Arrptr->HV1y,
./swe/dg2/friction.cpp:52:                NUMERIC_TYPE HV_y_upper = gauss_upper(Arrptr->HV, Arrptr->HV1y,
./swe/dg2/friction.cpp:55:                NUMERIC_TYPE& HU1x = Arrptr->HU1x[j*Parptr->xsz + i];
./swe/dg2/friction.cpp:56:                NUMERIC_TYPE& HU1y = Arrptr->HU1y[j*Parptr->xsz + i];
./swe/dg2/friction.cpp:57:                NUMERIC_TYPE& HV1x = Arrptr->HV1x[j*Parptr->xsz + i];
./swe/dg2/friction.cpp:58:                NUMERIC_TYPE& HV1y = Arrptr->HV1y[j*Parptr->xsz + i];
./swe/dg2/slope_limiter.cpp:19:			U.H1x[j*Parptr->xsz + i] = -Arrptr->DEM1x[j*Parptr->xsz + i];
./swe/dg2/slope_limiter.cpp:27:			U.H1x[j*Parptr->xsz + i] = -Arrptr->DEM1x[j*Parptr->xsz + i];
./swe/dg2/slope_limiter.cpp:39:			U.H1y[j*Parptr->ysz + i] = -Arrptr->DEM1y[j*Parptr->xsz + i];
./swe/dg2/slope_limiter.cpp:48:			U.H1y[j*Parptr->ysz + i] = -Arrptr->DEM1y[j*Parptr->xsz + i];
./swe/dg2/slope_limiter.cpp:81:			Arrptr->ETA1x_slopelim[j*Parptr->xsz + i] = C(0.0);
./swe/dg2/slope_limiter.cpp:82:			Arrptr->HU1x_slopelim[j*Parptr->xsz + i] = C(0.0);
./swe/dg2/slope_limiter.cpp:83:			Arrptr->HV1x_slopelim[j*Parptr->xsz + i] = C(0.0);
./swe/dg2/slope_limiter.cpp:89:			Arrptr->ETA1x_slopelim[j*Parptr->xsz + i] = C(0.0);
./swe/dg2/slope_limiter.cpp:90:			Arrptr->HU1x_slopelim[j*Parptr->xsz + i] = C(0.0);
./swe/dg2/slope_limiter.cpp:91:			Arrptr->HV1x_slopelim[j*Parptr->xsz + i] = C(0.0);
./swe/dg2/slope_limiter.cpp:111:					Arrptr->ETA1x_slopelim[j*Parptr->xsz + i];
./swe/dg2/slope_limiter.cpp:127:					Arrptr->HU1x_slopelim[j*Parptr->xsz + i];
./swe/dg2/slope_limiter.cpp:143:					Arrptr->HV1x_slopelim[j*Parptr->xsz + i];
./swe/dg2/slope_limiter.cpp:157:			NUMERIC_TYPE Z1x = Arrptr->DEM1x[j*Parptr->xsz + i];
./swe/dg2/slope_limiter.cpp:158:			NUMERIC_TYPE ETA1x = Arrptr->ETA1x_slopelim[j*Parptr->xsz + i];
./swe/dg2/slope_limiter.cpp:166:	memcpy(U.HU1x, Arrptr->HU1x_slopelim, size);
./swe/dg2/slope_limiter.cpp:167:	memcpy(U.HV1x, Arrptr->HV1x_slopelim, size);
./swe/dg2/slope_limiter.cpp:184:			Arrptr->ETA1y_slopelim[j*Parptr->xsz + i] = C(0.0);
./swe/dg2/slope_limiter.cpp:185:			Arrptr->HU1y_slopelim[j*Parptr->xsz + i] = C(0.0);
./swe/dg2/slope_limiter.cpp:186:			Arrptr->HV1y_slopelim[j*Parptr->xsz + i] = C(0.0);
./swe/dg2/slope_limiter.cpp:193:			Arrptr->ETA1y_slopelim[j*Parptr->xsz + i] = C(0.0);
./swe/dg2/slope_limiter.cpp:194:			Arrptr->HU1y_slopelim[j*Parptr->xsz + i] = C(0.0);
./swe/dg2/slope_limiter.cpp:195:			Arrptr->HV1y_slopelim[j*Parptr->xsz + i] = C(0.0);
./swe/dg2/slope_limiter.cpp:215:					Arrptr->ETA1y_slopelim[j*Parptr->xsz + i];
./swe/dg2/slope_limiter.cpp:231:					Arrptr->HU1y_slopelim[j*Parptr->xsz + i];
./swe/dg2/slope_limiter.cpp:247:					Arrptr->HV1y_slopelim[j*Parptr->xsz + i];
./swe/dg2/slope_limiter.cpp:261:			NUMERIC_TYPE Z1y = Arrptr->DEM1y[j*Parptr->xsz + i];
./swe/dg2/slope_limiter.cpp:262:			NUMERIC_TYPE ETA1y = Arrptr->ETA1y_slopelim[j*Parptr->xsz + i];
./swe/dg2/slope_limiter.cpp:270:	memcpy(U.HU1y, Arrptr->HU1y_slopelim, size);
./swe/dg2/slope_limiter.cpp:271:	memcpy(U.HV1y, Arrptr->HV1y_slopelim, size);
./swe/stats.cpp:36:			if (Arrptr->H[j*Parptr->xsz + i] > C(0.01)) FloodArea += Parptr->dA;
./swe/stats.cpp:82:		NUMERIC_TYPE FHy = Arrptr->FHy[j*(Parptr->xsz+1) + i];
./swe/stats.cpp:91:		NUMERIC_TYPE FHy = Arrptr->FHy[j*(Parptr->xsz+1) + i];
./swe/stats.cpp:100:		NUMERIC_TYPE FHx = Arrptr->FHx[j*(Parptr->xsz+1) + i];
./swe/stats.cpp:109:		NUMERIC_TYPE FHx = Arrptr->FHx[j*(Parptr->xsz+1) + i];
./swe/stats.cpp:131:			NUMERIC_TYPE H = Arrptr->H[j*Parptr->xsz + i];
./swe/stats.cpp:132:			NUMERIC_TYPE HU = Arrptr->HU[j*Parptr->xsz + i];
./swe/stats.cpp:133:			NUMERIC_TYPE HV = Arrptr->HV[j*Parptr->xsz + i];
./swe/stats.cpp:134:			NUMERIC_TYPE& Vx = Arrptr->Vx[j*Parptr->xsz + i];
./swe/stats.cpp:135:			NUMERIC_TYPE& Vy = Arrptr->Vy[j*Parptr->xsz + i];
./swe/stats.cpp:164:            NUMERIC_TYPE& maxH = Arrptr->maxH[j*Parptr->xsz + i];
./swe/stats.cpp:165:            maxH = FMAX(maxH, Arrptr->H[j*Parptr->xsz + i]);
./swe/fv1.cpp:111:	if (Arrptr->Manningsn == nullptr && Parptr->FPn <= C(0.0)) return;
./swe/fv1.cpp:118:			NUMERIC_TYPE H = Arrptr->H[j*Parptr->xsz + i];
./swe/fv1.cpp:119:			NUMERIC_TYPE& HU = Arrptr->HU[j*Parptr->xsz + i];
./swe/fv1.cpp:120:			NUMERIC_TYPE& HV = Arrptr->HV[j*Parptr->xsz + i];
./swe/fv1.cpp:138:            NUMERIC_TYPE n = (Arrptr->Manningsn == nullptr)
./swe/fv1.cpp:139:                ? Parptr->FPn : Arrptr->Manningsn[j*Parptr->xsz + i];
./swe/fv1.cpp:172:			NUMERIC_TYPE Z = Arrptr->DEM[j*Parptr->xsz + i];
./swe/fv1.cpp:176:			    NUMERIC_TYPE& H = Arrptr->H[j*Parptr->xsz + i];
./swe/fv1.cpp:200:		NUMERIC_TYPE& H = Arrptr->H[j*Parptr->xsz + i];
./swe/fv1.cpp:206:				NUMERIC_TYPE Z = Arrptr->DEM[j*Parptr->xsz + i];
./swe/fv1.cpp:216:				NUMERIC_TYPE Z = Arrptr->DEM[j*Parptr->xsz + i];
./swe/fv1.cpp:262:			NUMERIC_TYPE H_neg = Arrptr->Hstar_neg_x[j*Parptr->xsz + i-1];
./swe/fv1.cpp:268:			NUMERIC_TYPE H_pos = Arrptr->Hstar_pos_x[j*Parptr->xsz + i];
./swe/fv1.cpp:272:			NUMERIC_TYPE& FHx = Arrptr->FHx[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:273:			NUMERIC_TYPE& FHUx = Arrptr->FHUx[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:274:			NUMERIC_TYPE& FHVx = Arrptr->FHVx[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:286:			NUMERIC_TYPE H_neg = Arrptr->Hstar_neg_y[j*Parptr->xsz + i];
./swe/fv1.cpp:290:			NUMERIC_TYPE H_pos = Arrptr->Hstar_pos_y[(j-1)*Parptr->xsz + i];
./swe/fv1.cpp:296:			NUMERIC_TYPE& FHy = Arrptr->FHy[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:297:			NUMERIC_TYPE& FHUy = Arrptr->FHUy[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:298:			NUMERIC_TYPE& FHVy = Arrptr->FHVy[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:319:		NUMERIC_TYPE H_inside = Arrptr->Hstar_pos_x[j*Parptr->xsz + i];
./swe/fv1.cpp:323:		NUMERIC_TYPE& FHx = Arrptr->FHx[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:324:		NUMERIC_TYPE& FHUx = Arrptr->FHUx[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:325:		NUMERIC_TYPE& FHVx = Arrptr->FHVx[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:345:		NUMERIC_TYPE H_inside = Arrptr->Hstar_neg_x[j*Parptr->xsz + i-1];
./swe/fv1.cpp:351:		NUMERIC_TYPE& FHx = Arrptr->FHx[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:352:		NUMERIC_TYPE& FHUx = Arrptr->FHUx[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:353:		NUMERIC_TYPE& FHVx = Arrptr->FHVx[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:373:		NUMERIC_TYPE H_inside = Arrptr->Hstar_neg_y[j*Parptr->xsz + i];
./swe/fv1.cpp:377:		NUMERIC_TYPE& FHy = Arrptr->FHy[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:378:		NUMERIC_TYPE& FHUy = Arrptr->FHUy[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:379:		NUMERIC_TYPE& FHVy = Arrptr->FHVy[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:399:		NUMERIC_TYPE H_inside = Arrptr->Hstar_pos_y[(j-1)*Parptr->xsz + i];
./swe/fv1.cpp:405:		NUMERIC_TYPE& FHy = Arrptr->FHy[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:406:		NUMERIC_TYPE& FHUy = Arrptr->FHUy[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:407:		NUMERIC_TYPE& FHVy = Arrptr->FHVy[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:435:			NUMERIC_TYPE& H = Arrptr->H[j*Parptr->xsz + i];
./swe/fv1.cpp:436:			NUMERIC_TYPE H_w = Arrptr->FHx[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:437:			NUMERIC_TYPE H_e = Arrptr->FHx[j*(Parptr->xsz+1) + i+1];
./swe/fv1.cpp:438:			NUMERIC_TYPE H_n = Arrptr->FHy[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:439:			NUMERIC_TYPE H_s = Arrptr->FHy[(j+1)*(Parptr->xsz+1) + i];
./swe/fv1.cpp:444:			NUMERIC_TYPE& HU = Arrptr->HU[j*Parptr->xsz + i];
./swe/fv1.cpp:445:			NUMERIC_TYPE HU_w = Arrptr->FHUx[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:446:			NUMERIC_TYPE HU_e = Arrptr->FHUx[j*(Parptr->xsz+1) + i+1];
./swe/fv1.cpp:447:			NUMERIC_TYPE HU_n = Arrptr->FHUy[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:448:			NUMERIC_TYPE HU_s = Arrptr->FHUy[(j+1)*(Parptr->xsz+1) + i];
./swe/fv1.cpp:454:			NUMERIC_TYPE& HV = Arrptr->HV[j*Parptr->xsz + i];
./swe/fv1.cpp:455:			NUMERIC_TYPE HV_w = Arrptr->FHVx[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:456:			NUMERIC_TYPE HV_e = Arrptr->FHVx[j*(Parptr->xsz+1) + i+1];
./swe/fv1.cpp:457:			NUMERIC_TYPE HV_n = Arrptr->FHVy[j*(Parptr->xsz+1) + i];
./swe/fv1.cpp:458:			NUMERIC_TYPE HV_s = Arrptr->FHVy[(j+1)*(Parptr->xsz+1) + i];
./swe/fv1.cpp:476:	NUMERIC_TYPE Hstar_neg = Arrptr->Hstar_neg_x[j*Parptr->xsz + i];
./swe/fv1.cpp:477:	NUMERIC_TYPE Hstar_pos = Arrptr->Hstar_pos_x[j*Parptr->xsz + i];
./swe/fv1.cpp:494:	NUMERIC_TYPE Hstar_neg = Arrptr->Hstar_neg_y[j*Parptr->xsz + i];
./swe/fv1.cpp:495:	NUMERIC_TYPE Hstar_pos = Arrptr->Hstar_pos_y[j*Parptr->xsz + i];
./swe/fv1.cpp:530:			NUMERIC_TYPE Z = Arrptr->DEM[z_j*Parptr->xsz + z_i];
./swe/fv1.cpp:539:			NUMERIC_TYPE Z = Arrptr->DEM[z_j*Parptr->xsz + z_i];
./swe/fv1.cpp:598:			NUMERIC_TYPE H = Arrptr->H[j*Parptr->xsz + i];
./swe/fv1.cpp:601:				NUMERIC_TYPE HU = Arrptr->HU[j*Parptr->xsz + i];
./swe/fv1.cpp:602:				NUMERIC_TYPE HV = Arrptr->HV[j*Parptr->xsz + i];
./swe/output.cpp:43:		NUMERIC_TYPE H = Arrptr->H[
./swe/output.cpp:74:		NUMERIC_TYPE H = Arrptr->H[index];
./swe/output.cpp:75:		NUMERIC_TYPE HU = Arrptr->HU[index];
./swe/output.cpp:76:		NUMERIC_TYPE HV = Arrptr->HV[index];
./swe/output.cpp:115:		write_field(Arrptr->H, ".wd", ".wdb", Fnameptr, Statesptr, Parptr);
./swe/output.cpp:123:					".elevb", Arrptr->H, Arrptr->DEM, 3, Statesptr, Parptr);
./swe/output.cpp:128:					".elev", Arrptr->H, Arrptr->DEM, 3, Statesptr, Parptr);
./swe/output.cpp:134:		write_field(Arrptr->HU, ".Qx", ".Qxb", Fnameptr, Statesptr, Parptr);
./swe/output.cpp:135:		write_field(Arrptr->HV, ".Qy", ".Qyb", Fnameptr, Statesptr, Parptr);
./swe/output.cpp:140:		write_field(Arrptr->Vx, ".Vx", ".Vxb", Fnameptr, Statesptr, Parptr);
./swe/output.cpp:141:		write_field(Arrptr->Vy, ".Vy", ".Vyb", Fnameptr, Statesptr, Parptr);
./swe/output.cpp:158:	    write_binrasterfile(Fnameptr->resrootname, -1, ".maxb", Arrptr->maxH,
./swe/output.cpp:159:                Arrptr->DEM, 0, Statesptr, Parptr);
./swe/output.cpp:163:	    write_ascfile(Fnameptr->resrootname, -1, ".max", Arrptr->maxH,
./swe/output.cpp:164:                Arrptr->DEM, 0, Statesptr, Parptr);
./swe/dg2new.cpp:42:            Arrptr->DEM[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:43:            Arrptr->DEM1x[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:44:            Arrptr->DEM1y[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:45:            Arrptr->H[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:50:            Arrptr->DEM[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:51:            Arrptr->DEM1x[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:52:            Arrptr->DEM1y[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:53:            Arrptr->H[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:61:            Arrptr->DEM[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:62:            Arrptr->DEM1x[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:63:            Arrptr->DEM1y[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:64:            Arrptr->H[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:69:            Arrptr->DEM[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:70:            Arrptr->DEM1x[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:71:            Arrptr->DEM1y[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:72:            Arrptr->H[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:129:	read_ascfile(dem1x, Parptr, Arrptr->DEM1x, "Loading DEM1x\n", verbose);
./swe/dg2new.cpp:130:	read_ascfile(dem1y, Parptr, Arrptr->DEM1y, "Loading DEM1y\n", verbose);
./swe/dg2new.cpp:150:	read_ascfile(h1x, Parptr, Arrptr->H1x, "Loading startfile 1x\n", verbose);
./swe/dg2new.cpp:151:	read_ascfile(h1y, Parptr, Arrptr->H1y, "Loading startfile 1y\n", verbose);
./swe/dg2new.cpp:168:	read_ascfile(hu1x, Parptr, Arrptr->HU1x, "Loading startfile Qx1x\n", verbose);
./swe/dg2new.cpp:169:	read_ascfile(hu1y, Parptr, Arrptr->HU1y, "Loading startfile Qx1y\n", verbose);
./swe/dg2new.cpp:170:	read_ascfile(hv1x, Parptr, Arrptr->HV1x, "Loading startfile Qy1x\n", verbose);
./swe/dg2new.cpp:171:	read_ascfile(hv1y, Parptr, Arrptr->HV1y, "Loading startfile Qy1y\n", verbose);
./swe/dg2new.cpp:197:	if (Arrptr->Manningsn == nullptr && Parptr->FPn <= C(0.0)) return;
./swe/dg2new.cpp:211:	NUMERIC_TYPE H = Arrptr->H[j*Parptr->xsz+i];
./swe/dg2new.cpp:215:    NUMERIC_TYPE n = (Arrptr->Manningsn == nullptr)
./swe/dg2new.cpp:216:        ? Parptr->FPn : Arrptr->Manningsn[j*Parptr->xsz+i];
./swe/dg2new.cpp:218:    NUMERIC_TYPE H1x = Arrptr->H1x[j*Parptr->xsz+i];
./swe/dg2new.cpp:219:    NUMERIC_TYPE H1y = Arrptr->H1y[j*Parptr->xsz+i];
./swe/dg2new.cpp:220:    NUMERIC_TYPE HU = Arrptr->HU[j*Parptr->xsz+i];
./swe/dg2new.cpp:221:    NUMERIC_TYPE HV = Arrptr->HV[j*Parptr->xsz+i];
./swe/dg2new.cpp:222:    NUMERIC_TYPE HU1x = Arrptr->HU1x[j*Parptr->xsz+i];
./swe/dg2new.cpp:223:    NUMERIC_TYPE HU1y = Arrptr->HU1y[j*Parptr->xsz+i];
./swe/dg2new.cpp:224:    NUMERIC_TYPE HV1x = Arrptr->HV1x[j*Parptr->xsz+i];
./swe/dg2new.cpp:225:    NUMERIC_TYPE HV1y = Arrptr->HV1y[j*Parptr->xsz+i];
./swe/dg2new.cpp:248:    Arrptr->HU[j*Parptr->xsz+i] = HU_friction;
./swe/dg2new.cpp:249:    Arrptr->HV[j*Parptr->xsz+i] = HV_friction;
./swe/dg2new.cpp:250:    Arrptr->HU1x[j*Parptr->xsz+i] = C(0.5)*(HU_Gx2_friction - HU_Gx1_friction);
./swe/dg2new.cpp:251:    Arrptr->HV1x[j*Parptr->xsz+i] = C(0.5)*(HV_Gx2_friction - HV_Gx1_friction);
./swe/dg2new.cpp:252:    Arrptr->HU1y[j*Parptr->xsz+i] = C(0.5)*(HU_Gy2_friction - HU_Gy1_friction);
./swe/dg2new.cpp:253:    Arrptr->HV1y[j*Parptr->xsz+i] = C(0.5)*(HV_Gy2_friction - HV_Gy1_friction);
./swe/dg2new.cpp:317:    Arrptr->H_int[j*Parptr->xsz+i] = Arrptr->H[j*Parptr->xsz+i]
./swe/dg2new.cpp:319:    Arrptr->HU_int[j*Parptr->xsz+i] = Arrptr->HU[j*Parptr->xsz+i]
./swe/dg2new.cpp:321:    Arrptr->HV_int[j*Parptr->xsz+i] = Arrptr->HV[j*Parptr->xsz+i]
./swe/dg2new.cpp:324:    Arrptr->H1x_int[j*Parptr->xsz+i] = Arrptr->H1x[j*Parptr->xsz+i]
./swe/dg2new.cpp:326:    Arrptr->HU1x_int[j*Parptr->xsz+i] = Arrptr->HU1x[j*Parptr->xsz+i]
./swe/dg2new.cpp:328:    Arrptr->HV1x_int[j*Parptr->xsz+i] = Arrptr->HV1x[j*Parptr->xsz+i]
./swe/dg2new.cpp:331:    Arrptr->H1y_int[j*Parptr->xsz+i] = Arrptr->H1y[j*Parptr->xsz+i]
./swe/dg2new.cpp:333:    Arrptr->HU1y_int[j*Parptr->xsz+i] = Arrptr->HU1y[j*Parptr->xsz+i]
./swe/dg2new.cpp:335:    Arrptr->HV1y_int[j*Parptr->xsz+i] = Arrptr->HV1y[j*Parptr->xsz+i]
./swe/dg2new.cpp:338:    if (Arrptr->H_int[j*Parptr->xsz+i] <= Solverptr->DepthThresh)
./swe/dg2new.cpp:340:        Arrptr->HU_int[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:341:        Arrptr->HU1x_int[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:342:        Arrptr->HU1y_int[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:344:        Arrptr->HV_int[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:345:        Arrptr->HV1x_int[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:346:        Arrptr->HV1y_int[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:367:    H_new[j*Parptr->xsz+i] = C(0.5)*(Arrptr->H[j*Parptr->xsz+i] +
./swe/dg2new.cpp:368:            Arrptr->H_int[j*Parptr->xsz+i] + Solverptr->Tstep*L.H);
./swe/dg2new.cpp:369:    HU_new[j*Parptr->xsz+i] = C(0.5)*(Arrptr->HU[j*Parptr->xsz+i] +
./swe/dg2new.cpp:370:            Arrptr->HU_int[j*Parptr->xsz+i] + Solverptr->Tstep*L.HU);
./swe/dg2new.cpp:371:    HV_new[j*Parptr->xsz+i] = C(0.5)*(Arrptr->HV[j*Parptr->xsz+i] +
./swe/dg2new.cpp:372:            Arrptr->HV_int[j*Parptr->xsz+i] + Solverptr->Tstep*L.HV);
./swe/dg2new.cpp:374:    H1x_new[j*Parptr->xsz+i] = C(0.5)*(Arrptr->H1x[j*Parptr->xsz+i] +
./swe/dg2new.cpp:375:            Arrptr->H1x_int[j*Parptr->xsz+i] + Solverptr->Tstep*L.H1x);
./swe/dg2new.cpp:376:    HU1x_new[j*Parptr->xsz+i] = C(0.5)*(Arrptr->HU1x[j*Parptr->xsz+i] +
./swe/dg2new.cpp:377:            Arrptr->HU1x_int[j*Parptr->xsz+i] + Solverptr->Tstep*L.HU1x);
./swe/dg2new.cpp:378:    HV1x_new[j*Parptr->xsz+i] = C(0.5)*(Arrptr->HV1x[j*Parptr->xsz+i] +
./swe/dg2new.cpp:379:            Arrptr->HV1x_int[j*Parptr->xsz+i] + Solverptr->Tstep*L.HV1x);
./swe/dg2new.cpp:381:    H1y_new[j*Parptr->xsz+i] = C(0.5)*(Arrptr->H1y[j*Parptr->xsz+i] +
./swe/dg2new.cpp:382:            Arrptr->H1y_int[j*Parptr->xsz+i] + Solverptr->Tstep*L.H1y);
./swe/dg2new.cpp:383:    HU1y_new[j*Parptr->xsz+i] = C(0.5)*(Arrptr->HU1y[j*Parptr->xsz+i] +
./swe/dg2new.cpp:384:            Arrptr->HU1y_int[j*Parptr->xsz+i] + Solverptr->Tstep*L.HU1y);
./swe/dg2new.cpp:385:    HV1y_new[j*Parptr->xsz+i] = C(0.5)*(Arrptr->HV1y[j*Parptr->xsz+i] +
./swe/dg2new.cpp:386:            Arrptr->HV1y_int[j*Parptr->xsz+i] + Solverptr->Tstep*L.HV1y);
./swe/dg2new.cpp:576:    NUMERIC_TYPE DEM = Arrptr->DEM[j*Parptr->xsz+i];
./swe/dg2new.cpp:577:    NUMERIC_TYPE DEM1x = Arrptr->DEM1x[j*Parptr->xsz+i];
./swe/dg2new.cpp:578:    NUMERIC_TYPE DEM1y = Arrptr->DEM1y[j*Parptr->xsz+i];
./swe/dg2new.cpp:592:        H = Arrptr->H[j*Parptr->xsz+i];
./swe/dg2new.cpp:593:        H1x = Arrptr->H1x[j*Parptr->xsz+i];
./swe/dg2new.cpp:594:        H1y = Arrptr->H1y[j*Parptr->xsz+i];
./swe/dg2new.cpp:595:        HU = Arrptr->HU[j*Parptr->xsz+i];
./swe/dg2new.cpp:596:        HU1x = Arrptr->HU1x[j*Parptr->xsz+i];
./swe/dg2new.cpp:597:        HU1y = Arrptr->HU1y[j*Parptr->xsz+i];
./swe/dg2new.cpp:598:        HV = Arrptr->HV[j*Parptr->xsz+i];
./swe/dg2new.cpp:599:        HV1x = Arrptr->HV1x[j*Parptr->xsz+i];
./swe/dg2new.cpp:600:        HV1y = Arrptr->HV1y[j*Parptr->xsz+i];
./swe/dg2new.cpp:604:        H = Arrptr->H_int[j*Parptr->xsz+i];
./swe/dg2new.cpp:605:        H1x = Arrptr->H1x_int[j*Parptr->xsz+i];
./swe/dg2new.cpp:606:        H1y = Arrptr->H1y_int[j*Parptr->xsz+i];
./swe/dg2new.cpp:607:        HU = Arrptr->HU_int[j*Parptr->xsz+i];
./swe/dg2new.cpp:608:        HU1x = Arrptr->HU1x_int[j*Parptr->xsz+i];
./swe/dg2new.cpp:609:        HU1y = Arrptr->HU1y_int[j*Parptr->xsz+i];
./swe/dg2new.cpp:610:        HV = Arrptr->HV_int[j*Parptr->xsz+i];
./swe/dg2new.cpp:611:        HV1x = Arrptr->HV1x_int[j*Parptr->xsz+i];
./swe/dg2new.cpp:612:        HV1y = Arrptr->HV1y_int[j*Parptr->xsz+i];
./swe/dg2new.cpp:789:    Arrptr->H[j*Parptr->xsz+i] = H_new[j*Parptr->xsz+i];
./swe/dg2new.cpp:790:    Arrptr->HU[j*Parptr->xsz+i] = HU_new[j*Parptr->xsz+i];
./swe/dg2new.cpp:791:    Arrptr->HV[j*Parptr->xsz+i] = HV_new[j*Parptr->xsz+i];
./swe/dg2new.cpp:793:    Arrptr->H1x[j*Parptr->xsz+i] = H1x_new[j*Parptr->xsz+i];
./swe/dg2new.cpp:794:    Arrptr->HU1x[j*Parptr->xsz+i] = HU1x_new[j*Parptr->xsz+i];
./swe/dg2new.cpp:795:    Arrptr->HV1x[j*Parptr->xsz+i] = HV1x_new[j*Parptr->xsz+i];
./swe/dg2new.cpp:797:    Arrptr->H1y[j*Parptr->xsz+i] = H1y_new[j*Parptr->xsz+i];
./swe/dg2new.cpp:798:    Arrptr->HU1y[j*Parptr->xsz+i] = HU1y_new[j*Parptr->xsz+i];
./swe/dg2new.cpp:799:    Arrptr->HV1y[j*Parptr->xsz+i] = HV1y_new[j*Parptr->xsz+i];
./swe/dg2new.cpp:801:    if (Arrptr->H[j*Parptr->xsz+i] <= Solverptr->DepthThresh)
./swe/dg2new.cpp:803:        Arrptr->HU[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:804:        Arrptr->HU1x[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:805:        Arrptr->HU1y[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:807:        Arrptr->HV[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:808:        Arrptr->HV1x[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:809:        Arrptr->HV1y[j*Parptr->xsz+i] = C(0.0);
./swe/dg2new.cpp:815:        NUMERIC_TYPE U = Arrptr->HU[j*Parptr->xsz+i]/Arrptr->H[j*Parptr->xsz+i];
./swe/dg2new.cpp:816:        NUMERIC_TYPE V = Arrptr->HV[j*Parptr->xsz+i]/Arrptr->H[j*Parptr->xsz+i];
./swe/dg2new.cpp:819:            (FABS(U)+SQRT(Solverptr->g*Arrptr->H[j*Parptr->xsz+i]));
./swe/dg2new.cpp:821:            (FABS(V)+SQRT(Solverptr->g*Arrptr->H[j*Parptr->xsz+i]));
./chkpnt.cpp:137:		fread(Arrptr->H,sizeof(NUMERIC_TYPE),Parptr->xsz*Parptr->ysz,check_fp);
./chkpnt.cpp:138:		fread(Arrptr->Qx,sizeof(NUMERIC_TYPE),(Parptr->xsz+1)*(Parptr->ysz+1),check_fp);
./chkpnt.cpp:139:		fread(Arrptr->Qy,sizeof(NUMERIC_TYPE),(Parptr->xsz+1)*(Parptr->ysz+1),check_fp);
./chkpnt.cpp:140:		fread(Arrptr->maxH,sizeof(NUMERIC_TYPE),Parptr->xsz*Parptr->ysz,check_fp);
./chkpnt.cpp:141:		fread(Arrptr->maxHtm,sizeof(NUMERIC_TYPE),Parptr->xsz*Parptr->ysz,check_fp);
./chkpnt.cpp:142:		fread(Arrptr->initHtm,sizeof(NUMERIC_TYPE),Parptr->xsz*Parptr->ysz,check_fp);
./chkpnt.cpp:143:		if(checkv>1) fread(Arrptr->totalHtm,sizeof(NUMERIC_TYPE),Parptr->xsz*Parptr->ysz,check_fp);
./chkpnt.cpp:148:		fread(Arrptr->ChanMask,sizeof(int),Parptr->xsz*Parptr->ysz,check_fp);
./chkpnt.cpp:149:		fread(Arrptr->SegMask,sizeof(int),Parptr->xsz*Parptr->ysz,check_fp);
./chkpnt.cpp:248:    fwrite(Arrptr->H,sizeof(NUMERIC_TYPE),Parptr->xsz*Parptr->ysz,check_fp);
./chkpnt.cpp:249:    fwrite(Arrptr->Qx,sizeof(NUMERIC_TYPE),(Parptr->xsz+1)*(Parptr->ysz+1),check_fp);
./chkpnt.cpp:250:    fwrite(Arrptr->Qy,sizeof(NUMERIC_TYPE),(Parptr->xsz+1)*(Parptr->ysz+1),check_fp);
./chkpnt.cpp:251:    fwrite(Arrptr->maxH,sizeof(NUMERIC_TYPE),Parptr->xsz*Parptr->ysz,check_fp);
./chkpnt.cpp:252:    fwrite(Arrptr->maxHtm,sizeof(NUMERIC_TYPE),Parptr->xsz*Parptr->ysz,check_fp);
./chkpnt.cpp:253:    fwrite(Arrptr->initHtm,sizeof(NUMERIC_TYPE),Parptr->xsz*Parptr->ysz,check_fp);
./chkpnt.cpp:254:    if(checkv>1) fwrite(Arrptr->totalHtm,sizeof(NUMERIC_TYPE),Parptr->xsz*Parptr->ysz,check_fp);
./chkpnt.cpp:259:    fwrite(Arrptr->ChanMask,sizeof(int),Parptr->xsz*Parptr->ysz,check_fp);
./chkpnt.cpp:260:    fwrite(Arrptr->SegMask,sizeof(int),Parptr->xsz*Parptr->ysz,check_fp);
./sgc.cpp:395:		w0 = Arrptr->SGCwidth[p0]; // channel width
./sgc.cpp:396:		z0 = Arrptr->SGCz[p0];     // bank height
./sgc.cpp:402:			gr = Arrptr->SGCgroup[p0];
./sgc.cpp:424:		if (w0 > C(0.0) && Arrptr->DEM[p0] != DEM_NO_DATA) // if there is a sub-grid cahnnel
./sgc.cpp:426:			dx = Arrptr->dx[p0];
./sgc.cpp:427:			dy = Arrptr->dy[p0];
./sgc.cpp:431:			if (i == 0 || Arrptr->SGCwidth[p0 - 1] > C(0.0))           chan_length += C(0.5)*dx;    // check for domain edge or west side trib 
./sgc.cpp:432:			if (i == (Parptr->xsz - 1) || Arrptr->SGCwidth[p0 + 1] > C(0.0))           chan_length += C(0.5)*dx;    // check for domain edge or east side trib   
./sgc.cpp:433:			if (j == 0 || Arrptr->SGCwidth[p0 - Parptr->xsz] > C(0.0)) chan_length += C(0.5)*dy;    // check for domain edge or north side trib
./sgc.cpp:434:			if (j == (Parptr->ysz - 1) || Arrptr->SGCwidth[p0 + Parptr->xsz] > C(0.0)) chan_length += C(0.5)*dy;    // check for domain edge or south side trib
./sgc.cpp:435:			Arrptr->SGCc[p0] = m*getmax(chan_length, getmin(dx, dy)); // make sure channel is at least as long as the shortest cell width then apply meander coefficient m
./sgc.cpp:439:			if (w0 < getmax(dx, dy) && w0*Arrptr->SGCc[p0] > Arrptr->dA[p0])
./sgc.cpp:440:				Arrptr->SGCc[p0] = Arrptr->dA[p0] / w0;
./sgc.cpp:442:			if (Statesptr->SGCbed == ON && zf != no_data)	Arrptr->SGCz[p0] = getmin(zf, Arrptr->DEM[p0] - C(0.01));						// If bed elevation is specified in the bedfile set bed elevation bed to the bed file elevation and if above the DEM set to C(0.01) below the DEM
./sgc.cpp:443:			else if (Statesptr->SGCbfh_mode == ON)		Arrptr->SGCz[p0] = getmin(z0 - p, Arrptr->DEM[p0] - C(0.01));				// If the model is told to use p as depth use p as depth e.g. SGCbfh_mode
./sgc.cpp:444:			else if (Statesptr->SGCA_mode == ON)			Arrptr->SGCz[p0] = getmin(z0 - p / w0, Arrptr->DEM[p0] - C(0.01));			// If the model is told to use p as channel area use p as area and divide by width e.g. SGCA_mode
./sgc.cpp:445:			else if (a > 0)								Arrptr->SGCz[p0] = getmin(z0 - r*pow(a, p), Arrptr->DEM[p0] - C(0.01));		// Calculate z using the hydraulic geometry and catchement area, and if above the DEM set to C(0.01) below the DEM
./sgc.cpp:446:			else											Arrptr->SGCz[p0] = getmin(z0 - r*pow(w0, p), Arrptr->DEM[p0] - C(0.01));		// Calculate z using the hydraulic geometry and channel width, and if above the DEM set to C(0.01) below the DEM
./sgc.cpp:449:			Arrptr->SGCbfH[p0] = Arrptr->DEM[p0] - Arrptr->SGCz[p0]; // Calculate SGC bank full depth
./sgc.cpp:450:			if (Statesptr->SGClevee == ON) Arrptr->SGCbfH[p0] = Arrptr->SGCbfH[p0] + levee_tmp;
./sgc.cpp:456:				Arrptr->SGCc[p0] = Arrptr->SGCc[p0] * Arrptr->SGCwidth[p0]; // calculate SGCc
./sgc.cpp:457:				Arrptr->SGCbfV[p0] = Arrptr->SGCc[p0] * Arrptr->SGCbfH[p0]; // calculate bank full volume
./sgc.cpp:461:				//Arrptr->SGCbfH[p0] = Arrptr->DEM[p0]-Arrptr->SGCz[p0]; // Calculate SGC bank full depth
./sgc.cpp:462:				Arrptr->SGCc[p0] = Arrptr->SGCc[p0] * Arrptr->SGCwidth[p0] * sl*pow(Arrptr->SGCbfH[p0], C(-1.0) / sl) / (sl + C(1.0)); // calculate SGCc
./sgc.cpp:463:				Arrptr->SGCbfV[p0] = Arrptr->SGCc[p0] * pow(Arrptr->SGCbfH[p0], C(1.0) / sl + C(1.0)); // calculate bank full volume
./sgc.cpp:467:				//Arrptr->SGCbfH[p0] = Arrptr->DEM[p0]-Arrptr->SGCz[p0]; // Calculate SGC bank full depth
./sgc.cpp:468:				sl = w0 / (getmin(z0, Arrptr->DEM[p0]) - Arrptr->SGCz[p0]);  // calculate section slope using the minimum of DEM and z0 to preserve channel width at bank full, this channel will be rectangular with a linear slop bottom.
./sgc.cpp:469:				if (Arrptr->DEM[p0] > z0) Arrptr->SGCwidth[p0] = (Arrptr->DEM[p0] - Arrptr->SGCz[p0])*sl; // Calculate a new we if DEM is above bank height (e.g. we needs to be bigger)
./sgc.cpp:470:				Arrptr->SGCc[p0] = C(0.5)*Arrptr->SGCc[p0] * Arrptr->SGCwidth[p0]; // calculate SGCc
./sgc.cpp:471:				Arrptr->SGCbfV[p0] = Arrptr->SGCc[p0] * Arrptr->SGCbfH[p0]; // calculate bank full volume
./sgc.cpp:475:				//Arrptr->SGCbfH[p0] = Arrptr->DEM[p0]-Arrptr->SGCz[p0]; // Calculate SGC bank full depth
./sgc.cpp:476:				sl = w0 / (2 * (getmin(z0, Arrptr->DEM[p0]) - Arrptr->SGCz[p0]));  // calculate section slope using the minimum of DEM and z0 to preserve channel width at bank full, this channel will be rectangular with a linear slop bottom.
./sgc.cpp:478:				if (Arrptr->DEM[p0] > z0) Arrptr->SGCwidth[p0] = C(2.0)*(Arrptr->DEM[p0] - Arrptr->SGCz[p0])*sl;
./sgc.cpp:479:				Arrptr->SGCc[p0] = C(0.5)*Arrptr->SGCc[p0] * Arrptr->SGCwidth[p0]; // calculate SGCc
./sgc.cpp:480:				Arrptr->SGCbfV[p0] = Arrptr->SGCc[p0] * Arrptr->SGCbfH[p0]; // calculate bank full volume
./sgc.cpp:484:				//Arrptr->SGCbfH[p0] = Arrptr->DEM[p0] -Arrptr->SGCz[p0]; // Calculate SGC bank full depth
./sgc.cpp:485:				Arrptr->SGCc[p0] = Arrptr->SGCc[p0] * Arrptr->SGCwidth[p0] * C(2.0)*pow(Arrptr->SGCbfH[p0], C(-0.5)) / (C(2.0) + C(1.0)); // calculate SGCc
./sgc.cpp:486:				Arrptr->SGCbfV[p0] = Arrptr->SGCc[p0] * pow(Arrptr->SGCbfH[p0], C(3.0) / C(2.0)); // calculate bank full volume
./sgc.cpp:490:				//Arrptr->SGCbfH[p0] = Arrptr->DEM[p0]-Arrptr->SGCz[p0]; // Calculate SGC bank full depth
./sgc.cpp:491:				Arrptr->SGCc[p0] = Arrptr->SGCc[p0] * Arrptr->SGCwidth[p0]; // calculate SGCc
./sgc.cpp:492:				Arrptr->SGCbfV[p0] = Arrptr->SGCc[p0] * Arrptr->SGCbfH[p0]; // calculate bank full volume
./sgc.cpp:500:				Arrptr->SGCz[p0] = getmin (z0 - r*pow(w0,p), Arrptr->DEM[p0] - C(0.01));
./sgc.cpp:502:				//if (Arrptr->SGCz[p0] == Arrptr->DEM[p0]) Arrptr->SGCz[p0]-=C(0.01);
./sgc.cpp:503:				Arrptr->SGCsl[p0] = sl;  // for the trapazoidal channel SGCsl is an input parameter
./sgc.cpp:505:				Arrptr->SGCwidth[p0] = Arrptr->SGCwidth[p0] - 2*(Arrptr->DEM[p0]-Arrptr->SGCz[p0])*Arrptr->SGCsl[p0];
./sgc.cpp:515:			Arrptr->SGCz[p0] = Arrptr->DEM[p0]; // if no SGC set SGCz to floodplain elevation to allow easy water surface elevation outputs
./sgc.cpp:518:		//Arrptr->SGCbfH[p0] = Arrptr->DEM[p0]-Arrptr->SGCz[p0];
./sgc.cpp:534:			if (Arrptr->ChanMask[p0] > 0)
./sgc.cpp:537:				//Arrptr->DEM[p0] = Arrptr->DEM[p0] + big_number;
./sgc.cpp:538:				if (Arrptr->SGCwidth[p0] > C(0.0))
./sgc.cpp:540:					if (Arrptr->DEM[p0] == DEM_NO_DATA) // if DEM is nodata there cannot be a channel
./sgc.cpp:542:						Arrptr->SGCwidth[p0] = C(0.0);
./sgc.cpp:549:					Arrptr->DEM[p0] = DEM_NO_DATA;
./sgc.cpp:550:					Arrptr->SGCbfH[p0] = C(0.0);
./sgc.cpp:551:					Arrptr->SGCbfV[p0] = C(0.0);
./sgc.cpp:578:			z0 = Arrptr->DEM[p0];
./sgc.cpp:579:			z1 = Arrptr->DEM[p1];
./sgc.cpp:580:			zb0 = Arrptr->SGCz[p0];
./sgc.cpp:581:			zb1 = Arrptr->SGCz[p1];
./sgc.cpp:582:			h0 = Arrptr->H[p0];
./sgc.cpp:583:			h1 = Arrptr->H[p1];
./sgc.cpp:584:			w0 = Arrptr->SGCwidth[p0];
./sgc.cpp:585:			w1 = Arrptr->SGCwidth[p1];
./sgc.cpp:586:			if (Arrptr->Manningsn != NULL) fn = C(0.5)*(Arrptr->Manningsn[p0] + Arrptr->Manningsn[p1]);
./sgc.cpp:596:					Sf = sqrt(dh / Arrptr->dx[p0]);
./sgc.cpp:601:						Arrptr->QxSGold[pq0] = (pow(hflow, (C(5.0) / C(3.0)))*Sf / fn)*getmin(w0, w1);
./sgc.cpp:608:					Sf = sqrt(dh / Arrptr->dx[p0]);
./sgc.cpp:612:						Arrptr->QxSGold[pq0] = (-pow(hflow, (C(5.0) / C(3.0)))*Sf / fn);
./sgc.cpp:625:				Sf = sqrt(dh / Arrptr->dx[p0]);
./sgc.cpp:629:					Arrptr->Qxold[pq0] = (pow(hflow, (C(5.0) / C(3.0)))*Sf / fn);
./sgc.cpp:636:				Sf = sqrt(dh / Arrptr->dx[p0]);
./sgc.cpp:640:					Arrptr->Qxold[pq0] = (-pow(hflow, (C(5.0) / C(3.0)))*Sf / fn);
./sgc.cpp:656:			z0 = Arrptr->DEM[p0];
./sgc.cpp:657:			z1 = Arrptr->DEM[p1];
./sgc.cpp:658:			w0 = Arrptr->SGCwidth[p0];
./sgc.cpp:659:			w1 = Arrptr->SGCwidth[p1];
./sgc.cpp:660:			zb0 = Arrptr->SGCz[p0];
./sgc.cpp:661:			zb1 = Arrptr->SGCz[p1];
./sgc.cpp:662:			h0 = Arrptr->H[p0];
./sgc.cpp:663:			h1 = Arrptr->H[p1];
./sgc.cpp:664:			if (Arrptr->Manningsn != NULL) fn = C(0.5)*(Arrptr->Manningsn[p0] + Arrptr->Manningsn[p1]);
./sgc.cpp:675:					Sf = sqrt(dh / Arrptr->dy[p0]);
./sgc.cpp:679:						Arrptr->QySGold[pq0] = (pow(hflow, (C(5.0) / C(3.0)))*Sf / fn)*getmin(w0, w1);
./sgc.cpp:686:					Sf = sqrt(dh / Arrptr->dy[p0]);
./sgc.cpp:690:						Arrptr->QySGold[pq0] = (-pow(hflow, (C(5.0) / C(3.0)))*Sf / fn);
./sgc.cpp:703:				Sf = sqrt(dh / Arrptr->dy[p0]);
./sgc.cpp:707:					Arrptr->Qyold[pq0] = (pow(hflow, (C(5.0) / C(3.0)))*Sf / fn);
./sgc.cpp:714:				Sf = sqrt(dh / Arrptr->dy[p0]);
./sgc.cpp:718:					Arrptr->Qyold[pq0] = (-pow(hflow, (C(5.0) / C(3.0)))*Sf / fn);
./sgc.cpp:739:		hptr0 = Arrptr->H + j*Parptr->xsz;
./sgc.cpp:740:		qptr = Arrptr->Qx + j*(Parptr->xsz + 1) + 1;
./sgc.cpp:741:		wiptr = Arrptr->Weir_Identx + j*(Parptr->xsz + 1) + 1;
./sgc.cpp:756:				Arrptr->Qxold[i + (j*(Parptr->xsz + 1) + 1)] = C(0.0);
./sgc.cpp:757:				Arrptr->QxSGold[i + (j*(Parptr->xsz + 1) + 1)] = C(0.0);
./sgc.cpp:768:		hptr0 = Arrptr->H + j*Parptr->xsz;
./sgc.cpp:769:		hptr1 = Arrptr->H + (j + 1)*Parptr->xsz;
./sgc.cpp:770:		qptr = Arrptr->Qy + (j + 1)*(Parptr->xsz + 1);
./sgc.cpp:771:		wiptr = Arrptr->Weir_Identy + (j + 1)*(Parptr->xsz + 1);
./sgc.cpp:786:				Arrptr->Qyold[i + ((j + 1)*(Parptr->xsz + 1))] = C(0.0);
./sgc.cpp:787:				Arrptr->QySGold[i + ((j + 1)*(Parptr->xsz + 1))] = C(0.0);
./sgc.cpp:807:	z0 = Arrptr->DEM[p0]; z1 = Arrptr->DEM[p1];
./sgc.cpp:808:	w0 = Arrptr->SGCwidth[p0]; w1 = Arrptr->SGCwidth[p1];
./sgc.cpp:809:	zb0 = Arrptr->SGCz[p0]; zb1 = Arrptr->SGCz[p1];
./sgc.cpp:811:	h0 = Arrptr->H[p0]; h1 = Arrptr->H[p1];
./sgc.cpp:815:	bf0 = Arrptr->SGCbfH[p0];    bf1 = Arrptr->SGCbfH[p1];
./sgc.cpp:816:	if (Arrptr->Manningsn != NULL)   fn = C(0.5)*(Arrptr->Manningsn[p0] + Arrptr->Manningsn[p1]); // this could be pre-calculated
./sgc.cpp:826:			qc = Arrptr->QxSGold[pq0]; // Get old q in m3/s
./sgc.cpp:827:			gr0 = Arrptr->SGCgroup[p0];	gr1 = Arrptr->SGCgroup[p1]; // get channel groups
./sgc.cpp:829:			if (Arrptr->SGCManningsn != NULL)   cn = pow(C(0.5)*(Arrptr->SGCManningsn[p0] + Arrptr->SGCManningsn[p1]), C(2.)); // this could be pre-calculated
./sgc.cpp:834:			Sf = -dh / (Arrptr->dx[p0] * m);
./sgc.cpp:842:				R = CalcSGC_R(gr0, hflow, bf0, w0, Arrptr->SGCwidth[p0], A0, SGCptr);
./sgc.cpp:844:				Arrptr->QxSGold[pq0] = (qc - g*A0*dt*Sf) / (1 + dt*g*cn*fabs(qc) / (pow(R, C(4.0) / C(3.0))*A0));
./sgc.cpp:850:				R = CalcSGC_R(gr1, hflow, bf1, w1, Arrptr->SGCwidth[p1], A1, SGCptr);
./sgc.cpp:852:				Arrptr->QxSGold[pq0] = (qc - g*A1*dt*Sf) / (1 + dt*g*cn*fabs(qc) / (pow(R, C(4.0) / C(3.0))*A1));
./sgc.cpp:855:			Qc = Arrptr->QxSGold[pq0]; // Update channel flows
./sgc.cpp:857:		else Arrptr->QxSGold[pq0] = C(0.0); // make sure previous flux is set to zero
./sgc.cpp:862:	if (we < Arrptr->dy[p0]) // CCS dy[p0] for cell width relative to flow in x
./sgc.cpp:871:			q0 = Arrptr->Qxold[pq0]; // in m2/s
./sgc.cpp:875:			Sf = -dh / Arrptr->dx[p0];
./sgc.cpp:880:				Arrptr->Qxold[pq0] = (q0 - (g*dt*hflow*Sf)) / (1 + g*dt*fn*fn*fabs(q0) / pow(hflow, (C(7.0) / C(3.0))));//*Parptr->dx;
./sgc.cpp:881:				//Q= Arrptr->Qxold[pq0]*(Parptr->dx-we); //CCS_deletion
./sgc.cpp:882:				Q = Arrptr->Qxold[pq0] * (Arrptr->dx[p0] - we);
./sgc.cpp:885:				Arrptr->Qxold[pq0] = C(0.0); // Set Qxold to zero
./sgc.cpp:887:		else Arrptr->Qxold[pq0] = C(0.0); // Set Qxold to zero
./sgc.cpp:891:		//if (Arrptr->Qxold[pq0] != C(0.0))
./sgc.cpp:892:		//	printf("Qxold reset on large sub grid %" NUM_FMT"\n", Arrptr->Qxold[pq0]);
./sgc.cpp:893:		Arrptr->Qxold[pq0] = C(0.0);
./sgc.cpp:900:		//if ((Q-Qc) == C(0.0) || we >= Parptr->dx) Arrptr->Vx[pq0]=C(0.0); //CCS_deletion
./sgc.cpp:901:		if ((Q - Qc) == C(0.0) || we >= Arrptr->dy[p0])
./sgc.cpp:902:			Arrptr->Vx[pq0] = C(0.0); // CCS dy[p0] for cell width relative to channel flow in x
./sgc.cpp:905:			//Arrptr->Vx[pq0]=(Q-Qc)/(Parptr->dx-we)/hflow; //CCS_deletion
./sgc.cpp:906:			Arrptr->Vx[pq0] = (Q - Qc) / (Arrptr->dx[p0] - we) / hflow;
./sgc.cpp:907:			Arrptr->maxVx[pq0] = getmax(Arrptr->maxVx[pq0], fabs(Arrptr->Vx[pq0]));
./sgc.cpp:923:	z0 = Arrptr->DEM[p0]; z1 = Arrptr->DEM[p1];
./sgc.cpp:924:	w0 = Arrptr->SGCwidth[p0]; w1 = Arrptr->SGCwidth[p1];
./sgc.cpp:925:	zb0 = Arrptr->SGCz[p0]; zb1 = Arrptr->SGCz[p1];
./sgc.cpp:927:	h0 = Arrptr->H[p0]; h1 = Arrptr->H[p1];
./sgc.cpp:931:	bf0 = Arrptr->SGCbfH[p0];    bf1 = Arrptr->SGCbfH[p1];
./sgc.cpp:932:	if (Arrptr->Manningsn != NULL)   fn = C(0.5)*(Arrptr->Manningsn[p0] + Arrptr->Manningsn[p1]); // this could be pre-calculated
./sgc.cpp:942:			Qc = Arrptr->QySGold[pq0]; // Get old q in m3/s
./sgc.cpp:943:			gr0 = Arrptr->SGCgroup[p0];	gr1 = Arrptr->SGCgroup[p1]; // get channel groups
./sgc.cpp:946:			if (Arrptr->SGCManningsn != NULL)   cn = pow(C(0.5)*(Arrptr->SGCManningsn[p0] + Arrptr->SGCManningsn[p1]), 2); // this could be pre-calculated
./sgc.cpp:951:			Sf = -dh / (Arrptr->dy[p0] * m);
./sgc.cpp:959:				R = CalcSGC_R(gr0, hflow, bf0, w0, Arrptr->SGCwidth[p0], A0, SGCptr);
./sgc.cpp:961:				Arrptr->QySGold[pq0] = (qc - g*A0*dt*Sf) / (1 + dt*g*cn*fabs(qc) / (pow(R, C(4.0) / C(3.0))*A0));
./sgc.cpp:967:				R = CalcSGC_R(gr1, hflow, bf1, w1, Arrptr->SGCwidth[p1], A1, SGCptr);
./sgc.cpp:969:				Arrptr->QySGold[pq0] = (qc - g*A1*dt*Sf) / (1 + dt*g*cn*fabs(qc) / (pow(R, C(4.0) / C(3.0))*A1));
./sgc.cpp:972:			Qc = Arrptr->QySGold[pq0]; // Update channel flows
./sgc.cpp:974:		else Arrptr->QySGold[pq0] = C(0.0); // make sure previous flux is set to zero
./sgc.cpp:979:	if (we < Arrptr->dx[p0]) // CCS use dx[p0] for cell width relative to flow in y
./sgc.cpp:988:			q0 = Arrptr->Qyold[pq0]; // in m2/s
./sgc.cpp:991:			Sf = -dh / Arrptr->dy[p0];
./sgc.cpp:996:				Arrptr->Qyold[pq0] = (q0 - (g*dt*hflow*Sf)) / (1 + g*dt*fn*fn*fabs(q0) / pow(hflow, (C(7.0) / C(3.0))));
./sgc.cpp:997:				//Q= Arrptr->Qyold[pq0]*(Parptr->dx-we); //CCS_deletion
./sgc.cpp:998:				Q = Arrptr->Qyold[pq0] * (Arrptr->dy[p0] - we);
./sgc.cpp:1001:				Arrptr->Qyold[pq0] = C(0.0); // Set Qxold to zero
./sgc.cpp:1003:		else Arrptr->Qyold[pq0] = C(0.0); // make sure previous flux is set to zero
./sgc.cpp:1007:		//if (Arrptr->Qyold[pq0] != C(0.0))
./sgc.cpp:1008:		//	printf("Qyold reset on large sub grid %" NUM_FMT"\n", Arrptr->Qxold[pq0]);
./sgc.cpp:1009:		Arrptr->Qyold[pq0] = C(0.0);
./sgc.cpp:1016:		//if ((Q-Qc) == C(0.0) || we >= Parptr->dx) Arrptr->Vy[pq0]=C(0.0);// check Qfp is above CCS_deletion
./sgc.cpp:1017:		if ((Q - Qc) == C(0.0) || we >= Arrptr->dx[p0])
./sgc.cpp:1018:			Arrptr->Vy[pq0] = C(0.0); // check Qfp is above  CCS dx[p0] for cell width relative to channel flow in y
./sgc.cpp:1021:			//Arrptr->Vy[pq0]=(Q-Qc)/(Parptr->dx-we)/hflow; //CCS_deletion
./sgc.cpp:1022:			Arrptr->Vy[pq0] = (Q - Qc) / (Arrptr->dy[p0] - we) / hflow;
./sgc.cpp:1023:			Arrptr->maxVy[pq0] = getmax(Arrptr->maxVy[pq0], fabs(Arrptr->Vy[pq0]));
./sgc.cpp:1060:			if (Arrptr->H[pTH]>Solverptr->DepthThresh)
./sgc.cpp:1062:				if (Arrptr->SGCManningsn != NULL)   cn = Arrptr->SGCManningsn[pTH] * Arrptr->SGCManningsn[pTH]; // this could be pre-calculated
./sgc.cpp:1063:				else cn = SGCptr->SGCn[Arrptr->SGCgroup[pTH]];
./sgc.cpp:1064:				if (Arrptr->Manningsn != NULL) fn = Arrptr->Manningsn[pTH];
./sgc.cpp:1066:				CalcSGC_pointFREE(Arrptr->H[pTH], Arrptr->SGCwidth[pTH], BCptr->PS_Val[ps_index], Solverptr->DepthThresh, Solverptr->Tstep, getmin(Arrptr->dx[pTH], Arrptr->dy[pTH]), Solverptr->g, cn, fn, Arrptr->SGCbfH[pTH], Arrptr->SGCgroup[pTH], -1, &BCptr->PS_Q_FP_old[ps_index], &Qfree, &BCptr->PS_Q_SG_old[ps_index], SGCptr);
./sgc.cpp:1072:		Arrptr->SGCdVol[pTH] += dV; // Add volume to SGCdVol for use later by update H e.g wait for main update H before calculating H
./sgc.cpp:1085:		qxptr0 = Arrptr->Qx + j*(Parptr->xsz + 1);
./sgc.cpp:1086:		qyptr0 = Arrptr->Qy + j*(Parptr->xsz + 1);
./sgc.cpp:1087:		qyptr1 = Arrptr->Qy + (j + 1)*(Parptr->xsz + 1);
./sgc.cpp:1093:			dV += Arrptr->SGCdVol[p0]; // add on all other volume changes in cell
./sgc.cpp:1094:			Arrptr->SGCdVol[p0] = C(0.0); // rest SGCdVol to zero
./sgc.cpp:1097:				Arrptr->SGCVol[p0] += dV; // Add dV to Vol. This is now the total volume.
./sgc.cpp:1098:				Arrptr->SGCVol[p0] = getmax(Arrptr->SGCVol[p0], C(0.0)); // if volume has gone negative set to zero, should not happen so will result in mass balance error
./sgc.cpp:1099:				if (Arrptr->SGCVol[p0] > C(0.0))
./sgc.cpp:1101:					gr = Arrptr->SGCgroup[p0]; // channel group number
./sgc.cpp:1103:					if (Arrptr->SGCwidth[p0] == C(0.0))														Arrptr->H[p0] = Arrptr->SGCVol[p0]/Parptr->dA; // there is no sub-grid channel so normal updateH
./sgc.cpp:1104:					else if (Arrptr->SGCVol[p0] >= Arrptr->SGCbfV[p0] && Arrptr->SGCwidth[p0] < Parptr->dx)	Arrptr->H[p0] = Arrptr->SGCbfH[p0]+(Arrptr->SGCVol[p0]-Arrptr->SGCbfV[p0])/Parptr->dA; // there is a sub-grid channel but its over bank // Note need to include check for SGCwidth < cell width to make sure out of bank volume is not accounted for in cells with channels wider than a cell
./sgc.cpp:1105:					else																					Arrptr->H[p0] = CalcSGC_UpH(SGCptr->SGCchantype[gr],  Arrptr->SGCVol[p0], SGCptr->SGCs[gr], Arrptr->SGCc[p0]); // there is a sub-grid channel and its within bank
./sgc.cpp:1107:					if (Arrptr->SGCwidth[p0] == C(0.0))
./sgc.cpp:1108:						Arrptr->H[p0] = Arrptr->SGCVol[p0] / Arrptr->dA[p0]; // there is no sub-grid channel so normal updateH
./sgc.cpp:1109:					else if (Arrptr->SGCVol[p0] >= Arrptr->SGCbfV[p0] && Arrptr->SGCwidth[p0] < C(0.5)*(Arrptr->dx[p0] + Arrptr->dy[p0]))
./sgc.cpp:1110:						Arrptr->H[p0] = Arrptr->SGCbfH[p0] + (Arrptr->SGCVol[p0] - Arrptr->SGCbfV[p0]) / Arrptr->dA[p0]; // there is a sub-grid channel but its over bank // Note need to include check for SGCwidth < cell width to make sure out of bank volume is not accounted for in cells with channels wider than a cell
./sgc.cpp:1112:						Arrptr->H[p0] = CalcSGC_UpH(SGCptr->SGCchantype[gr], Arrptr->SGCVol[p0], SGCptr->SGCs[gr], Arrptr->SGCc[p0]); // there is a sub-grid channel and its within bank
./sgc.cpp:1114:				else Arrptr->H[p0] = C(0.0); // make sure H is zero if Vol is zero
./sgc.cpp:1117:			ThreadMax = getmax(Arrptr->H[p0], ThreadMax);
./sgc.cpp:1145:			if (Arrptr->SGCwidth[pTH] > C(0.0))
./sgc.cpp:1148:				himp = himp - Arrptr->SGCz[pTH];
./sgc.cpp:1151:				gr = Arrptr->SGCgroup[pTH]; // channel group number
./sgc.cpp:1152:				if (himp <= Arrptr->SGCbfH[pTH])				dV = CalcSGC_UpV(SGCptr->SGCchantype[gr], himp, SGCptr->SGCs[gr], Arrptr->SGCc[pTH]); //Calculate channel volume
./sgc.cpp:1153:				else											dV = Arrptr->SGCbfV[pTH] + (himp - Arrptr->SGCbfH[pTH])*Arrptr->dA[pTH]; // out of bank level
./sgc.cpp:1155:				if (Arrptr->H[pTH] <= Arrptr->SGCbfH[pTH])	    dV -= CalcSGC_UpV(SGCptr->SGCchantype[gr], Arrptr->H[pTH], SGCptr->SGCs[gr], Arrptr->SGCc[pTH]); //Calculate channel volume
./sgc.cpp:1156:				else											dV -= Arrptr->SGCbfV[pTH] + (Arrptr->H[pTH] - Arrptr->SGCbfH[pTH])*Arrptr->dA[pTH]; // out of bank level
./sgc.cpp:1157:				Arrptr->H[pTH] = himp;
./sgc.cpp:1162:				himp = himp - Arrptr->DEM[pTH]; // Get depth on floodplain
./sgc.cpp:1164:				dV = (himp - Arrptr->H[pTH])*Arrptr->dA[pTH];
./sgc.cpp:1165:				Arrptr->H[pTH] = himp;
./sgc.cpp:1168:			Arrptr->SGCVol[pTH] += dV;
./sgc.cpp:1190:				Hmax = getmax(Hmax, Arrptr->H[p0]);
./sgc.cpp:1236:				qptr = Arrptr->Qy + BCi;
./sgc.cpp:1237:				qoldptr = Arrptr->Qyold + BCi;
./sgc.cpp:1238:				qSGoldptr = Arrptr->QySGold + BCi;
./sgc.cpp:1250:				qptr = Arrptr->Qx + Parptr->xsz + (BCi - Parptr->xsz)*(Parptr->xsz + 1);
./sgc.cpp:1251:				qoldptr = Arrptr->Qxold + Parptr->xsz + (BCi - Parptr->xsz)*(Parptr->xsz + 1);
./sgc.cpp:1252:				qSGoldptr = Arrptr->QxSGold + Parptr->xsz + (BCi - Parptr->xsz)*(Parptr->xsz + 1);
./sgc.cpp:1264:				qptr = Arrptr->Qy + 2 * Parptr->xsz + Parptr->ysz - 1 - BCi + (Parptr->ysz)*(Parptr->xsz + 1);
./sgc.cpp:1265:				qoldptr = Arrptr->Qyold + 2 * Parptr->xsz + Parptr->ysz - 1 - BCi + (Parptr->ysz)*(Parptr->xsz + 1);
./sgc.cpp:1266:				qSGoldptr = Arrptr->QySGold + 2 * Parptr->xsz + Parptr->ysz - 1 - BCi + (Parptr->ysz)*(Parptr->xsz + 1);
./sgc.cpp:1278:				qptr = Arrptr->Qx + (numBCs - 1 - BCi)*(Parptr->xsz + 1);
./sgc.cpp:1279:				qoldptr = Arrptr->Qxold + (numBCs - 1 - BCi)*(Parptr->xsz + 1);
./sgc.cpp:1280:				qSGoldptr = Arrptr->QxSGold + (numBCs - 1 - BCi)*(Parptr->xsz + 1);
./sgc.cpp:1291:				cell_length = Arrptr->dy[p0];
./sgc.cpp:1292:				cell_width = Arrptr->dx[p0];
./sgc.cpp:1296:				cell_length = Arrptr->dx[p0];
./sgc.cpp:1297:				cell_width = Arrptr->dy[p0];
./sgc.cpp:1303:				if (Arrptr->H[p0]>Solverptr->DepthThresh)
./sgc.cpp:1305:					if (Arrptr->SGCManningsn != NULL)   cn = Arrptr->SGCManningsn[p0] * Arrptr->SGCManningsn[p0]; // this could be pre-calculated
./sgc.cpp:1306:					else cn = SGCptr->SGCn[Arrptr->SGCgroup[p0]];
./sgc.cpp:1307:					if (Arrptr->Manningsn != NULL) fn = Arrptr->Manningsn[p0];
./sgc.cpp:1310:					CalcSGC_pointFREE(Arrptr->H[p0], Arrptr->SGCwidth[p0], BCptr->BC_Val[BCi], Solverptr->DepthThresh, Solverptr->Tstep, cell_width, g, cn, fn, Arrptr->SGCbfH[p0], Arrptr->SGCgroup[p0], sign, qoldptr, qptr, qSGoldptr, SGCptr);
./sgc.cpp:1312:					hflow = Arrptr->H[p0];
./sgc.cpp:1313:					w0 = Arrptr->SGCwidth[p0];
./sgc.cpp:1318:					gr = Arrptr->SGCgroup[p0];
./sgc.cpp:1320:					if(Arrptr->SGCManningsn!=NULL)   cn=Arrptr->SGCManningsn[p0]*Arrptr->SGCManningsn[p0]; // this could be pre-calculated
./sgc.cpp:1322:					CalcSGC_A(gr, hflow, Arrptr->SGCbfH[p0], &A, &w0, SGCptr); // calculate channel area for SGC
./sgc.cpp:1323:					R = CalcSGC_R(gr, hflow, Arrptr->SGCbfH[p0], w0, Arrptr->SGCwidth[p0], A, SGCptr); // calculate hydraulic radius for SGC
./sgc.cpp:1326:					hflow = getmax(hflow-Arrptr->SGCbfH[p0], C(0.0)); // reduce hflow to account for channel
./sgc.cpp:1335:					if(Arrptr->Manningsn!=NULL) fn=Arrptr->Manningsn[p0];
./sgc.cpp:1354:				if (Arrptr->H[p0]>Solverptr->DepthThresh)
./sgc.cpp:1360:					h1 = Arrptr->H[p0];        // cell depth
./sgc.cpp:1361:					z1 = Arrptr->DEM[p0];      // FP elevation
./sgc.cpp:1362:					w0 = Arrptr->SGCwidth[p0]; // SGC width
./sgc.cpp:1367:						zb0 = Arrptr->SGCz[p0]; // channel bed
./sgc.cpp:1370:						gr = Arrptr->SGCgroup[p0];
./sgc.cpp:1377:						if (Arrptr->SGCManningsn != NULL)   cn = Arrptr->SGCManningsn[p0] * Arrptr->SGCManningsn[p0]; // this could be pre-calculated
./sgc.cpp:1379:						CalcSGC_A(gr, hflow, Arrptr->SGCbfH[p0], &A, &w0, SGCptr); // calculate channel area for SGC
./sgc.cpp:1380:						R = CalcSGC_R(gr, hflow, Arrptr->SGCbfH[p0], w0, Arrptr->SGCwidth[p0], A, SGCptr); // calculate hydraulic radius for SGC
./sgc.cpp:1383:						hflow = getmax(hflow - Arrptr->SGCbfH[p0], C(0.0)); // reduce hflow to account for channel
./sgc.cpp:1393:						if (Arrptr->Manningsn != NULL) fn = Arrptr->Manningsn[p0];
./sgc.cpp:1395:						dh = surface_elevation0 - (h1 + z1 - Arrptr->SGCbfH[p0]);
./sgc.cpp:1441:	evap_rate = InterpolateTimeSeries(Arrptr->evap, Solverptr->t); //constant rate across whole floodplain
./sgc.cpp:1454:			h0 = Arrptr->H[p0];
./sgc.cpp:1472:				//Arrptr->H[p0]=h0; TFD this causes inconsistancies
./sgc.cpp:1474:				bfh = Arrptr->SGCbfH[p0];
./sgc.cpp:1477:				if (Arrptr->SGCwidth[p0] > C(0.0) && h0 < bfh)
./sgc.cpp:1480:					//if (h_old < Arrptr->SGCbfH[p0] || Arrptr->SGCwidth[p0] > Parptr->dx) //CCS_deletion 
./sgc.cpp:1481:					if (h_old < Arrptr->SGCbfH[p0] || Arrptr->SGCwidth[p0] >= C(0.5)*(Arrptr->dx[p0] + Arrptr->dy[p0]))
./sgc.cpp:1484:						gr = Arrptr->SGCgroup[p0]; // channel group number
./sgc.cpp:1485:						V = CalcSGC_UpV(SGCptr->SGCchantype[gr], h_old, SGCptr->SGCs[gr], Arrptr->SGCc[p0]); //Calculate channel volume 
./sgc.cpp:1486:						V -= CalcSGC_UpV(SGCptr->SGCchantype[gr], h0, SGCptr->SGCs[gr], Arrptr->SGCc[p0]); //Calculate channel volume 
./sgc.cpp:1487:						Arrptr->SGCdVol[p0] -= V;
./sgc.cpp:1497:						gr = Arrptr->SGCgroup[p0]; // channel group number
./sgc.cpp:1498:						V = CalcSGC_UpV(SGCptr->SGCchantype[gr], bfh, SGCptr->SGCs[gr], Arrptr->SGCc[p0]); //Calculate bankfull area
./sgc.cpp:1499:						V -= CalcSGC_UpV(SGCptr->SGCchantype[gr], h0, SGCptr->SGCs[gr], Arrptr->SGCc[p0]); //Calculate channel area
./sgc.cpp:1502:						V += (cell_evap*Arrptr->dA[p0]);
./sgc.cpp:1503:						Arrptr->SGCdVol[p0] -= V; // remove volume from cell
./sgc.cpp:1511:					V = (cell_evap*Arrptr->dA[p0]);
./sgc.cpp:1512:					Arrptr->SGCdVol[p0] -= V; // remove volume from cell
./sgc.cpp:1530:	rain_rate = InterpolateTimeSeries(Arrptr->rain, Solverptr->t);//constant rate across whole floodplain
./sgc.cpp:1540:			V = (rain_rate*Solverptr->Tstep*Arrptr->dA[p0]); // now calc inside pragma loop to handle variable dA lat-long grids
./sgc.cpp:1542:			if (Arrptr->DEM[p0] != 1e10) // if not nodata cell
./sgc.cpp:1544:				Arrptr->SGCdVol[p0] += V; // add rainfall volume to cell		
./sgc.cpp:1546:				//Arrptr->H[p0]+=rain_rate*Solverptr->Tstep;
./sgc.cpp:1563:		rain_rate = InterpolateTimeSeries(Arrptr->rain, Solverptr->t);//constant rate across whole floodplain
./sgc.cpp:1575:			if (Arrptr->DEM[p0] != 1e10)
./sgc.cpp:1579:					V = (rain_rate*Solverptr->Tstep*Arrptr->dA[p0]);
./sgc.cpp:1580:					Arrptr->H[p0] += cell_rain; // Update H array for cell rainfall
./sgc.cpp:1581:					Arrptr->SGCdVol[p0] += V; // add rainfall volume to cell
./sgc.cpp:1585:				if (Arrptr->H[p0]>0) // Only proceed with rest of loop if cell is wet:
./sgc.cpp:1587:					h0 = Arrptr->H[p0];
./sgc.cpp:1588:					z0 = Arrptr->DEM[p0];
./sgc.cpp:1595:						z1 = Arrptr->DEM[p1];
./sgc.cpp:1596:						h1 = Arrptr->H[p1];
./sgc.cpp:1599:						Sfx = fabs(dh / Arrptr->dx[p0]); // friction slope in x 
./sgc.cpp:1606:						z1 = Arrptr->DEM[p1];
./sgc.cpp:1607:						h1 = Arrptr->H[p1];
./sgc.cpp:1610:						Sfy = fabs(dh / Arrptr->dy[p0]); // friction slope in y
./sgc.cpp:1615:					Arrptr->H[p0]+=cell_rain; // Update H array for cell rainfall
./sgc.cpp:1616:					Arrptr->SGCdVol[p0]+=V; // add rainfall volume to cell
./sgc.cpp:1620:					if (Arrptr->SGCwidth[p0] == C(0.0)) // if not subgrid channel cell
./sgc.cpp:1622:						h0 = Arrptr->H[p0];
./sgc.cpp:1625:							h1 = Arrptr->H[Arrptr->FlowDir[p0]] - Arrptr->SGCbfH[Arrptr->FlowDir[p0]];
./sgc.cpp:1627:							z0 = Arrptr->DEM[p0]; //cell DEM height
./sgc.cpp:1628:							z1 = Arrptr->DEM[Arrptr->FlowDir[p0]]; //lowest neighbour cell DEM height 
./sgc.cpp:1638:							flow_fraction = Solverptr->Tstep / Arrptr->RouteInt[p0]; // fraction of cell volume to route in this time step
./sgc.cpp:1643:							flowV = flow*Arrptr->dA[p0] * flow_fraction; // Calc flow volume (flow depth * area * flow fraction)
./sgc.cpp:1645:							Arrptr->SGCdVol[p0] -= flowV; // Remove flow volume from source cell
./sgc.cpp:1646:							Arrptr->SGCdVol[Arrptr->FlowDir[p0]] += flowV; // Add flow volume to recipient cell
./fp_trent.cpp:41:	z0=Arrptr->DEM[p0];
./fp_trent.cpp:42:    z1=Arrptr->DEM[p1];
./fp_trent.cpp:51:	h0=hl=Arrptr->H[p0];
./fp_trent.cpp:52:  	h1=hr=Arrptr->H[p1];
./fp_trent.cpp:54:	hul=Arrptr->HU[p0] ;
./fp_trent.cpp:55:	hur=Arrptr->HU[p1] ;
./fp_trent.cpp:57:	hvl=Arrptr->HV[p0] ;
./fp_trent.cpp:58:	hvr=Arrptr->HV[p1] ;
./fp_trent.cpp:62:	Arrptr->FH[pq0]= ;
./fp_trent.cpp:63: 	Arrptr->FHU[pq0]= ;
./fp_trent.cpp:64: 	Arrptr->FHV[pq0]= ;
./fp_trent.cpp:66:	Arrptr->RSHU[p0]= ;	
./fp_trent.cpp:67:	Arrptr->LSHU[p1]= ;
./fp_trent.cpp:68:	Arrptr->RSHV[p0]= ;	
./fp_trent.cpp:69:	Arrptr->LSHV[p1]= ;
./fp_trent.cpp:140:				Arrptr->FHx[pq0]=C(0.5)*(f1rp+f1lp-a1m*alfa1*e11-a2m*alfa2*e21-a3m*alfa3*e31) ;
./fp_trent.cpp:141:				Arrptr->FHUx[pq0]=C(0.5)*(f2rp+f2lp-a1m*alfa1*e12-a2m*alfa2*e22-a3m*alfa3*e32) ;
./fp_trent.cpp:142:				Arrptr->FHVx[pq0]=C(0.5)*(f3rp+f3lp-a1m*alfa1*e13-a2m*alfa2*e23-a3m*alfa3*e33) ;
./fp_trent.cpp:144:				s0=-(Arrptr->DEM[p1]-Arrptr->DEM[p0])/dl;
./fp_trent.cpp:146:				Arrptr->RSHU[p0]=C(0.5)*g*hl*s0 ;	
./fp_trent.cpp:147:				Arrptr->LSHU[p1]=C(0.5)*g*hr*s0 ;
./fp_trent.cpp:149:				Arrptr->RSHV[p0]=C(0.) ;	
./fp_trent.cpp:150:				Arrptr->LSHV[p1]=C(0.) ;								
./fp_trent.cpp:159:				if (hr*fctm+Arrptr->DEM[p1] > Arrptr->DEM[p0]  && (hur/hr-pow(g*hr,C(0.5))) <= C(0.) ){	/* overtopping */
./fp_trent.cpp:161:					wsurface=(Arrptr->DEM[p0]-hr-Arrptr->DEM[p1])/dl ;
./fp_trent.cpp:163:					Arrptr->FHx[pq0]=hur ;
./fp_trent.cpp:164:					Arrptr->FHUx[pq0]=hur*hur/hr ;
./fp_trent.cpp:165:					Arrptr->FHVx[pq0]=hvr*hur/hr ;
./fp_trent.cpp:167:					Arrptr->H[p0]=dtol;
./fp_trent.cpp:169:					Arrptr->RSHU[p0]=g*hr*wsurface ;	
./fp_trent.cpp:170:					Arrptr->LSHU[p1]=g*hr*wsurface ;
./fp_trent.cpp:172:					Arrptr->RSHV[p0]=C(0.) ;	
./fp_trent.cpp:173:					Arrptr->LSHV[p1]=C(0.) ;	
./fp_trent.cpp:178:						// WDC modifies Arrptr->FHx[pq0]=0 ;
./fp_trent.cpp:181:							Arrptr->FHUx[pq0]=hur*hur/hr ;  // remind (-) sign while upgrade
./fp_trent.cpp:182:							Arrptr->FHVx[pq0]=C(0.) ;
./fp_trent.cpp:186:							Arrptr->FHUx[pq0]=C(0.) ;
./fp_trent.cpp:187:							Arrptr->FHVx[pq0]=C(0.) ;
./fp_trent.cpp:197:								Arrptr->FHx[pq0]=C(0.5)*(cbarra*(z0-z1)-hr*(fabs(ubarra)+cbarra));
./fp_trent.cpp:200:								Arrptr->FHx[pq0]=0 ;
./fp_trent.cpp:212:							//s0=-(Arrptr->DEM[p1+1]-Arrptr->DEM[p1])/dl;
./fp_trent.cpp:213:							//Arrptr->RSHU[p0]=C(0.0) ;	
./fp_trent.cpp:214:							//if (s0 >= 0) Arrptr->LSHU[p1]=C(0.0);
./fp_trent.cpp:215:							//else if (Arrptr->H[p1+1] < dtol) Arrptr->LSHU[p1]=C(0.0);
./fp_trent.cpp:216:							//else Arrptr->LSHU[p1]=C(0.5)*g*hr*s0;
./fp_trent.cpp:218:							Arrptr->RSHV[p0]=C(0.0) ;	
./fp_trent.cpp:219:							Arrptr->LSHV[p1]=C(0.0) ;
./fp_trent.cpp:221:							//Arrptr->LSHU[p1]=C(0.0) ;
./fp_trent.cpp:222:							//Arrptr->LSHV[p1]=C(0.0) ;
./fp_trent.cpp:223:							Arrptr->RSHU[p0]=C(0.0) ;//GUSTAVO
./fp_trent.cpp:224:							Arrptr->LSHU[p1]=C(0.0) ;//GUSTAVO
./fp_trent.cpp:246:							Arrptr->FHx[pq0]=C(0.5)*(f1rp+f1lp-a1m*alfa1*e11-a2m*alfa2*e21-a3m*alfa3*e31) ; 
./fp_trent.cpp:247:							Arrptr->FHUx[pq0]=C(0.5)*(f2rp+f2lp-a1m*alfa1*e12-a2m*alfa2*e22-a3m*alfa3*e32) ;
./fp_trent.cpp:248:							Arrptr->FHVx[pq0]=C(0.5)*(f3rp+f3lp-a1m*alfa1*e13-a2m*alfa2*e23-a3m*alfa3*e33) ;
./fp_trent.cpp:255:							Arrptr->FHUx[pq0]=hur*(hur/hr-pow(g*hr,C(0.5)))+C(0.5)*g*hr*hr ;  // remind (-) sign while upgrade
./fp_trent.cpp:256:							Arrptr->FHVx[pq0]=C(0.) ;
./fp_trent.cpp:257:							Arrptr->FHx[pq0]=C(0.);//GUSTAVO
./fp_trent.cpp:259:							Arrptr->RSHV[p0]=C(0.0) ;//GUSTAVO
./fp_trent.cpp:260:							Arrptr->LSHV[p1]=C(0.0) ;//GUSTAVO
./fp_trent.cpp:261:							Arrptr->RSHU[p0]=C(0.0) ;//GUSTAVO
./fp_trent.cpp:262:							Arrptr->LSHU[p1]=C(0.0) ;//GUSTAVO
./fp_trent.cpp:266:						//	Arrptr->FHUx[pq0]=C(0.) ;
./fp_trent.cpp:267:						//	Arrptr->FHVx[pq0]=C(0.) ;
./fp_trent.cpp:278:				if (hl*fctm+Arrptr->DEM[p0]  > Arrptr->DEM[p1]  && (hul/hl+pow(g*hl,C(0.5))) >= C(0.)){	/* overtopping */
./fp_trent.cpp:280:					wsurface=(hl+Arrptr->DEM[p0]-Arrptr->DEM[p1])/dl;
./fp_trent.cpp:282:					Arrptr->FHx[pq0]=hul ;
./fp_trent.cpp:283:					Arrptr->FHUx[pq0]=hul*hul/hl ;
./fp_trent.cpp:284:					Arrptr->FHVx[pq0]=hvl*hul/hl ;
./fp_trent.cpp:286:					Arrptr->H[p1]=dtol;
./fp_trent.cpp:288:					Arrptr->RSHU[p0]=g*hl*wsurface ;	
./fp_trent.cpp:289:					Arrptr->LSHU[p1]=g*hl*wsurface ;
./fp_trent.cpp:291:					Arrptr->RSHV[p0]=C(0.) ;	
./fp_trent.cpp:292:					Arrptr->LSHV[p1]=C(0.) ;
./fp_trent.cpp:300:						// WDC modifies Arrptr->FHx[pq0]=0 ;		
./fp_trent.cpp:307:					//Arrptr->RSHU[p0]=C(0.0) ;
./fp_trent.cpp:308:					//if (Arrptr->LSHU[p0] > 0) Arrptr->RSHU[p0]; 
./fp_trent.cpp:309:					//else Arrptr->RSHU[p0]= -Arrptr->LSHU[p0] ;
./fp_trent.cpp:311:					//s0=-(Arrptr->DEM[p1+1]-Arrptr->DEM[p1])/dl;
./fp_trent.cpp:312:					//if (Arrptr->LSHU[p0] <= 0) Arrptr->RSHU[p0] = C(0.0);
./fp_trent.cpp:313:					//else if (Arrptr->H[p0-1] < dtol) Arrptr->RSHU[p0] = C(0.0); // if other side is also dry assume zero
./fp_trent.cpp:314:					//else Arrptr->RSHU[p0]=Arrptr->LSHU[p0] ;	
./fp_trent.cpp:315:					//Arrptr->LSHU[p1]=C(0.0) ; //C(0.5)*g*hr*s0;
./fp_trent.cpp:317:					Arrptr->RSHV[p0]=C(0.0) ;	
./fp_trent.cpp:318:					Arrptr->LSHV[p1]=C(0.0) ;
./fp_trent.cpp:320:					//Arrptr->RSHU[p0]=C(0.0) ;
./fp_trent.cpp:321:					//Arrptr->RSHV[p0]=C(0.0) ;
./fp_trent.cpp:322:					Arrptr->RSHU[p0]=C(0.0) ;//GUSTAVO
./fp_trent.cpp:323:					Arrptr->LSHU[p1]=C(0.0) ;//GUSTAVO
./fp_trent.cpp:345:					Arrptr->FHx[pq0]=C(0.5)*(f1rp+f1lp-a1m*alfa1*e11-a2m*alfa2*e21-a3m*alfa3*e31) ; 
./fp_trent.cpp:346:					Arrptr->FHUx[pq0]=C(0.5)*(f2rp+f2lp-a1m*alfa1*e12-a2m*alfa2*e22-a3m*alfa3*e32) ;
./fp_trent.cpp:347:					Arrptr->FHVx[pq0]=C(0.5)*(f3rp+f3lp-a1m*alfa1*e13-a2m*alfa2*e23-a3m*alfa3*e33) ;
./fp_trent.cpp:353:						// WDC modifies Arrptr->FHx[pq0]=0 ;		
./fp_trent.cpp:357:							Arrptr->FHUx[pq0]=hul*(hul/hl+pow(g*hl,C(0.5)))+C(0.5)*g*hl*hl;
./fp_trent.cpp:358:							Arrptr->FHVx[pq0]=C(0.);
./fp_trent.cpp:360:							Arrptr->FHx[pq0]=C(0.);//GUSTAVO
./fp_trent.cpp:362:							Arrptr->RSHV[p0]=C(0.0) ;//GUSTAVO
./fp_trent.cpp:363:							Arrptr->LSHV[p1]=C(0.0) ;//GUSTAVO
./fp_trent.cpp:364:							Arrptr->RSHU[p0]=C(0.0) ;//GUSTAVO
./fp_trent.cpp:365:							Arrptr->LSHU[p1]=C(0.0) ;//GUSTAVO
./fp_trent.cpp:369:						//	Arrptr->FHUx[pq0]=C(0.);
./fp_trent.cpp:370:						//	Arrptr->FHVx[pq0]=C(0.);
./fp_trent.cpp:377:							Arrptr->FHUx[pq0]=hul*hul/hl;
./fp_trent.cpp:378:							Arrptr->FHVx[pq0]=C(0.);
./fp_trent.cpp:382:							Arrptr->FHUx[pq0]=C(0.);
./fp_trent.cpp:383:							Arrptr->FHVx[pq0]=C(0.);
./fp_trent.cpp:389:						Arrptr->RSHU[p0]=0 ;
./fp_trent.cpp:390:						Arrptr->RSHV[p0]=0 ; 
./fp_trent.cpp:404:								Arrptr->FHx[pq0]=C(-0.5)*(cbarra*(z1-z0)-hl*(fabs(ubarra)+cbarra));
./fp_trent.cpp:407:								Arrptr->FHx[pq0]=C(0.);
./fp_trent.cpp:414:						// 2nd Add all betas to Arrptr->RSHU[p0], Arrptr->RSHV[p0];
./fp_trent.cpp:423:  Q=Arrptr->FHx[pq0]*dl ; // origional version included addition *dl but removed for compatability with UpdateH JCN
./fp_trent.cpp:433:	    Arrptr->Vx[pq0]=Arrptr->FHx[pq0]/hflow;
./fp_trent.cpp:435:	    Arrptr->maxVx[pq0]=getmax(Arrptr->maxVx[pq0],fabs(Arrptr->Vx[pq0]));
./fp_trent.cpp:437:	  else Arrptr->Vx[pq0]=C(0.0);
./fp_trent.cpp:471:  z0=Arrptr->DEM[p0];
./fp_trent.cpp:472:  z1=Arrptr->DEM[p1];
./fp_trent.cpp:483:	h0=hl=Arrptr->H[p0];
./fp_trent.cpp:484:  	h1=hr=Arrptr->H[p1];
./fp_trent.cpp:486:	hul=Arrptr->HU[p0] ;
./fp_trent.cpp:487:	hur=Arrptr->HU[p1] ;
./fp_trent.cpp:489:	hvl=Arrptr->HV[p0] ;
./fp_trent.cpp:490:	hvr=Arrptr->HV[p1] ;
./fp_trent.cpp:496:	Arrptr->FH[pq0]= ;
./fp_trent.cpp:497: 	Arrptr->FHU[pq0]= ;
./fp_trent.cpp:498: 	Arrptr->FHV[pq0]= ;
./fp_trent.cpp:502:	Arrptr->BSHU[p0]= ;	
./fp_trent.cpp:503:	Arrptr->TSHU[p1]= ;
./fp_trent.cpp:505:	Arrptr->BSHV[p0]= ;	
./fp_trent.cpp:506:	Arrptr->TSHV[p1]= ;
./fp_trent.cpp:578:				Arrptr->FHy[pq0]=C(0.5)*(g1rp+g1lp-a1m*alfa1*e11-a2m*alfa2*e21-a3m*alfa3*e31) ;
./fp_trent.cpp:579:				Arrptr->FHUy[pq0]=C(0.5)*(g2rp+g2lp-a1m*alfa1*e12-a2m*alfa2*e22-a3m*alfa3*e32) ;
./fp_trent.cpp:580:				Arrptr->FHVy[pq0]=C(0.5)*(g3rp+g3lp-a1m*alfa1*e13-a2m*alfa2*e23-a3m*alfa3*e33) ;
./fp_trent.cpp:582:				s0=-(Arrptr->DEM[p1]-Arrptr->DEM[p0])/dl;
./fp_trent.cpp:584:				Arrptr->BSHU[p0]=C(0.) ;	
./fp_trent.cpp:585:				Arrptr->TSHU[p1]=C(0.) ;
./fp_trent.cpp:587:				Arrptr->BSHV[p0]=C(0.5)*g*hl*s0 ;	
./fp_trent.cpp:588:				Arrptr->TSHV[p1]=C(0.5)*g*hr*s0 ;																				
./fp_trent.cpp:596:				if (hr*fctm+Arrptr->DEM[p1] > Arrptr->DEM[p0] && (hvr/hr-pow(g*hr,C(0.5)))<= C(0.)){	/* overtopping */
./fp_trent.cpp:598:					wsurface=(hl+Arrptr->DEM[p0]-hr-Arrptr->DEM[p1])/dl;	
./fp_trent.cpp:600:					Arrptr->FHy[pq0]=hvr ;
./fp_trent.cpp:601:					Arrptr->FHUy[pq0]=hvr*hur/hr ;
./fp_trent.cpp:602:					Arrptr->FHVy[pq0]=hvr*hvr/hr ;
./fp_trent.cpp:604:					Arrptr->H[p0]=dtol;
./fp_trent.cpp:606:					Arrptr->BSHU[p0]=C(0.) ;	
./fp_trent.cpp:607:					Arrptr->TSHU[p1]=C(0.) ;
./fp_trent.cpp:609:					Arrptr->BSHV[p0]=g*hr*wsurface ;	
./fp_trent.cpp:610:					Arrptr->TSHV[p1]=g*hr*wsurface ;
./fp_trent.cpp:618:						//Arrptr->FHy[pq0]=0 ;
./fp_trent.cpp:625:					//s0=-(Arrptr->DEM[p1]-Arrptr->DEM[p1+Parptr->xsz])/dl; //work out slope on other side
./fp_trent.cpp:626:					//if (s0 < 0) Arrptr->TSHV[p1]=C(0.0); // if away from boundary use zero
./fp_trent.cpp:627:					//else Arrptr->TSHV[p1]=-C(0.5)*g*hr*s0 ; // if towrads boundary balance woth ghost cell
./fp_trent.cpp:628:					//s0=-(Arrptr->DEM[p1+Parptr->xsz]-Arrptr->DEM[p1])/dl;
./fp_trent.cpp:630:					Arrptr->BSHU[p0]=C(0.0) ;	
./fp_trent.cpp:631:					//Arrptr->TSHU[p1]=C(0.0) ;
./fp_trent.cpp:633:					Arrptr->BSHV[p0]=C(0.0) ;	
./fp_trent.cpp:634:					//if (s0 >= 0) Arrptr->TSHV[p1]=C(0.0); 
./fp_trent.cpp:635:					//else if (Arrptr->H[p1+Parptr->xsz] < dtol) Arrptr->TSHV[p1]=C(0.0);
./fp_trent.cpp:636:					//else Arrptr->TSHV[p1]=C(0.5)*g*hr*s0 ;	
./fp_trent.cpp:638:					Arrptr->TSHU[p1]=C(0.0) ;
./fp_trent.cpp:639:					Arrptr->TSHV[p1]=C(0.0) ;
./fp_trent.cpp:660:					Arrptr->FHy[pq0]=C(0.5)*(g1rp+g1lp-a1m*alfa1*e11-a2m*alfa2*e21-a3m*alfa3*e31) ;
./fp_trent.cpp:661:					Arrptr->FHUy[pq0]=C(0.5)*(g2rp+g2lp-a1m*alfa1*e12-a2m*alfa2*e22-a3m*alfa3*e32) ;
./fp_trent.cpp:662:					Arrptr->FHVy[pq0]=C(0.5)*(g3rp+g3lp-a1m*alfa1*e13-a2m*alfa2*e23-a3m*alfa3*e33) ;
./fp_trent.cpp:668:						//Arrptr->FHy[pq0]=0 ;
./fp_trent.cpp:672:							Arrptr->FHUy[pq0]=C(0.);
./fp_trent.cpp:673:							Arrptr->FHVy[pq0]=hvr*(hvr/hr-pow(g*hr,C(0.5)))+C(0.5)*g*hr*hr; // remind (-) sign while upgrade
./fp_trent.cpp:674:							Arrptr->FHy[pq0]=C(0.);//GUSTAVO
./fp_trent.cpp:676:							Arrptr->BSHU[p0]=C(0.0) ;//GUSTAVO
./fp_trent.cpp:677:							Arrptr->BSHV[p0]=C(0.0) ;//GUSTAVO
./fp_trent.cpp:678:							Arrptr->TSHU[p1]=C(0.0) ;//GUSTAVO
./fp_trent.cpp:679:							Arrptr->TSHV[p1]=C(0.0) ;//GUSTAVO
./fp_trent.cpp:684:						//	Arrptr->FHUy[pq0]=C(0.);
./fp_trent.cpp:685:						//	Arrptr->FHVy[pq0]=C(0.);
./fp_trent.cpp:693:							Arrptr->FHUy[pq0]=C(0.);
./fp_trent.cpp:694:							Arrptr->FHVy[pq0]=hvr*hvr/hr; // remind (-) sign while upgrade
./fp_trent.cpp:699:							Arrptr->FHUy[pq0]=C(0.);
./fp_trent.cpp:700:							Arrptr->FHVy[pq0]=C(0.);	
./fp_trent.cpp:704:						Arrptr->TSHU[p1]=C(0.) ;
./fp_trent.cpp:705:						Arrptr->TSHV[p1]=C(0.) ;
./fp_trent.cpp:714:								Arrptr->FHy[pq0]=C(0.5)*(cbarra*(z0-z1)-hr*(fabs(ubarra)+cbarra));
./fp_trent.cpp:717:								Arrptr->FHy[pq0]=0 ;
./fp_trent.cpp:734:				if (hl*fctm+Arrptr->DEM[p0] > Arrptr->DEM[p1] && (hvl/hl +pow(g*hl,C(0.5)) ) >= C(0.)){	/* overtopping */
./fp_trent.cpp:737:					wsurface=(hl+Arrptr->DEM[p0]-hr-Arrptr->DEM[p1])/dl;	
./fp_trent.cpp:739:					Arrptr->FHy[pq0]=hvl ;
./fp_trent.cpp:740: 					Arrptr->FHUy[pq0]=hvl*hul/hl ;
./fp_trent.cpp:741: 					Arrptr->FHVy[pq0]=hvl*hvl/hl ;
./fp_trent.cpp:743:					Arrptr->H[p1]=dtol;
./fp_trent.cpp:745:					Arrptr->BSHU[p0]=C(0.) ;	
./fp_trent.cpp:746:					Arrptr->TSHU[p1]=C(0.) ;
./fp_trent.cpp:749:					Arrptr->BSHV[p0]=g*hl*wsurface ;	
./fp_trent.cpp:750:					Arrptr->TSHV[p1]=g*hl*wsurface ;
./fp_trent.cpp:765:					//Arrptr->BSHU[p0]=C(0.0);
./fp_trent.cpp:766:					//if (Arrptr->TSHV[p0] > 0) Arrptr->BSHV[p0] = C(0.0); 	
./fp_trent.cpp:767:					//else Arrptr->BSHV[p0]= -Arrptr->TSHV[p0];
./fp_trent.cpp:769:					//s0=-(Arrptr->DEM[p1+Arrptr->xsz]-Arrptr->DEM[p1])/dl;
./fp_trent.cpp:771:					//Arrptr->BSHU[p0]=C(0.0) ;	
./fp_trent.cpp:772:					Arrptr->TSHU[p1]=C(0.0) ;
./fp_trent.cpp:774:					//if (Arrptr->TSHV[p0] <= 0) Arrptr->BSHV[p0]=C(0.0);
./fp_trent.cpp:775:					//else Arrptr->BSHV[p0]=Arrptr->TSHV[p0] ;	
./fp_trent.cpp:776:					Arrptr->TSHV[p1]=C(0.0);	
./fp_trent.cpp:778:					Arrptr->BSHU[p0]=C(0.0);
./fp_trent.cpp:779:					Arrptr->BSHV[p0]=C(0.0);
./fp_trent.cpp:800:					Arrptr->FHy[pq0]=C(0.5)*(g1rp+g1lp-a1m*alfa1*e11-a2m*alfa2*e21-a3m*alfa3*e31) ;
./fp_trent.cpp:801:					Arrptr->FHUy[pq0]=C(0.5)*(g2rp+g2lp-a1m*alfa1*e12-a2m*alfa2*e22-a3m*alfa3*e32) ;
./fp_trent.cpp:802:					Arrptr->FHVy[pq0]=C(0.5)*(g3rp+g3lp-a1m*alfa1*e13-a2m*alfa2*e23-a3m*alfa3*e33) ;
./fp_trent.cpp:810:						//Arrptr->FHy[pq0]=0 ;
./fp_trent.cpp:814:							Arrptr->FHUy[pq0]=C(0.);
./fp_trent.cpp:815:							Arrptr->FHVy[pq0]=hvl*(hvl/hl+pow(g*hl,C(0.5)))+C(0.5)*g*hl*hl;
./fp_trent.cpp:816:							Arrptr->FHy[pq0]=C(0.);//GUSTAVO
./fp_trent.cpp:818:							Arrptr->TSHU[p1]=C(0.0) ;//GUSTAVO
./fp_trent.cpp:819:							Arrptr->TSHV[p1]=C(0.0);//GUSTAVO
./fp_trent.cpp:820:							Arrptr->BSHU[p0]=C(0.0);//GUSTAVO
./fp_trent.cpp:821:							Arrptr->BSHV[p0]=C(0.0);//GUSTAVO
./fp_trent.cpp:826:						//	Arrptr->FHUy[pq0]=C(0.);
./fp_trent.cpp:827:						//	Arrptr->FHVy[pq0]=C(0.);
./fp_trent.cpp:832:						//Arrptr->FHy[pq0]=0 ;
./fp_trent.cpp:836:							Arrptr->FHUy[pq0]=C(0.);
./fp_trent.cpp:837:							Arrptr->FHVy[pq0]=hvl*hvl/hl;
./fp_trent.cpp:841:							Arrptr->FHUy[pq0]=C(0.);
./fp_trent.cpp:842:							Arrptr->FHVy[pq0]=C(0.);	
./fp_trent.cpp:846:						Arrptr->BSHU[p0]=C(0.);
./fp_trent.cpp:847:						Arrptr->BSHV[p0]=C(0.);
./fp_trent.cpp:861:								Arrptr->FHy[pq0]=C(-0.5)*(cbarra*(z1-z0)-hl*(fabs(ubarra)+cbarra));
./fp_trent.cpp:864:								Arrptr->FHy[pq0]=C(0.);
./fp_trent.cpp:873:  Q=Arrptr->FHy[pq0]*dl  ;	// origional version included addition *dl but removed for compatability with UpdateH JCN
./fp_trent.cpp:883:	    Arrptr->Vy[pq0]=Arrptr->FHy[pq0]/hflow;
./fp_trent.cpp:885:	    Arrptr->maxVy[pq0]=getmax(Arrptr->maxVy[pq0],fabs(Arrptr->Vy[pq0]));
./fp_trent.cpp:887:	  else Arrptr->Vy[pq0]=C(0.0);
./fp_trent.cpp:903:		h0=Arrptr->H[p0];
./fp_trent.cpp:904:		if(MaskTestRoe(Arrptr->ChanMask[p0])) 
./fp_trent.cpp:936:		locH=Arrptr->H[p0];
./fp_trent.cpp:943:			locV=Arrptr->HV[p0]/locH;
./fp_trent.cpp:944:			locU=Arrptr->HU[p0]/locH;
./fp_trent.cpp:987:		  if(Arrptr->H[pc] > Solverptr->MomentumThresh)
./fp_trent.cpp:994:			Arrptr->HU[pc]+=-(Solverptr->Tstep/Parptr->dx)*(Arrptr->FHUx[pxr]-Arrptr->FHUx[pxl]+Arrptr->FHUy[pyr]-Arrptr->FHUy[pyl])+Solverptr->Tstep*(Arrptr->BSHU[pc]+Arrptr->TSHU[pc]+Arrptr->LSHU[pc]+Arrptr->RSHU[pc]) ;
./fp_trent.cpp:995:			Arrptr->HV[pc]+=-(Solverptr->Tstep/Parptr->dx)*(Arrptr->FHVx[pxr]-Arrptr->FHVx[pxl]+Arrptr->FHVy[pyr]-Arrptr->FHVy[pyl])+Solverptr->Tstep*(Arrptr->BSHV[pc]+Arrptr->TSHV[pc]+Arrptr->LSHV[pc]+Arrptr->RSHV[pc]) ;
./fp_trent.cpp:997:			norm=pow((Arrptr->HU[pc]/Arrptr->H[pc])*(Arrptr->HU[pc]/Arrptr->H[pc])+(Arrptr->HV[pc]/Arrptr->H[pc])*(Arrptr->HV[pc]/Arrptr->H[pc]),C(0.5)) ;		
./fp_trent.cpp:998:			if(Arrptr->Manningsn!=NULL)
./fp_trent.cpp:1000:			  fn=Arrptr->Manningsn[pc];   // centered
./fp_trent.cpp:1006:		    manning=pow((pow(fn,C(1.5))/Arrptr->H[pc]+C(0.)*pow(fn,C(1.5))/Parptr->dx),(C(4.)/C(3.))) ;
./fp_trent.cpp:1008:		    Arrptr->HU[pc]*=(C(1.)/(C(1.)+Solverptr->g*Solverptr->Tstep*sf)) ;
./fp_trent.cpp:1009:		    Arrptr->HV[pc]*=(C(1.)/(C(1.)+Solverptr->g*Solverptr->Tstep*sf)) ;
./fp_trent.cpp:1012:			Arrptr->HU[pc]=C(0.);
./fp_trent.cpp:1013:			Arrptr->HV[pc]=C(0.);
./lisflood.cpp:730:			write_ascfile(Fnameptr->resrootname, -1, ".dem", Arrptr->SGCz, Arrptr->DEM, 0, Statesptr, Parptr);
./lisflood.cpp:732:			write_ascfile(Fnameptr->resrootname, -1, ".dem", Arrptr->DEM, Arrptr->DEM, 0, Statesptr, Parptr);
./lisflood_orig.cpp:728:			write_ascfile(Fnameptr->resrootname, -1, ".dem", Arrptr->SGCz, Arrptr->DEM, 0, Statesptr, Parptr);
./lisflood_orig.cpp:730:			write_ascfile(Fnameptr->resrootname, -1, ".dem", Arrptr->DEM, Arrptr->DEM, 0, Statesptr, Parptr);
./boundary.cpp:33:		Arrptr->Qx[j*(Parptr->xsz + 1)] = C(0.0);  //zero West boundary
./boundary.cpp:34:		Arrptr->Qx[Parptr->xsz + j*(Parptr->xsz + 1)] = C(0.0); //zero East boundary
./boundary.cpp:37:		Arrptr->Qy[i] = C(0.0);  //zero North boundary
./boundary.cpp:38:		Arrptr->Qy[i + Parptr->ysz*(Parptr->xsz + 1)] = C(0.0); //zero South boundary
./boundary.cpp:53:				qptr = Arrptr->Qy + BCi;
./boundary.cpp:54:				qoldptr = Arrptr->Qyold + BCi;
./boundary.cpp:65:				qptr = Arrptr->Qx + Parptr->xsz + (BCi - Parptr->xsz)*(Parptr->xsz + 1);
./boundary.cpp:66:				qoldptr = Arrptr->Qxold + Parptr->xsz + (BCi - Parptr->xsz)*(Parptr->xsz + 1);
./boundary.cpp:77:				qptr = Arrptr->Qy + 2 * Parptr->xsz + Parptr->ysz - 1 - BCi + (Parptr->ysz)*(Parptr->xsz + 1);
./boundary.cpp:78:				qoldptr = Arrptr->Qyold + 2 * Parptr->xsz + Parptr->ysz - 1 - BCi + (Parptr->ysz)*(Parptr->xsz + 1);
./boundary.cpp:89:				qptr = Arrptr->Qx + (numBCs - 1 - BCi)*(Parptr->xsz + 1);
./boundary.cpp:90:				qoldptr = Arrptr->Qxold + (numBCs - 1 - BCi)*(Parptr->xsz + 1);
./boundary.cpp:98:			if (BCptr->BC_Ident[BCi] == FREE1 && Arrptr->H[p0] > Solverptr->DepthThresh)
./boundary.cpp:100:				hflow = Arrptr->H[p0];
./boundary.cpp:101:				h0 = Arrptr->H[p0];
./boundary.cpp:102:				h1 = Arrptr->H[p1];
./boundary.cpp:103:				z0 = Arrptr->DEM[p0];
./boundary.cpp:104:				z1 = Arrptr->DEM[p1];
./boundary.cpp:105:				if (Arrptr->Manningsn != NULL) fn = Arrptr->Manningsn[p0]; else fn = Parptr->FPn;
./boundary.cpp:107:				if (!(Arrptr->ChanMask[p0] != -1))
./boundary.cpp:129:						if (edge == 2) *qptr = C(1.75)*sqrt(g)*pow(Arrptr->H[i - 1 + (Parptr->ysz)*(Parptr->xsz)], C(1.5)); // East
./boundary.cpp:130:						else if (edge == 4)*qptr = C(1.75)*sqrt(g)*pow(Arrptr->H[i + 1 + (Parptr->ysz)*(Parptr->xsz)], C(1.5)); // West
./boundary.cpp:131:						else if (edge == 3) *qptr = C(1.75)*sqrt(g)*pow(Arrptr->H[i + (Parptr->ysz - 1)*(Parptr->xsz)], C(1.5));	// South			
./boundary.cpp:132:						else if (edge == 1) *qptr = C(1.75)*sqrt(g)*pow(Arrptr->H[i + (Parptr->ysz + 1)*(Parptr->xsz)], C(1.5));	// North
./boundary.cpp:163:						if (dir == 1) Arrptr->TRecy[pTQ] = Solverptr->Tstep;
./boundary.cpp:164:						if (dir == 2) Arrptr->TRecx[pTQ] = Solverptr->Tstep;
./boundary.cpp:174:							if (dir == 1) Arrptr->LimQy[pTQ] = *qptr;
./boundary.cpp:175:							if (dir == 2) Arrptr->LimQx[pTQ] = *qptr;
./boundary.cpp:190:				if (Arrptr->H[p0]>Solverptr->DepthThresh)
./boundary.cpp:192:					hflow = getmax(Arrptr->H[p0], BCptr->BC_Val[BCi] - Arrptr->DEM[p0]);
./boundary.cpp:194:					h1 = Arrptr->H[p0];
./boundary.cpp:195:					z1 = Arrptr->DEM[p0];
./boundary.cpp:197:					if (Arrptr->Manningsn != NULL) fn = Arrptr->Manningsn[p0]; else fn = Parptr->FPn;
./boundary.cpp:199:					if (!(Arrptr->ChanMask[p0] != -1))
./boundary.cpp:230:							if (dir == 1) Arrptr->TRecy[pTQ] = Solverptr->Tstep;
./boundary.cpp:231:							if (dir == 2) Arrptr->TRecx[pTQ] = Solverptr->Tstep;
./boundary.cpp:242:								if (dir == 1) Arrptr->LimQy[pTQ] = *qptr;
./boundary.cpp:243:								if (dir == 2) Arrptr->LimQx[pTQ] = *qptr;
./boundary.cpp:252:				if (Arrptr->H[p0] > Solverptr->DepthThresh)
./boundary.cpp:256:					hflow = getmax(Arrptr->H[p0], h0 - Arrptr->DEM[p0]);
./boundary.cpp:257:					h1 = Arrptr->H[p0];
./boundary.cpp:258:					z1 = Arrptr->DEM[p0];
./boundary.cpp:260:					if (Arrptr->Manningsn != NULL) fn = Arrptr->Manningsn[p0]; else fn = Parptr->FPn;
./boundary.cpp:262:					if (!(Arrptr->ChanMask[p0] != -1)){
./boundary.cpp:267:								z0 = z1 + (Arrptr->DEM[p0] - Arrptr->DEM[p1]);//GUS
./boundary.cpp:272:								hvr = Arrptr->HV[p0];
./boundary.cpp:274:								hur = Arrptr->HU[p0];
./boundary.cpp:282:								z0 = z1 - (Arrptr->DEM[p1] - Arrptr->DEM[p0]);//GUS
./boundary.cpp:287:								hvl = Arrptr->HV[p0];
./boundary.cpp:289:								hul = Arrptr->HU[p0];
./boundary.cpp:299:								z0 = z1 + (Arrptr->DEM[p0] - Arrptr->DEM[p1]);//GUS
./boundary.cpp:304:								hvl = Arrptr->HV[p0];
./boundary.cpp:306:								hul = Arrptr->HU[p0];
./boundary.cpp:314:								z0 = z1 + (Arrptr->DEM[p0] - Arrptr->DEM[p1]);//GUS
./boundary.cpp:319:								hvr = Arrptr->HV[p0];
./boundary.cpp:321:								hur = Arrptr->HU[p0];
./boundary.cpp:363:								if (dir == 1) Arrptr->TRecy[pTQ] = Solverptr->Tstep;
./boundary.cpp:364:								if (dir == 2) Arrptr->TRecx[pTQ] = Solverptr->Tstep;
./boundary.cpp:374:									if (dir == 1) Arrptr->LimQy[pTQ] = *qptr;
./boundary.cpp:375:									if (dir == 2) Arrptr->LimQx[pTQ] = *qptr;
./boundary.cpp:396:				hflow = getmax(Arrptr->H[p0], h0 - Arrptr->DEM[p0]);
./boundary.cpp:401:					if (edge == 1 && Arrptr->H[p0] > Solverptr->MomentumThresh) // north edge
./boundary.cpp:403:						h1 = Arrptr->H[p0];
./boundary.cpp:405:						z1 = Arrptr->DEM[p0];
./boundary.cpp:407:						z0 = z1 + (Arrptr->DEM[p0] - Arrptr->DEM[p1]);//GUS
./boundary.cpp:413:						hvr = Arrptr->HV[p0];
./boundary.cpp:415:						hur = Arrptr->HU[p0];
./boundary.cpp:420:					if (edge == 2 && Arrptr->H[p0] > Solverptr->MomentumThresh) // east edge
./boundary.cpp:422:						h0 = Arrptr->H[p0];
./boundary.cpp:424:						z0 = Arrptr->DEM[p0];
./boundary.cpp:426:						z1 = z0 - (Arrptr->DEM[p1] - Arrptr->DEM[p0]);//GUS
./boundary.cpp:431:						hvl = Arrptr->HV[p0];
./boundary.cpp:434:						hul = Arrptr->HU[p0];
./boundary.cpp:441:					if (edge == 3 && Arrptr->H[p0] > Solverptr->MomentumThresh) // south edge
./boundary.cpp:443:						h0 = Arrptr->H[p0];
./boundary.cpp:445:						z0 = Arrptr->DEM[p0];
./boundary.cpp:447:						z1 = z0 - (Arrptr->DEM[p1] - Arrptr->DEM[p0]);//GUS
./boundary.cpp:452:						hvl = Arrptr->HV[p0];
./boundary.cpp:455:						hul = Arrptr->HU[p0];
./boundary.cpp:461:					if (edge == 4 && Arrptr->H[p0] > Solverptr->MomentumThresh) // west edge
./boundary.cpp:463:						h1 = Arrptr->H[p0];
./boundary.cpp:465:						z1 = Arrptr->DEM[p0];
./boundary.cpp:467:						z0 = z1 + (Arrptr->DEM[p0] - Arrptr->DEM[p1]);//GUS
./boundary.cpp:473:						hvr = Arrptr->HV[p0];
./boundary.cpp:475:						hur = Arrptr->HU[p0];
./boundary.cpp:488:				if (BCptr->BC_Ident[BCi] == NONE0 && Arrptr->H[p0] > Solverptr->DepthThresh)
./boundary.cpp:494:						hr = Arrptr->H[p0];
./boundary.cpp:495:						hvr = Arrptr->HV[p0];
./boundary.cpp:497:						Arrptr->FHUy[pTQ] = C(0.);
./boundary.cpp:498:						Arrptr->FHVy[pTQ] = hvr*(hvr / hr - pow(g*hr, C(0.5))) + C(0.5)*g*hr*hr;
./boundary.cpp:503:						hl = Arrptr->H[p0];
./boundary.cpp:504:						hul = Arrptr->HU[p0];
./boundary.cpp:506:						Arrptr->FHUx[pTQ] = hul*(hul / hl + pow(g*hl, C(0.5))) + C(0.5)*g*hl*hl;
./boundary.cpp:507:						Arrptr->FHVx[pTQ] = C(0.);
./boundary.cpp:511:						hl = Arrptr->H[p0];
./boundary.cpp:512:						hvl = Arrptr->HV[p0];
./boundary.cpp:514:						Arrptr->FHUy[pTQ] = C(0.);
./boundary.cpp:515:						Arrptr->FHVy[pTQ] = hvl*(hvl / hl + pow(g*hl, C(0.5))) + C(0.5)*g*hl*hl;
./boundary.cpp:519:						hr = Arrptr->H[p0];
./boundary.cpp:520:						hur = Arrptr->HU[p0];
./boundary.cpp:522:						Arrptr->FHUx[pTQ] = hur*(hur / hr - pow(g*hr, C(0.5))) + C(0.5)*g*hr*hr;
./boundary.cpp:523:						Arrptr->FHVx[pTQ] = C(0.);
./boundary.cpp:620:				Arrptr->FHx[pq0]=C(0.5)*(f1rp+f1lp-a1m*alfa1*e11-a2m*alfa2*e21-a3m*alfa3*e31) ;
./boundary.cpp:621:				Arrptr->FHUx[pq0]=C(0.5)*(f2rp+f2lp-a1m*alfa1*e12-a2m*alfa2*e22-a3m*alfa3*e32) ;
./boundary.cpp:622:				Arrptr->FHVx[pq0]=C(0.5)*(f3rp+f3lp-a1m*alfa1*e13-a2m*alfa2*e23-a3m*alfa3*e33) ;
./boundary.cpp:626:					s0=(Arrptr->DEM[p1]-Arrptr->DEM[p0])/dl;
./boundary.cpp:627:					Arrptr->RSHU[p0]=C(0.5)*g*hl*s0 ;
./boundary.cpp:628:					Arrptr->RSHV[p0]=C(0.0);
./boundary.cpp:631:					s0=-(Arrptr->DEM[p1]-Arrptr->DEM[p0])/dl;
./boundary.cpp:632:					Arrptr->LSHU[p0]=C(0.5)*g*hr*s0 ;
./boundary.cpp:633:					Arrptr->LSHV[p0]=C(0.0);
./boundary.cpp:645:				//if (hr*fctm+Arrptr->DEM[p1] > Arrptr->DEM[p0]  && (hur/hr-pow(g*hr,C(0.5))) <= C(0.) ){	/* overtopping */
./boundary.cpp:650:					Arrptr->FHx[pq0]=hur ;
./boundary.cpp:651:					Arrptr->FHUx[pq0]=hur*hur/hr ;
./boundary.cpp:652:					Arrptr->FHVx[pq0]=hvr*hur/hr ;
./boundary.cpp:654:					Arrptr->H[p0]=dtol;
./boundary.cpp:658:						Arrptr->RSHU[p0]=g*hr*wsurface ;
./boundary.cpp:659:						Arrptr->RSHV[p0]=C(0.0);
./boundary.cpp:662:						Arrptr->LSHU[p0]=g*hr*wsurface ;
./boundary.cpp:663:						Arrptr->LSHV[p0]=C(0.0);
./boundary.cpp:670:						// WDC modifies Arrptr->FHx[pq0]=0 ;
./boundary.cpp:673:							Arrptr->FHUx[pq0]=hur*hur/hr ;  // remind (-) sign while upgrade
./boundary.cpp:674:							Arrptr->FHVx[pq0]=C(0.) ;
./boundary.cpp:678:							Arrptr->FHUx[pq0]=C(0.) ;
./boundary.cpp:679:							Arrptr->FHVx[pq0]=C(0.) ;
./boundary.cpp:689:								Arrptr->FHx[pq0]=C(0.5)*(cbarra*(z0-z1)-hr*(fabs(ubarra)+cbarra));
./boundary.cpp:692:								Arrptr->FHx[pq0]=0 ;
./boundary.cpp:704:							//s0=-(Arrptr->DEM[p1+1]-Arrptr->DEM[p1])/dl;
./boundary.cpp:705:							//Arrptr->RSHU[p0]=C(0.0) ;
./boundary.cpp:706:							//if (s0 >= 0) Arrptr->LSHU[p1]=C(0.0);
./boundary.cpp:707:							//else if (Arrptr->H[p1+1] < dtol) Arrptr->LSHU[p1]=C(0.0);
./boundary.cpp:708:							//else Arrptr->LSHU[p1]=C(0.5)*g*hr*s0;
./boundary.cpp:710:							Arrptr->RSHV[p0]=C(0.0) ;
./boundary.cpp:711:							//Arrptr->LSHV[p1]=C(0.0) ;
./boundary.cpp:713:							//Arrptr->LSHU[p1]=C(0.0) ;
./boundary.cpp:714:							//Arrptr->LSHV[p1]=C(0.0) ;
./boundary.cpp:715:							Arrptr->RSHU[p0]=C(0.0) ;//GUSTAVO
./boundary.cpp:716:							//Arrptr->LSHU[p1]=C(0.0) ;//GUSTAVO
./boundary.cpp:738:							Arrptr->FHx[pq0]=C(0.5)*(f1rp+f1lp-a1m*alfa1*e11-a2m*alfa2*e21-a3m*alfa3*e31) ;
./boundary.cpp:739:							Arrptr->FHUx[pq0]=C(0.5)*(f2rp+f2lp-a1m*alfa1*e12-a2m*alfa2*e22-a3m*alfa3*e32) ;
./boundary.cpp:740:							Arrptr->FHVx[pq0]=C(0.5)*(f3rp+f3lp-a1m*alfa1*e13-a2m*alfa2*e23-a3m*alfa3*e33) ;
./boundary.cpp:747:							Arrptr->FHUx[pq0]=hur*(hur/hr-pow(g*hr,C(0.5)))+C(0.5)*g*hr*hr ;  // remind (-) sign while upgrade
./boundary.cpp:748:							Arrptr->FHVx[pq0]=C(0.) ;
./boundary.cpp:749:							Arrptr->FHx[pq0]=C(0.);//GUSTAVO
./boundary.cpp:751:							Arrptr->RSHV[p0]=C(0.0) ;//GUSTAVO
./boundary.cpp:752:							//Arrptr->LSHV[p1]=C(0.0) ;//GUSTAVO
./boundary.cpp:753:							Arrptr->RSHU[p0]=C(0.0) ;//GUSTAVO
./boundary.cpp:754:							//Arrptr->LSHU[p1]=C(0.0) ;//GUSTAVO
./boundary.cpp:758:						//	Arrptr->FHUx[pq0]=C(0.) ;
./boundary.cpp:759:						//	Arrptr->FHVx[pq0]=C(0.) ;
./boundary.cpp:774:					Arrptr->FHx[pq0]=hul ;
./boundary.cpp:775:					Arrptr->FHUx[pq0]=hul*hul/hl ;
./boundary.cpp:776:					Arrptr->FHVx[pq0]=hvl*hul/hl ;
./boundary.cpp:778:					Arrptr->H[p0]=dtol;
./boundary.cpp:782:						Arrptr->RSHU[p0]=g*hl*wsurface ;
./boundary.cpp:783:						Arrptr->RSHV[p0]=C(0.0) ;
./boundary.cpp:786:						Arrptr->LSHU[p0]=g*hr*wsurface ;
./boundary.cpp:787:						Arrptr->LSHV[p0]=C(0.0);
./boundary.cpp:798:						// WDC modifies Arrptr->FHx[pq0]=0 ;
./boundary.cpp:805:					//Arrptr->RSHU[p0]=C(0.0) ;
./boundary.cpp:806:					//if (Arrptr->LSHU[p0] > 0) Arrptr->RSHU[p0];
./boundary.cpp:807:					//else Arrptr->RSHU[p0]= -Arrptr->LSHU[p0] ;
./boundary.cpp:809:					//s0=-(Arrptr->DEM[p1+1]-Arrptr->DEM[p1])/dl;
./boundary.cpp:810:					//if (Arrptr->LSHU[p0] <= 0) Arrptr->RSHU[p0] = C(0.0);
./boundary.cpp:811:					//else if (Arrptr->H[p0-1] < dtol) Arrptr->RSHU[p0] = C(0.0); // if other side is also dry assume zero
./boundary.cpp:812:					//else Arrptr->RSHU[p0]=Arrptr->LSHU[p0] ;
./boundary.cpp:813:					//Arrptr->LSHU[p1]=C(0.0) ; //C(0.5)*g*hr*s0;
./boundary.cpp:815:					Arrptr->RSHV[p0]=C(0.0) ;
./boundary.cpp:816:					//Arrptr->LSHV[p1]=C(0.0) ;
./boundary.cpp:818:					//Arrptr->RSHU[p0]=C(0.0) ;
./boundary.cpp:819:					//Arrptr->RSHV[p0]=C(0.0) ;
./boundary.cpp:820:					Arrptr->RSHU[p0]=C(0.0) ;//GUSTAVO
./boundary.cpp:821:					//Arrptr->LSHU[p1]=C(0.0) ;//GUSTAVO
./boundary.cpp:843:					Arrptr->FHx[pq0]=C(0.5)*(f1rp+f1lp-a1m*alfa1*e11-a2m*alfa2*e21-a3m*alfa3*e31) ;
./boundary.cpp:844:					Arrptr->FHUx[pq0]=C(0.5)*(f2rp+f2lp-a1m*alfa1*e12-a2m*alfa2*e22-a3m*alfa3*e32) ;
./boundary.cpp:845:					Arrptr->FHVx[pq0]=C(0.5)*(f3rp+f3lp-a1m*alfa1*e13-a2m*alfa2*e23-a3m*alfa3*e33) ;
./boundary.cpp:851:						// WDC modifies Arrptr->FHx[pq0]=0 ;
./boundary.cpp:855:							Arrptr->FHUx[pq0]=hul*(hul/hl+pow(g*hl,C(0.5)))+C(0.5)*g*hl*hl;
./boundary.cpp:856:							Arrptr->FHVx[pq0]=C(0.);
./boundary.cpp:858:							Arrptr->FHx[pq0]=C(0.);//GUSTAVO
./boundary.cpp:860:							Arrptr->RSHV[p0]=C(0.0) ;//GUSTAVO
./boundary.cpp:861:							//Arrptr->LSHV[p1]=C(0.0) ;//GUSTAVO
./boundary.cpp:862:							Arrptr->RSHU[p0]=C(0.0) ;//GUSTAVO
./boundary.cpp:863:							//Arrptr->LSHU[p1]=C(0.0) ;//GUSTAVO
./boundary.cpp:867:						//	Arrptr->FHUx[pq0]=C(0.);
./boundary.cpp:868:						//	Arrptr->FHVx[pq0]=C(0.);
./boundary.cpp:875:							Arrptr->FHUx[pq0]=hul*hul/hl;
./boundary.cpp:876:							Arrptr->FHVx[pq0]=C(0.);
./boundary.cpp:880:							Arrptr->FHUx[pq0]=C(0.);
./boundary.cpp:881:							Arrptr->FHVx[pq0]=C(0.);
./boundary.cpp:887:						Arrptr->RSHU[p0]=0 ;
./boundary.cpp:888:						Arrptr->RSHV[p0]=0 ;
./boundary.cpp:902:								Arrptr->FHx[pq0]=C(-0.5)*(cbarra*(z1-z0)-hl*(fabs(ubarra)+cbarra));
./boundary.cpp:905:								Arrptr->FHx[pq0]=C(0.);
./boundary.cpp:912:						// 2nd Add all betas to Arrptr->RSHU[p0], Arrptr->RSHV[p0];
./boundary.cpp:921:  Q=Arrptr->FHx[pq0]*dl ; // origional version included addition *dl but removed for compatability with UpdateH JCN
./boundary.cpp:932:	    Arrptr->Vx[pq0]=Arrptr->FHx[pq0]/hflow;
./boundary.cpp:934:	    Arrptr->maxVx[pq0]=getmax(Arrptr->maxVx[pq0],fabs(Arrptr->Vx[pq0]));
./boundary.cpp:936:	  else Arrptr->Vx[pq0]=C(0.0);
./boundary.cpp:1035:				Arrptr->FHy[pq0]=C(0.5)*(g1rp+g1lp-a1m*alfa1*e11-a2m*alfa2*e21-a3m*alfa3*e31) ;
./boundary.cpp:1036:				Arrptr->FHUy[pq0]=C(0.5)*(g2rp+g2lp-a1m*alfa1*e12-a2m*alfa2*e22-a3m*alfa3*e32) ;
./boundary.cpp:1037:				Arrptr->FHVy[pq0]=C(0.5)*(g3rp+g3lp-a1m*alfa1*e13-a2m*alfa2*e23-a3m*alfa3*e33) ;
./boundary.cpp:1039:				//printf("**** FHVy %" NUM_FMT" ****\n",Arrptr->FHVy[pq0]);
./boundary.cpp:1042:				//Arrptr->BSHU[p0]=C(0.) ;
./boundary.cpp:1043:				//Arrptr->TSHU[p1]=C(0.) ;
./boundary.cpp:1044:				//Arrptr->BSHV[p0]=C(0.5)*g*hl*s0 ;
./boundary.cpp:1045:				//Arrptr->TSHV[p1]=C(0.5)*g*hr*s0 ;
./boundary.cpp:1049:					s0=-(Arrptr->DEM[p1]-Arrptr->DEM[p0])/Parptr->dx;//extrapolating slope
./boundary.cpp:1050:					Arrptr->TSHV[p0]=C(0.5)*g*hr*s0 ;// GUS temporary
./boundary.cpp:1053:					s0=(Arrptr->DEM[p1]-Arrptr->DEM[p0])/Parptr->dx;//extrapolating slope
./boundary.cpp:1054:					Arrptr->BSHV[p0]=C(0.5)*g*hl*s0 ;// GUS temporary
./boundary.cpp:1067:					Arrptr->FHy[pq0]=hvr ;
./boundary.cpp:1068:					Arrptr->FHUy[pq0]=hvr*hur/hr ;
./boundary.cpp:1069:					Arrptr->FHVy[pq0]=hvr*hvr/hr ;
./boundary.cpp:1071:					Arrptr->H[p0]=dtol;
./boundary.cpp:1074:						Arrptr->TSHV[p0]=g*hr*wsurface ;
./boundary.cpp:1075:						Arrptr->TSHU[p0]=C(0.) ;
./boundary.cpp:1078:						Arrptr->BSHV[p0]=g*hr*wsurface ;
./boundary.cpp:1079:						Arrptr->BSHU[p0]=C(0.) ;
./boundary.cpp:1089:						//Arrptr->FHy[pq0]=0 ;
./boundary.cpp:1096:					//s0=-(Arrptr->DEM[p1]-Arrptr->DEM[p1+Parptr->xsz])/dl; //work out slope on other side
./boundary.cpp:1097:					//if (s0 < 0) Arrptr->TSHV[p1]=C(0.0); // if away from boundary use zero
./boundary.cpp:1098:					//else Arrptr->TSHV[p1]=C(-0.5)*g*hr*s0 ; // if towrads boundary balance woth ghost cell
./boundary.cpp:1099:					//s0=-(Arrptr->DEM[p1+Parptr->xsz]-Arrptr->DEM[p1])/dl;
./boundary.cpp:1101:					Arrptr->BSHU[p0]=C(0.0) ;
./boundary.cpp:1102:					//Arrptr->TSHU[p1]=C(0.0) ;
./boundary.cpp:1104:					Arrptr->BSHV[p0]=C(0.0) ;
./boundary.cpp:1105:					//if (s0 >= 0) Arrptr->TSHV[p1]=C(0.0);
./boundary.cpp:1106:					//else if (Arrptr->H[p1+Parptr->xsz] < dtol) Arrptr->TSHV[p1]=C(0.0);
./boundary.cpp:1107:					//else Arrptr->TSHV[p1]=C(0.5)*g*hr*s0 ;
./boundary.cpp:1109:					//Arrptr->TSHU[p1]=C(0.0) ;
./boundary.cpp:1110:					//Arrptr->TSHV[p1]=C(0.0) ;
./boundary.cpp:1131:					Arrptr->FHy[pq0]=C(0.5)*(g1rp+g1lp-a1m*alfa1*e11-a2m*alfa2*e21-a3m*alfa3*e31) ;
./boundary.cpp:1132:					Arrptr->FHUy[pq0]=C(0.5)*(g2rp+g2lp-a1m*alfa1*e12-a2m*alfa2*e22-a3m*alfa3*e32) ;
./boundary.cpp:1133:					Arrptr->FHVy[pq0]=C(0.5)*(g3rp+g3lp-a1m*alfa1*e13-a2m*alfa2*e23-a3m*alfa3*e33) ;
./boundary.cpp:1139:						//Arrptr->FHy[pq0]=0 ;
./boundary.cpp:1143:							Arrptr->FHUy[pq0]=C(0.);
./boundary.cpp:1144:							Arrptr->FHVy[pq0]=hvr*(hvr/hr-pow(g*hr,C(0.5)))+C(0.5)*g*hr*hr; // remind (-) sign while upgrade
./boundary.cpp:1145:							Arrptr->FHy[pq0]=C(0.);//GUS
./boundary.cpp:1147:							Arrptr->BSHU[p0]=C(0.0) ;//GUS
./boundary.cpp:1148:							Arrptr->BSHV[p0]=C(0.0) ;//GUS
./boundary.cpp:1149:							//Arrptr->TSHU[p1]=C(0.0) ;//GUS
./boundary.cpp:1150:							//Arrptr->TSHV[p1]=C(0.0) ;//GUS
./boundary.cpp:1170:						Arrptr->FHy[pq0]=(g*dt*hflow*wsurface);
./boundary.cpp:1171:						Arrptr->FHUy[pq0]=Arrptr->FHy[pq0]*hul/hl ;
./boundary.cpp:1172:						Arrptr->FHVy[pq0]=Arrptr->FHy[pq0]*Arrptr->FHy[pq0]/hl ;
./boundary.cpp:1173:						Arrptr->H[p0]=dtol;// why???
./boundary.cpp:1177:						Arrptr->FHy[pq0]=hvl ;
./boundary.cpp:1178:						Arrptr->FHUy[pq0]=hvl*hul/hl ;
./boundary.cpp:1179:						Arrptr->FHVy[pq0]=hvl*hvl/hl ;
./boundary.cpp:1181:						Arrptr->H[p0]=dtol;
./boundary.cpp:1185:						Arrptr->TSHV[p0]=g*hl*wsurface ;
./boundary.cpp:1186:						Arrptr->TSHU[p0]=C(0.0) ;
./boundary.cpp:1189:						Arrptr->BSHV[p0]=g*hl*wsurface ;
./boundary.cpp:1190:						Arrptr->BSHU[p0]=g*hl*wsurface ;
./boundary.cpp:1208:					//Arrptr->BSHU[p0]=C(0.0);
./boundary.cpp:1209:					//if (Arrptr->TSHV[p0] > 0) Arrptr->BSHV[p0] = C(0.0);
./boundary.cpp:1210:					//else Arrptr->BSHV[p0]= -Arrptr->TSHV[p0];
./boundary.cpp:1212:					//s0=-(Arrptr->DEM[p1+Arrptr->xsz]-Arrptr->DEM[p1])/dl;
./boundary.cpp:1214:					//Arrptr->BSHU[p0]=C(0.0) ;
./boundary.cpp:1215:					//Arrptr->TSHU[p1]=C(0.0) ;
./boundary.cpp:1217:					//if (Arrptr->TSHV[p0] <= 0) Arrptr->BSHV[p0]=C(0.0);
./boundary.cpp:1218:					//else Arrptr->BSHV[p0]=Arrptr->TSHV[p0] ;
./boundary.cpp:1219:					//Arrptr->TSHV[p1]=C(0.0);
./boundary.cpp:1221:					Arrptr->BSHU[p0]=C(0.0);
./boundary.cpp:1222:					Arrptr->BSHV[p0]=C(0.0);
./boundary.cpp:1243:					Arrptr->FHy[pq0]=C(0.5)*(g1rp+g1lp-a1m*alfa1*e11-a2m*alfa2*e21-a3m*alfa3*e31) ;
./boundary.cpp:1244:					Arrptr->FHUy[pq0]=C(0.5)*(g2rp+g2lp-a1m*alfa1*e12-a2m*alfa2*e22-a3m*alfa3*e32) ;
./boundary.cpp:1245:					Arrptr->FHVy[pq0]=C(0.5)*(g3rp+g3lp-a1m*alfa1*e13-a2m*alfa2*e23-a3m*alfa3*e33) ;
./boundary.cpp:1253:						//Arrptr->FHy[pq0]=0 ;
./boundary.cpp:1257:							Arrptr->FHUy[pq0]=C(0.);
./boundary.cpp:1258:							Arrptr->FHVy[pq0]=hvl*(hvl/hl+pow(g*hl,C(0.5)))+C(0.5)*g*hl*hl;
./boundary.cpp:1259:							Arrptr->FHy[pq0]=C(0.);//GUS
./boundary.cpp:1261:							//Arrptr->TSHU[p1]=C(0.0) ;//GUS
./boundary.cpp:1262:							//Arrptr->TSHV[p1]=C(0.0);//GUS
./boundary.cpp:1263:							Arrptr->BSHU[p0]=C(0.0);//GUS
./boundary.cpp:1264:							Arrptr->BSHV[p0]=C(0.0);//GUS
./boundary.cpp:1275:  Q=Arrptr->FHy[pq0]*dl  ;	// origional version included addition *dl but removed for compatability with UpdateH JCN
./boundary.cpp:1285:	    Arrptr->Vy[pq0]=Arrptr->FHy[pq0]/hflow;
./boundary.cpp:1287:	    Arrptr->maxVy[pq0]=getmax(Arrptr->maxVy[pq0],fabs(Arrptr->Vy[pq0]));
./boundary.cpp:1289:	  else Arrptr->Vy[pq0]=C(0.0);
./boundary.cpp:1314:		  for(i=0;i<Parptr->xsz;i++) if(Arrptr->ChanMask[i]==-1)
./boundary.cpp:1316:    if(Arrptr->Qy[i]>0) qina+=Arrptr->Qy[i];
./boundary.cpp:1317:    else qouta-=Arrptr->Qy[i];
./boundary.cpp:1322:  for(i=0;i<Parptr->xsz;i++) if(Arrptr->ChanMask[i+(Parptr->ysz-1)*Parptr->xsz]==-1)
./boundary.cpp:1324:    if(Arrptr->Qy[i+Parptr->ysz*(Parptr->xsz+1)]>0) qoutb+=Arrptr->Qy[i+Parptr->ysz*(Parptr->xsz+1)];
./boundary.cpp:1325:    else qinb-=Arrptr->Qy[i+Parptr->ysz*(Parptr->xsz+1)];
./boundary.cpp:1332:  for(i=0;i<Parptr->ysz;i++) if(Arrptr->ChanMask[i*Parptr->xsz]==-1) 
./boundary.cpp:1334:    if(Arrptr->Qx[i*(Parptr->xsz+1)]>0) qinc+=Arrptr->Qx[i*(Parptr->xsz+1)];
./boundary.cpp:1335:    else qoutc-=Arrptr->Qx[i*(Parptr->xsz+1)];
./boundary.cpp:1341:  for(i=0;i<Parptr->ysz;i++) if(Arrptr->ChanMask[Parptr->xsz-1+i*Parptr->xsz]==-1)
./boundary.cpp:1343:    if(Arrptr->Qx[Parptr->xsz+i*(Parptr->xsz+1)]>0) qoutd+=Arrptr->Qx[Parptr->xsz+i*(Parptr->xsz+1)];
./boundary.cpp:1344:    else qind-=Arrptr->Qx[Parptr->xsz+i*(Parptr->xsz+1)];
./boundary.cpp:1463:			NUMERIC_TYPE Z = Arrptr->DEM[j*Parptr->xsz + i];
./boundary.cpp:1467:			    NUMERIC_TYPE& H = Arrptr->H[j*Parptr->xsz + i];
./fp_flow.cpp:33:    hptr0=Arrptr->H+j*Parptr->xsz;
./fp_flow.cpp:34:    qptr=Arrptr->Qx+j*(Parptr->xsz+1)+1;
./fp_flow.cpp:35:    wiptr=Arrptr->Weir_Identx+j*(Parptr->xsz+1)+1;
./fp_flow.cpp:74:    hptr0=Arrptr->H+j*Parptr->xsz;
./fp_flow.cpp:75:    hptr1=Arrptr->H+(j+1)*Parptr->xsz;
./fp_flow.cpp:76:    qptr=Arrptr->Qy+(j+1)*(Parptr->xsz+1);
./fp_flow.cpp:77:    wiptr=Arrptr->Weir_Identy+(j+1)*(Parptr->xsz+1);
./fp_flow.cpp:125:  z0=Arrptr->DEM[p0];
./fp_flow.cpp:126:  z1=Arrptr->DEM[p1];
./fp_flow.cpp:127:  h0=Arrptr->H[p0];
./fp_flow.cpp:128:  h1=Arrptr->H[p1];
./fp_flow.cpp:130:  if(Arrptr->Manningsn!=NULL) fn=C(0.5)*(Arrptr->Manningsn[p0]+Arrptr->Manningsn[p1]);
./fp_flow.cpp:141:	//Arrptr->Hflowx[pTQ] = hflow;
./fp_flow.cpp:143:    if(MaskTest(Arrptr->ChanMask[p0],Arrptr->ChanMask[p1]) && hflow>Solverptr->DepthThresh) {
./fp_flow.cpp:156:        Arrptr->TRecx[pTQ]=*TSptr;
./fp_flow.cpp:167:          Arrptr->LimQx[pTQ]=Q;
./fp_flow.cpp:181:	//Arrptr->Hflowx[pTQ] = hflow;
./fp_flow.cpp:183:    if(MaskTest(Arrptr->ChanMask[p0],Arrptr->ChanMask[p1]) && hflow>Solverptr->DepthThresh) 
./fp_flow.cpp:197:        Arrptr->TRecx[pTQ]=*TSptr;
./fp_flow.cpp:208:          Arrptr->LimQx[pTQ]=Q;
./fp_flow.cpp:221:	    Arrptr->Vx[pTQ]=Q/Parptr->dx/hflow;
./fp_flow.cpp:222:	    Arrptr->maxVx[pTQ]=getmax(Arrptr->maxVx[pTQ],fabs(Arrptr->Vx[pTQ]));
./fp_flow.cpp:224:	  else Arrptr->Vx[pTQ]=C(0.0);
./fp_flow.cpp:239:  z0=Arrptr->DEM[p0];
./fp_flow.cpp:240:  z1=Arrptr->DEM[p1];
./fp_flow.cpp:241:  h0=Arrptr->H[p0];
./fp_flow.cpp:242:  h1=Arrptr->H[p1];
./fp_flow.cpp:244:  if(Arrptr->Manningsn!=NULL) fn=C(0.5)*(Arrptr->Manningsn[p0]+Arrptr->Manningsn[p1]);
./fp_flow.cpp:256:	//Arrptr->Hflowy[pTQ] = hflow;
./fp_flow.cpp:258:    if(MaskTest(Arrptr->ChanMask[p0],Arrptr->ChanMask[p1]) && hflow>Solverptr->DepthThresh) 
./fp_flow.cpp:272:        Arrptr->TRecy[pTQ]=*TSptr;
./fp_flow.cpp:283:          Arrptr->LimQy[pTQ]=Q;
./fp_flow.cpp:298:	// Arrptr->Hflowy[pTQ] = hflow;
./fp_flow.cpp:300:    if(MaskTest(Arrptr->ChanMask[p0],Arrptr->ChanMask[p1]) && hflow>Solverptr->DepthThresh) 
./fp_flow.cpp:314:        Arrptr->TRecy[pTQ]=*TSptr;
./fp_flow.cpp:325:          Arrptr->LimQy[pTQ]=Q;
./fp_flow.cpp:337:	    Arrptr->Vy[pTQ]=Q/Parptr->dx/hflow;
./fp_flow.cpp:338:	    Arrptr->maxVy[pTQ]=getmax(Arrptr->maxVy[pTQ],fabs(Arrptr->Vy[pTQ]));
./fp_flow.cpp:340:	  else Arrptr->Vy[pTQ]=C(0.0);
./fp_acc.cpp:33:  z0=Arrptr->DEM[p0];
./fp_acc.cpp:34:  z1=Arrptr->DEM[p1];
./fp_acc.cpp:35:  h0=Arrptr->H[p0];
./fp_acc.cpp:36:  h1=Arrptr->H[p1];
./fp_acc.cpp:37:  q0=Arrptr->Qxold[pq0]; // in m2/s
./fp_acc.cpp:46:	    qy_avg=(Arrptr->Qyold[pqy1]+Arrptr->Qyold[pqy2]+Arrptr->Qyold[pqy3]+Arrptr->Qyold[pqy4])/4;
./fp_acc.cpp:54:  if(Arrptr->Manningsn!=NULL) fn=C(0.5)*(Arrptr->Manningsn[p0]+Arrptr->Manningsn[p1]);
./fp_acc.cpp:66:	//Arrptr->Hflowx[pq0] = hflow;
./fp_acc.cpp:68:    qup=Arrptr->Qxold[pq0-1];
./fp_acc.cpp:69:    qdown=Arrptr->Qxold[pq0+1];
./fp_acc.cpp:71:    if(MaskTest(Arrptr->ChanMask[p0],Arrptr->ChanMask[p1]) && hflow>Solverptr->DepthThresh)
./fp_acc.cpp:93:	    Arrptr->Vx[pq0]=Q/Parptr->dx/hflow;
./fp_acc.cpp:94:	    Arrptr->maxVx[pq0]=getmax(Arrptr->maxVx[pq0],fabs(Arrptr->Vx[pq0]));
./fp_acc.cpp:96:	  else Arrptr->Vx[pq0]=C(0.0);
./fp_acc.cpp:116:  z0=Arrptr->DEM[p0];
./fp_acc.cpp:117:  z1=Arrptr->DEM[p1];
./fp_acc.cpp:118:  h0=Arrptr->H[p0];
./fp_acc.cpp:119:  h1=Arrptr->H[p1];
./fp_acc.cpp:120:  q0=Arrptr->Qyold[pq0]; // in m2/s
./fp_acc.cpp:129:	  qx_avg=(Arrptr->Qxold[pqx1]+Arrptr->Qxold[pqx2]+Arrptr->Qxold[pqx3]+Arrptr->Qxold[pqx4])/4;
./fp_acc.cpp:137:  if(Arrptr->Manningsn!=NULL) fn=C(0.5)*(Arrptr->Manningsn[p0]+Arrptr->Manningsn[p1]);
./fp_acc.cpp:148:	//Arrptr->Hflowy[pq0] = hflow;
./fp_acc.cpp:150:    qup=Arrptr->Qyold[i+(j)*(Parptr->xsz+1)];
./fp_acc.cpp:151:    qdown=Arrptr->Qyold[i+(j+2)*(Parptr->xsz+1)];
./fp_acc.cpp:153:    if(MaskTest(Arrptr->ChanMask[p0],Arrptr->ChanMask[p1]) && hflow>Solverptr->DepthThresh) 
./fp_acc.cpp:175:	    Arrptr->Vy[pq0]=Q/Parptr->dx/hflow;
./fp_acc.cpp:176:	    Arrptr->maxVy[pq0]=getmax(Arrptr->maxVy[pq0],fabs(Arrptr->Vy[pq0]));
./fp_acc.cpp:178:	  else Arrptr->Vy[pq0]=C(0.0);
./fp_acc.cpp:197:			h0=Arrptr->H[p0];
./fp_acc.cpp:198:			if(MaskTestAcc(Arrptr->ChanMask[p0])) 
./fp_acc.cpp:235:			locH=Arrptr->H[p0];
./fp_acc.cpp:236:			locV=Arrptr->Qyold[pqx]/Parptr->dx;
./fp_acc.cpp:237:			locU=Arrptr->Qxold[pqy]/Parptr->dx;
./fp_acc.cpp:283:		  Arrptr->Qxold[pqptr]=Arrptr->Qx[pqptr]*dxinv;
./fp_acc.cpp:295:		  Arrptr->Qyold[pqptr]=Arrptr->Qy[pqptr]*dxinv;
./preprocess/createDamBreakObstacle.cpp:52:	Arrptr->DEM = memory_allocate_zero_numeric_legacy(pars.xsz * pars.ysz);
./preprocess/createDamBreakObstacle.cpp:53:	Arrptr->H = memory_allocate_zero_numeric_legacy(pars.xsz * pars.ysz);
./preprocess/createDamBreakObstacle.cpp:56:	dg2::initialise_field(Z, Parptr, Arrptr->DEM, Arrptr->DEM1x, Arrptr->DEM1y);
./preprocess/createDamBreakObstacle.cpp:57:	dg2::initialise_field(H, Parptr, Arrptr->H, Arrptr->H1x, Arrptr->H1y);
./preprocess/createRadialDamBreak.cpp:30:	Arrptr->DEM = memory_allocate_zero_numeric_legacy(pars.xsz * pars.ysz);
./preprocess/createRadialDamBreak.cpp:31:	Arrptr->H = memory_allocate_zero_numeric_legacy(pars.xsz * pars.ysz);
./preprocess/createRadialDamBreak.cpp:36:	dg2::initialise_field(Z, Parptr, Arrptr->DEM, Arrptr->DEM1x, Arrptr->DEM1y);
./preprocess/createRadialDamBreak.cpp:37:	dg2::initialise_field(H, Parptr, Arrptr->H, Arrptr->H1x, Arrptr->H1y);
./preprocess/createLakeAtRestCones.cpp:33:	Arrptr->DEM = memory_allocate_zero_numeric_legacy(pars.xsz * pars.ysz);
./preprocess/createLakeAtRestCones.cpp:34:	Arrptr->H = memory_allocate_zero_numeric_legacy(pars.xsz * pars.ysz);
./preprocess/createLakeAtRestCones.cpp:37:	dg2::initialise_field(Z, Parptr, Arrptr->DEM, Arrptr->DEM1x, Arrptr->DEM1y);
./preprocess/generateDG2DEM.cpp:67:	Arrptr->DEM = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./preprocess/generateDG2DEM.cpp:73:			Arrptr->DEM, Arrptr->DEM1x, Arrptr->DEM1y);
./preprocess/generateDG2DEM.cpp:77:	memory_free_legacy(&Arrptr->DEM);
./preprocess/createHump.cpp:31:	Arrptr->DEM = memory_allocate_zero_numeric_legacy(pars.xsz * pars.ysz);
./preprocess/createHump.cpp:32:	Arrptr->H = memory_allocate_zero_numeric_legacy(pars.xsz * pars.ysz);
./preprocess/createHump.cpp:35:	dg2::initialise_field(Z, Parptr, Arrptr->DEM, Arrptr->DEM1x, Arrptr->DEM1y);
./preprocess/createLakeAtRestBlocks.cpp:45:	Arrptr->DEM = memory_allocate_zero_numeric_legacy(pars.xsz * pars.ysz);
./preprocess/createLakeAtRestBlocks.cpp:46:	Arrptr->H = memory_allocate_zero_numeric_legacy(pars.xsz * pars.ysz);
./preprocess/createLakeAtRestBlocks.cpp:49:	dg2::initialise_field(Z, Parptr, Arrptr->DEM, Arrptr->DEM1x, Arrptr->DEM1y);
./input.cpp:137:	Arrptr->weir_count = nw;
./input.cpp:139:	Arrptr->Weir_hc = memory_allocate_numeric_legacy(nw);
./input.cpp:140:	Arrptr->Weir_Cd = memory_allocate_numeric_legacy(nw);
./input.cpp:141:	Arrptr->Weir_m = memory_allocate_numeric_legacy(nw);
./input.cpp:142:	Arrptr->Weir_w = memory_allocate_numeric_legacy(nw);
./input.cpp:143:	Arrptr->Weir_Typ = new EWeirType[nw]; // type of structure... weir = 0, bridge = 1;
./input.cpp:145:	Arrptr->Weir_Fixdir = new EDirection[nw];   // Fixed flow directions
./input.cpp:146:	Arrptr->Weir_Identx = new int[(Parptr->xsz + 1)*(Parptr->ysz + 1)];
./input.cpp:147:	Arrptr->Weir_Identy = new int[(Parptr->xsz + 1)*(Parptr->ysz + 1)];
./input.cpp:150:	SetArrayValue(Arrptr->Weir_Identx, -1, (Parptr->xsz + 1) * (Parptr->ysz + 1));
./input.cpp:151:	SetArrayValue(Arrptr->Weir_Identy, -1, (Parptr->xsz + 1) * (Parptr->ysz + 1));
./input.cpp:162:			&x, &y, Arrptr->Weir_Cd + i, Arrptr->Weir_hc + i, Arrptr->Weir_m + i, Arrptr->Weir_w + i) != 7)
./input.cpp:163:			Arrptr->Weir_w[i] = Parptr->dx;
./input.cpp:177:			Arrptr->Weir_Identx[xi + 1 + yi*(Parptr->xsz + 1)] = i;
./input.cpp:178:			Arrptr->Weir_Fixdir[i] = DirectionNA;
./input.cpp:179:			Arrptr->Weir_Typ[i] = EWeir_Weir;
./input.cpp:183:			Arrptr->Weir_Identx[xi + yi*(Parptr->xsz + 1)] = i;
./input.cpp:184:			Arrptr->Weir_Fixdir[i] = DirectionNA;
./input.cpp:185:			Arrptr->Weir_Typ[i] = EWeir_Weir;
./input.cpp:189:			Arrptr->Weir_Identy[xi + yi*(Parptr->xsz + 1)] = i;
./input.cpp:190:			Arrptr->Weir_Fixdir[i] = DirectionNA;
./input.cpp:191:			Arrptr->Weir_Typ[i] = EWeir_Weir;
./input.cpp:195:			Arrptr->Weir_Identy[xi + (yi + 1)*(Parptr->xsz + 1)] = i;
./input.cpp:196:			Arrptr->Weir_Fixdir[i] = DirectionNA;
./input.cpp:197:			Arrptr->Weir_Typ[i] = EWeir_Weir;
./input.cpp:203:			Arrptr->Weir_Identx[xi + 1 + yi*(Parptr->xsz + 1)] = i;
./input.cpp:204:			Arrptr->Weir_Fixdir[i] = West;
./input.cpp:205:			Arrptr->Weir_Typ[i] = EWeir_Weir;
./input.cpp:209:			Arrptr->Weir_Identx[xi + yi*(Parptr->xsz + 1)] = i;
./input.cpp:210:			Arrptr->Weir_Fixdir[i] = East;
./input.cpp:211:			Arrptr->Weir_Typ[i] = EWeir_Weir;
./input.cpp:215:			Arrptr->Weir_Identy[xi + yi*(Parptr->xsz + 1)] = i;
./input.cpp:216:			Arrptr->Weir_Fixdir[i] = South;
./input.cpp:217:			Arrptr->Weir_Typ[i] = EWeir_Weir;
./input.cpp:221:			Arrptr->Weir_Identy[xi + (yi + 1)*(Parptr->xsz + 1)] = i;
./input.cpp:222:			Arrptr->Weir_Fixdir[i] = North;
./input.cpp:223:			Arrptr->Weir_Typ[i] = EWeir_Weir;
./input.cpp:228:			Arrptr->Weir_Identx[xi + 1 + yi*(Parptr->xsz + 1)] = i;
./input.cpp:229:			Arrptr->Weir_Fixdir[i] = DirectionNA;
./input.cpp:230:			Arrptr->Weir_Typ[i] = EWeir_Bridge;
./input.cpp:234:			Arrptr->Weir_Identx[xi + yi*(Parptr->xsz + 1)] = i;
./input.cpp:235:			Arrptr->Weir_Fixdir[i] = DirectionNA;
./input.cpp:236:			Arrptr->Weir_Typ[i] = EWeir_Bridge;
./input.cpp:240:			Arrptr->Weir_Identy[xi + yi*(Parptr->xsz + 1)] = i;
./input.cpp:241:			Arrptr->Weir_Fixdir[i] = DirectionNA;
./input.cpp:242:			Arrptr->Weir_Typ[i] = EWeir_Bridge;
./input.cpp:246:			Arrptr->Weir_Identy[xi + (yi + 1)*(Parptr->xsz + 1)] = i;
./input.cpp:247:			Arrptr->Weir_Fixdir[i] = DirectionNA;
./input.cpp:248:			Arrptr->Weir_Typ[i] = EWeir_Bridge;
./input.cpp:251:		// now a check to make sure that Arrptr->Weir_hc is greater than the ground elevation,
./input.cpp:256:		if (Statesptr->SGC == ON && Arrptr->SGCwidth[p0] > C(0.0)) z0 = Arrptr->SGCz[p0];
./input.cpp:257:		else z0 = Arrptr->DEM[p0];
./input.cpp:275:		if (Statesptr->SGC == ON && Arrptr->SGCwidth[p1] > C(0.0)) z1 = Arrptr->SGCz[p1];
./input.cpp:276:		else z1 = Arrptr->DEM[p1];
./input.cpp:279:		if (Arrptr->Weir_hc[i] < z0 || Arrptr->Weir_hc[i] < z1)
./input.cpp:283:				if (Arrptr->Weir_Typ[i] == EWeir_Weir)
./input.cpp:289:					Arrptr->Weir_hc[i] = getmax(z0, z1);
./input.cpp:290:					if (verbose == ON) printf("Weir number %i crest height increased to %.3" NUM_FMT" m\n", i, Arrptr->Weir_hc[i]);
./input.cpp:296:				//Arrptr->Weir_Typ[i] = 0;
./input.cpp:330:        Arrptr->protection_count = nw;
./input.cpp:331:	Arrptr->Protection_pos = memory_allocate_numeric_legacy(nw);
./input.cpp:333:        Arrptr->Protection_ph = memory_allocate_numeric_legacy(nw);
./input.cpp:334:        Arrptr->Protection_pfh = memory_allocate_numeric_legacy(nw);
./input.cpp:335:	Arrptr->Protection_pf = memory_allocate_numeric_legacy(nw);
./input.cpp:336:	Arrptr->Protection_pbounds = memory_allocate_numeric_legacy(nw*8);
./input.cpp:337:        Arrptr->Protection_PROTEC = memory_allocate_numeric_legacy((Parptr->xsz + 1) * (Parptr->ysz + 1));   
./input.cpp:340:	//Arrptr->Protection_Identx = new int[(Parptr->xsz + 1)*(Parptr->ysz + 1)];
./input.cpp:341:        //Arrptr->Protection_PROTEC = new int[(Parptr->xsz + 1)*(Parptr->ysz + 1)];
./input.cpp:343:        //SetArrayValue(Arrptr->Protection_PROTEC,0 , (Parptr->xsz + 1) * (Parptr->ysz + 1));
./input.cpp:349:			Arrptr->Protection_PROTEC[i + j*Parptr->xsz] = 0;
./input.cpp:355:		Arrptr->Protection_pf[i]=0;
./input.cpp:364:				&x, &y, Arrptr->Protection_ph + i, Arrptr->Protection_pfh + i);	      
./input.cpp:375:		else if (Arrptr->Protection_ph[i]<=0)
./input.cpp:377:			printf("Invalid protection Height: %d (%" NUM_FMT")\n", i,Arrptr->Protection_ph[i]);
./input.cpp:380:		else if (Arrptr->Protection_pfh[i]<=0)
./input.cpp:382:                        printf("Invalid protection Failure Height: %d (%" NUM_FMT")\n", i,Arrptr->Protection_pfh[i]);
./input.cpp:387:		Arrptr->Protection_pos[i]=posi;
./input.cpp:388:		Arrptr->Protection_pbounds[(8*i)]=(int)((xi-1) + (yi-1)*Parptr->xsz);
./input.cpp:389:		Arrptr->Protection_pbounds[(8*i)+1]=(int)((xi) + (yi-1)*Parptr->xsz);
./input.cpp:390:		Arrptr->Protection_pbounds[(8*i)+2]=(int)((xi+1) + (yi-1)*Parptr->xsz);
./input.cpp:391:		Arrptr->Protection_pbounds[(8*i)+3]=(int)((xi-1) + (yi)*Parptr->xsz);
./input.cpp:392:	 	Arrptr->Protection_pbounds[(8*i)+4]=(int)((xi+1) + (yi)*Parptr->xsz);
./input.cpp:393:		Arrptr->Protection_pbounds[(8*i)+5]=(int)((xi-1) + (yi+1)*Parptr->xsz);
./input.cpp:394:		Arrptr->Protection_pbounds[(8*i)+6]=(int)((xi) + (yi+1)*Parptr->xsz);
./input.cpp:395:		Arrptr->Protection_pbounds[(8*i)+7]=(int)((xi+1) + (yi+1)*Parptr->xsz);
./input.cpp:404:                        if(Arrptr->Protection_PROTEC[i + j*Parptr->xsz]>0)
./input.cpp:406:                                Arrptr->DEM[i + j*Parptr->xsz] = Arrptr->DEM[i + j*Parptr->xsz] + Arrptr->Protection_PROTEC[i + j*Parptr->xsz];
./input.cpp:669:						Arrptr->ChanMask[ni + nj*Parptr->xsz] = 1; // mark mask with value of 1 - will renumber later in order
./input.cpp:674:						if (Arrptr->ChanMask[ni + nj*Parptr->xsz] == -1)   // channel mask not set
./input.cpp:678:							Arrptr->ChanMask[ni + nj*Parptr->xsz] = 1; // mark mask with value of 1 - will renumber later in order
./input.cpp:748:			Arrptr->ChanMask[pi + pj*Parptr->xsz] = i;
./input.cpp:750:			csp->BankZ[i] = Arrptr->DEM[pi + pj*Parptr->xsz];
./input.cpp:752:			Arrptr->SegMask[pi + pj*Parptr->xsz] = chseg;
./input.cpp:809:						Arrptr->DEM[pi + pj*Parptr->xsz] = hp[i1] + (hp[i2] - hp[i1])*(csp->Chainage[i] - cp[i1]) / (cp[i2] - cp[i1]);
./input.cpp:826:					grad = (Arrptr->DEM[csp->ChanX[i] + csp->ChanY[i] * Parptr->xsz] - Arrptr->DEM[csp->ChanX[i - 1] + csp->ChanY[i - 1] * Parptr->xsz])
./input.cpp:831:					grad = (Arrptr->DEM[csp->ChanX[i + 1] + csp->ChanY[i + 1] * Parptr->xsz] - Arrptr->DEM[csp->ChanX[i] + csp->ChanY[i] * Parptr->xsz])
./input.cpp:840:					grad = (csp->JunctionDEM - Arrptr->DEM[csp->ChanX[i] + csp->ChanY[i] * Parptr->xsz])
./input.cpp:846:					grad = (csp->JunctionDEM - Arrptr->DEM[csp->ChanX[i - 1] + csp->ChanY[i - 1] * Parptr->xsz])
./input.cpp:851:					grad = (Arrptr->DEM[csp->ChanX[i + 1] + csp->ChanY[i + 1] * Parptr->xsz] - Arrptr->DEM[csp->ChanX[i] + csp->ChanY[i] * Parptr->xsz])
./input.cpp:1008:	Arrptr->dist_infiltration = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1011:		fscanf(fp, "%" NUM_FMT"", Arrptr->dist_infiltration + i + j * Parptr->xsz);
./input.cpp:1012:		if (AreEqual(Arrptr->dist_infiltration[i + j * Parptr->xsz], no_data_value))
./input.cpp:1013:			Arrptr->dist_infiltration[i + j * Parptr->xsz] = 0.0;
./input.cpp:1015:		Arrptr->dist_infiltration[i + j * Parptr->xsz] = Arrptr->dist_infiltration[i + j * Parptr->xsz] / 60 / 60 / 1000;
./input.cpp:1040:	Arrptr->Manningsn = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1043:		fscanf(fp, "%" NUM_FMT"", Arrptr->Manningsn + i + j*Parptr->xsz);
./input.cpp:1044:		if (AreEqual(Arrptr->Manningsn[i + j*Parptr->xsz], no_data_value))
./input.cpp:1045:			Arrptr->Manningsn[i + j*Parptr->xsz] = Parptr->FPn;
./input.cpp:1067:	Arrptr->SGCManningsn = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1070:		fscanf(fp, "%" NUM_FMT"", Arrptr->SGCManningsn + i + j*Parptr->xsz);
./input.cpp:1071:		if (AreEqual(Arrptr->SGCManningsn[i + j*Parptr->xsz], no_data_value))
./input.cpp:1072:			Arrptr->SGCManningsn[i + j*Parptr->xsz] = Parptr->SGC_n;
./input.cpp:1134:		Arrptr->paerial = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1137:			fscanf(fp, "%" NUM_FMT"", Arrptr->paerial + i + j*Parptr->xsz);
./input.cpp:1138:			if (AreEqual(Arrptr->paerial[i + j*Parptr->xsz], no_data_value))
./input.cpp:1139:				Arrptr->paerial[i + j*Parptr->xsz] = 1;
./input.cpp:1151:		Arrptr->paerial = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz*Parptr->zsz);
./input.cpp:1158:				fscanf(fp, "%" NUM_FMT"", Arrptr->paerial + i + j*Parptr->xsz + k*Parptr->xsz*Parptr->ysz);
./input.cpp:1159:				if (AreEqual(Arrptr->paerial[i + j*Parptr->xsz + k*Parptr->xsz*Parptr->ysz], no_data_value))
./input.cpp:1160:					Arrptr->paerial[i + j*Parptr->xsz + k*Parptr->xsz*Parptr->ysz] = 1;
./input.cpp:1172:		Arrptr->paerial = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1173:		Arrptr->pbound = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz * 4);
./input.cpp:1177:			fscanf(fp, "%" NUM_FMT"", Arrptr->paerial + i + j*Parptr->xsz);
./input.cpp:1178:			if (AreEqual(Arrptr->paerial[i + j*Parptr->xsz], no_data_value))
./input.cpp:1179:				Arrptr->paerial[i + j*Parptr->xsz] = 1;
./input.cpp:1188:				fscanf(fp, "%" NUM_FMT"", Arrptr->pbound + i + j*Parptr->xsz + k*Parptr->xsz*Parptr->ysz);
./input.cpp:1189:				if (AreEqual(Arrptr->pbound[i + j*Parptr->xsz + k*Parptr->xsz*Parptr->ysz], no_data_value))
./input.cpp:1190:					Arrptr->pbound[i + j*Parptr->xsz + k*Parptr->xsz*Parptr->ysz] = 1;
./input.cpp:1204:		Arrptr->paerial = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz*Parptr->zsz);
./input.cpp:1205:		Arrptr->pbound = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz*Parptr->zsz * 4);
./input.cpp:1212:				fscanf(fp, "%" NUM_FMT"", Arrptr->paerial + i + j*Parptr->xsz + k*Parptr->xsz*Parptr->ysz);
./input.cpp:1213:				if (AreEqual(Arrptr->paerial[i + j*Parptr->xsz + k*Parptr->xsz*Parptr->ysz], no_data_value))
./input.cpp:1214:					Arrptr->paerial[i + j*Parptr->xsz + k*Parptr->xsz*Parptr->ysz] = 1;
./input.cpp:1225:				fscanf(fp, "%" NUM_FMT"", Arrptr->pbound + i + j*Parptr->xsz + m*Parptr->xsz*Parptr->ysz + k*Parptr->xsz*Parptr->ysz);
./input.cpp:1226:				if (AreEqual(Arrptr->pbound[i + j*Parptr->xsz + m*Parptr->xsz*Parptr->ysz + k*Parptr->xsz*Parptr->ysz], no_data_value))
./input.cpp:1228:					Arrptr->pbound[i + j*Parptr->xsz + m*Parptr->xsz*Parptr->ysz + k*Parptr->xsz*Parptr->ysz] = 1;
./input.cpp:1248:			//fscanf(fp, "%" NUM_FMT"", Arrptr->H + i + j*Parptr->xsz);
./input.cpp:1250:			if (AreEqual(Arrptr->H[i + j*Parptr->xsz], no_data_value)) Arrptr->H[i + j*Parptr->xsz] = C(0.0);
./input.cpp:1256:					gr = Arrptr->SGCgroup[i + j*Parptr->xsz]; // channel group number
./input.cpp:1258:					Arrptr->H[i + j*Parptr->xsz] = getmax(Arrptr->H[i + j*Parptr->xsz] - Arrptr->SGCz[i + j*Parptr->xsz], C(0.0));
./input.cpp:1260:					if (Arrptr->H[i + j*Parptr->xsz] <= Arrptr->SGCbfH[i + j*Parptr->xsz])
./input.cpp:1261:						Arrptr->SGCVol[i + j*Parptr->xsz] = CalcSGC_UpV(SGCptr->SGCchantype[gr], Arrptr->H[i + j*Parptr->xsz], SGCptr->SGCs[gr], Arrptr->SGCc[i + j*Parptr->xsz]);
./input.cpp:1262:					else if (Arrptr->SGCwidth[i + j*Parptr->xsz] >= C(0.5)*(Arrptr->dx[i + j*Parptr->xsz] + Arrptr->dy[i + j*Parptr->xsz]))
./input.cpp:1263:						Arrptr->SGCVol[i + j*Parptr->xsz] = CalcSGC_UpV(SGCptr->SGCchantype[gr], Arrptr->H[i + j*Parptr->xsz], SGCptr->SGCs[gr], Arrptr->SGCc[i + j*Parptr->xsz]);
./input.cpp:1265:						Arrptr->SGCVol[i + j*Parptr->xsz] = Arrptr->SGCbfV[i + j*Parptr->xsz] + (Arrptr->H[i + j*Parptr->xsz] 
./input.cpp:1266:							- Arrptr->SGCbfH[i + j*Parptr->xsz])*(Arrptr->dx[i + j*Parptr->xsz] * Arrptr->dy[i + j*Parptr->xsz]); // out of bank level * cell area
./input.cpp:1269:					Arrptr->H[i + j*Parptr->xsz] = getmax(Arrptr->H[i + j*Parptr->xsz] - Arrptr->DEM[i + j*Parptr->xsz], C(0.0));
./input.cpp:1274:				gr = Arrptr->SGCgroup[i + j*Parptr->xsz]; // channel group number
./input.cpp:1275:				if (Arrptr->H[i + j*Parptr->xsz] <= Arrptr->SGCbfH[i + j*Parptr->xsz])
./input.cpp:1276:					Arrptr->SGCVol[i + j*Parptr->xsz] = CalcSGC_UpV(SGCptr->SGCchantype[gr], Arrptr->H[i + j*Parptr->xsz], SGCptr->SGCs[gr], Arrptr->SGCc[i + j*Parptr->xsz]);
./input.cpp:1277:				else if (Arrptr->SGCwidth[i + j*Parptr->xsz] >= C(0.5)*(Arrptr->dx[i + j*Parptr->xsz] + Arrptr->dy[i + j*Parptr->xsz]))
./input.cpp:1278:					Arrptr->SGCVol[i + j*Parptr->xsz] = CalcSGC_UpV(SGCptr->SGCchantype[gr], Arrptr->H[i + j*Parptr->xsz], SGCptr->SGCs[gr], Arrptr->SGCc[i + j*Parptr->xsz]);
./input.cpp:1280:					Arrptr->SGCVol[i + j*Parptr->xsz] = Arrptr->SGCbfV[i + j*Parptr->xsz] + (Arrptr->H[i + j*Parptr->xsz] - Arrptr->SGCbfH[i + j*Parptr->xsz])*(Arrptr->dx[i + j*Parptr->xsz] * Arrptr->dy[i + j*Parptr->xsz]); // out of bank level
./input.cpp:1303:			fscanf(fp, "%" NUM_FMT"", Arrptr->H + i + j*Parptr->xsz);
./input.cpp:1338:		fread(Arrptr->H + j*Parptr->xsz, sizeof(NUMERIC_TYPE), Parptr->xsz, fp);
./input.cpp:1343:		//	if ((int)Arrptr->H[i + j*Parptr->xsz] == no_data_value) Arrptr->H[i + j*Parptr->xsz] = C(0.0);
./input.cpp:1347:		//		if (Statesptr->SGC == ON) Arrptr->H[i + j*Parptr->xsz] = getmax(Arrptr->H[i + j*Parptr->xsz] - Arrptr->SGCz[i + j*Parptr->xsz], C(0.0));
./input.cpp:1348:		//		else Arrptr->H[i + j*Parptr->xsz] = getmax(Arrptr->H[i + j*Parptr->xsz] - Arrptr->DEM[i + j*Parptr->xsz], C(0.0));
./input.cpp:1387:			fscanf(fp, "%" NUM_FMT"", Arrptr->HU + i + j*Parptr->xsz);
./input.cpp:1400:			fscanf(fp, "%" NUM_FMT"", Arrptr->HV + i + j*Parptr->xsz);
./input.cpp:1421:	Arrptr->H = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1425:		Arrptr->HU = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1426:		Arrptr->HV = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1427:		Arrptr->LSHU = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1428:		Arrptr->RSHU = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1429:		Arrptr->BSHU = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1430:		Arrptr->TSHU = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1431:		Arrptr->LSHV = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1432:		Arrptr->RSHV = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1433:		Arrptr->BSHV = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1434:		Arrptr->TSHV = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1435:		Arrptr->FHx = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input.cpp:1436:		Arrptr->FHUx = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input.cpp:1437:		Arrptr->FHVx = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input.cpp:1438:		Arrptr->FHy = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input.cpp:1439:		Arrptr->FHUy = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input.cpp:1440:		Arrptr->FHVy = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input.cpp:1451:	Arrptr->maxH = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1452:	Arrptr->totalHtm = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1453:	Arrptr->Qx = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input.cpp:1454:	Arrptr->Qy = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input.cpp:1456:	//Arrptr->Hflowx=memory_allocate_zero_numeric_legacy((Parptr->xsz+1)*(Parptr->ysz+1));
./input.cpp:1457:	//Arrptr->Hflowy=memory_allocate_zero_numeric_legacy((Parptr->xsz+1)*(Parptr->ysz+1));
./input.cpp:1461:		Arrptr->Vx = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input.cpp:1462:		Arrptr->Vy = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input.cpp:1463:		Arrptr->maxVx = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input.cpp:1464:		Arrptr->maxVy = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input.cpp:1468:		Arrptr->maxVc = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1469:		Arrptr->maxVcH = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1470:		Arrptr->maxHaz = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1475:		Arrptr->SGCwidth = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1476:		Arrptr->SGCz = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1477:		Arrptr->SGCc = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1480:		Arrptr->QxSGold = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input.cpp:1481:		Arrptr->QySGold = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input.cpp:1483:		Arrptr->SGCbfH = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1484:		Arrptr->SGCbfV = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1486:		Arrptr->SGCVol = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1487:		Arrptr->SGCdVol = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1489:		Arrptr->SGCgroup = new int[Parptr->xsz*Parptr->ysz]();
./input.cpp:1492:			Arrptr->SGCFlowWidth = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1496:	Arrptr->Qxold = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input.cpp:1497:	Arrptr->Qyold = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input.cpp:1502:	Arrptr->U = memory_allocate_zero_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input.cpp:1503:	//Arrptr->V=memory_allocate_zero_numeric_legacy((Parptr->xsz+1)*(Parptr->ysz+1));
./input.cpp:1506:	Arrptr->maxHtm = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1507:	Arrptr->initHtm = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1508:	Arrptr->TRecx = memory_allocate_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input.cpp:1509:	Arrptr->TRecy = memory_allocate_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input.cpp:1510:	Arrptr->LimQx = memory_allocate_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input.cpp:1511:	Arrptr->LimQy = memory_allocate_numeric_legacy((Parptr->xsz + 1)*(Parptr->ysz + 1));
./input.cpp:1513:	Arrptr->ChanMask = new int[Parptr->xsz*Parptr->ysz];
./input.cpp:1514:	Arrptr->SegMask = new int[Parptr->xsz*Parptr->ysz];
./input.cpp:1516:	Arrptr->DEM = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1521:		Arrptr->FlowDir = new int[Parptr->xsz*Parptr->ysz]();
./input.cpp:1522:		for (i = 0; i < Parptr->xsz*Parptr->ysz; i++) Arrptr->FlowDir[i] = (int)NULLVAL;
./input.cpp:1526:	Arrptr->dx = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1527:	Arrptr->dy = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1528:	Arrptr->dA = memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:1533:	for (i = 0; i < Parptr->xsz*Parptr->ysz; i++) Arrptr->maxHtm[i] = NULLVAL;
./input.cpp:1534:	for (i = 0; i < Parptr->xsz*Parptr->ysz; i++) Arrptr->initHtm[i] = NULLVAL;
./input.cpp:1535:	for (i = 0; i < (Parptr->xsz + 1)*(Parptr->ysz + 1); i++) Arrptr->TRecx[i] = NULLVAL;
./input.cpp:1536:	for (i = 0; i < (Parptr->xsz + 1)*(Parptr->ysz + 1); i++) Arrptr->TRecy[i] = NULLVAL;
./input.cpp:1537:	for (i = 0; i < (Parptr->xsz + 1)*(Parptr->ysz + 1); i++) Arrptr->LimQx[i] = NULLVAL;
./input.cpp:1538:	for (i = 0; i < (Parptr->xsz + 1)*(Parptr->ysz + 1); i++) Arrptr->LimQy[i] = NULLVAL;
./input.cpp:1541:	for (i = 0; i < Parptr->xsz*Parptr->ysz; i++) Arrptr->ChanMask[i] = -1;
./input.cpp:1542:	for (i = 0; i < Parptr->xsz*Parptr->ysz; i++) Arrptr->SegMask[i] = -1;
./input.cpp:1544:	LoadDEMData(Parptr, Arrptr, Arrptr->DEM, fp, no_data_value);
./input.cpp:2227:	Arrptr->evap = LoadTimeSeries(Fnameptr->evapfilename, fp, ON);
./input.cpp:2231:	for (i = 0; i < Arrptr->evap->count; i++)
./input.cpp:2232:		Arrptr->evap->value[i] /= (1000 * 24 * 3600);
./input.cpp:2247:	Arrptr->rain = LoadTimeSeries(Fnameptr->rainfilename, fp, ON);
./input.cpp:2251:	for (i = 0; i < Arrptr->rain->count; i++)
./input.cpp:2252:		Arrptr->rain->value[i] /= (1000 * 3600);
./input.cpp:2279:	Arrptr->Rainmask = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./input.cpp:2283:		fscanf(fp, "%" NUM_FMT"", Arrptr->Rainmask + i + j*Parptr->xsz);
./input.cpp:2284:		if (AreEqual(Arrptr->Rainmask[i + j*Parptr->xsz], no_data_value))
./input.cpp:2285:			Arrptr->Rainmask[i + j*Parptr->xsz] = 0;
./input.cpp:2305:		memset(Arrptr->SGCwidth, 0, sizeof(NUMERIC_TYPE)*(Parptr->xsz)*(Parptr->ysz));
./input.cpp:2306:		memcpy(Arrptr->SGCz, Arrptr->DEM, sizeof(NUMERIC_TYPE)*(Parptr->xsz)*(Parptr->ysz));
./input.cpp:2316:			fscanf(fp, "%" NUM_FMT"", Arrptr->SGCz + i + j*Parptr->xsz);
./input.cpp:2317:			if (AreEqual(Arrptr->SGCz[i + j*Parptr->xsz], no_data_value))
./input.cpp:2318:				Arrptr->SGCz[i + j*Parptr->xsz] = Arrptr->DEM[i + j*Parptr->xsz]; // In the case of no_data_value set the bank height to the DEM
./input.cpp:2329:			fscanf(fp, "%" NUM_FMT"", Arrptr->SGCwidth + i + j*Parptr->xsz);
./input.cpp:2330:			if (AreEqual( Arrptr->SGCwidth[i + j*Parptr->xsz], no_data_value))
./input.cpp:2331:				Arrptr->SGCwidth[i + j*Parptr->xsz] = C(0.0); // In the case of no_data_value set the width to zero
./input.cpp:2348:			Arrptr->SGCgroup[i + j*Parptr->xsz] = (int)tmp;
./input.cpp:2349:			if (AreEqual(Arrptr->SGCgroup[i + j*Parptr->xsz], no_data_value) || Arrptr->SGCgroup[i + j*Parptr->xsz] < 0) 
./input.cpp:2350:				Arrptr->SGCgroup[i + j*Parptr->xsz] = 0; // In the case of no_data_value set the chan group to zero
./input.cpp:2358:		memset(Arrptr->ChanMask, 0, sizeof(int)*(Parptr->xsz)*(Parptr->ysz));
./input.cpp:2368:			if (AreEqual(tmp, no_data_value)) Arrptr->ChanMask[i + j*Parptr->xsz] = 0; // In the case of no_data_value set the chan mask to zero
./input.cpp:2369:			else if (tmp > C(0.0)) Arrptr->ChanMask[i + j*Parptr->xsz] = 1; // a positive number is a mask cell 1
./input.cpp:2370:			else Arrptr->ChanMask[i + j*Parptr->xsz] = 0; // anything else is a no mask cell 0
./input.cpp:2591:	read_file(Fnameptr->DamMaskfilename, no_data_value, &num_cols, &num_rows, &Arrptr->DamMask, &xllcorner, &yllcorner, &cell_size);
./input.cpp:2596:		if (Arrptr->DamMask[i + j*Parptr->xsz] < C(0.0)) 
./input.cpp:2598:			Arrptr->DEM[i + j*Parptr->xsz] = no_data_value;
./input.cpp:2599:			if (AreEqual(Arrptr->DEM[i + j*Parptr->xsz], no_data_value))
./input.cpp:2600:			Arrptr->DEM[i + j*Parptr->xsz] = DEM_NO_DATA;
./input.cpp:2607:		if (Arrptr->DamMask[i + j*Parptr->xsz]== (n+1))
./lisflood2/lis2_output.cpp:454:			//	write_binrasterfile(resrootname, save_number, ".QLxb", Arrptr->LimQx, Arrptr->DEM, 1, Statesptr, Parptr);
./lisflood2/lis2_output.cpp:455:			//	write_binrasterfile(resrootname, save_number, ".QLyb", Arrptr->LimQy, Arrptr->DEM, 2, Statesptr, Parptr);
./lisflood2/lis2_output.cpp:459:			//	write_ascfile(resrootname, save_number, ".QLx", Arrptr->LimQx, Arrptr->DEM, 1, Statesptr, Parptr);
./lisflood2/lis2_output.cpp:460:			//	write_ascfile(resrootname, save_number, ".QLy", Arrptr->LimQy, Arrptr->DEM, 2, Statesptr, Parptr);
./lisflood2/lisflood_processing.cpp:29:	int channel_group0 = Arrptr->SGCgroup[grid_index];
./lisflood2/lisflood_processing.cpp:30:	int channel_group1 = Arrptr->SGCgroup[grid_index_next];
./lisflood2/lisflood_processing.cpp:35:	if (Arrptr->SGCManningsn != NULL)
./lisflood2/lisflood_processing.cpp:37:		g_friction_squared = g * C(0.5) * Arrptr->SGCManningsn[grid_index] * Arrptr->SGCManningsn[grid_index_next];
./lisflood2/lisflood_processing.cpp:57:	sub_grid_cell_info->sg_cell_cell_area[cell_index] = Arrptr->dA[source_row_index];
./lisflood2/lisflood_processing.cpp:58:	sub_grid_cell_info->sg_cell_dem[cell_index] = Arrptr->DEM[source_index];
./lisflood2/lisflood_processing.cpp:60:	sub_grid_cell_info->sg_cell_SGC_width[cell_index] = Arrptr->SGCwidth[source_index];
./lisflood2/lisflood_processing.cpp:61:	sub_grid_cell_info->sg_cell_SGC_BankFullHeight[cell_index] = Arrptr->SGCbfH[source_index];
./lisflood2/lisflood_processing.cpp:62:	sub_grid_cell_info->sg_cell_SGC_BankFullVolume[cell_index] = Arrptr->SGCbfV[source_index];
./lisflood2/lisflood_processing.cpp:63:	sub_grid_cell_info->sg_cell_SGC_c[cell_index] = Arrptr->SGCc[source_index];
./lisflood2/lisflood_processing.cpp:65:	sub_grid_cell_info->sg_cell_SGC_group[cell_index] = Arrptr->SGCgroup[source_index];
./lisflood2/lisflood_processing.cpp:66:	sub_grid_cell_info->sg_cell_SGC_is_large[cell_index] = (sub_grid_cell_info->sg_cell_SGC_width[cell_index] >= C(0.5)*(Arrptr->dx[source_row_index] + Arrptr->dy[source_row_index]));
./lisflood2/lisflood_processing.cpp:82:		(Arrptr->SGCwidth[source_index_right] > C(0.0)) &&
./lisflood2/lisflood_processing.cpp:83:		(Arrptr->DEM[source_index_right] != DEM_NO_DATA || Arrptr->ChanMask[source_index_right] > 0) && // typically the sub-grid model would not operate under DEM NoData, except if ChanMask is present
./lisflood2/lisflood_processing.cpp:84:		(weirs_enable != ON || Arrptr->Weir_Identx[source_index_qx] == -1)
./lisflood2/lisflood_processing.cpp:92:		if ((Arrptr->SGCwidth[source_index_below] > C(0.0)) &&
./lisflood2/lisflood_processing.cpp:93:			(Arrptr->DEM[source_index_below] != DEM_NO_DATA || Arrptr->ChanMask[source_index_below] > 0) &&
./lisflood2/lisflood_processing.cpp:94:			(weirs_enable != ON || Arrptr->Weir_Identy[source_index_qy] == -1)
./lisflood2/lisflood_processing.cpp:151:			if (Arrptr->SGCwidth[source_index_this] > C(0.0) && (Arrptr->DEM[source_index_this] != DEM_NO_DATA || Arrptr->ChanMask[source_index_this] > 0))
./lisflood2/lisflood_processing.cpp:203:				if (Arrptr->SGCwidth[source_index_this] > C(0.0) && (Arrptr->DEM[source_index_this] != DEM_NO_DATA || Arrptr->ChanMask[source_index_this] > 0))
./lisflood2/lisflood_processing.cpp:287:				if (Arrptr->SGCwidth[source_index_this] > C(0.0) && (Arrptr->DEM[source_index_this] != DEM_NO_DATA || Arrptr->ChanMask[source_index_this] > 0))
./lisflood2/lisflood_processing.cpp:306:					//Arrptr->SGCbfH[source_index] = 0;
./lisflood2/lisflood_processing.cpp:329:			const NUMERIC_TYPE row_dx = Arrptr->dx[source_row_index];
./lisflood2/lisflood_processing.cpp:330:			const NUMERIC_TYPE row_dy = Arrptr->dy[source_row_index];
./lisflood2/lisflood_processing.cpp:341:				if (Arrptr->SGCwidth[source_index_this] > C(0.0) && (Arrptr->DEM[source_index_this] != DEM_NO_DATA || Arrptr->ChanMask[source_index_this] > 0))
./lisflood2/lisflood_processing.cpp:344:						(Arrptr->SGCwidth[source_index_right] > C(0.0)) &&
./lisflood2/lisflood_processing.cpp:345:						(Arrptr->DEM[source_index_right] != DEM_NO_DATA || Arrptr->ChanMask[source_index_right] > 0) &&
./lisflood2/lisflood_processing.cpp:346:						(Statesptr->weirs != ON || Arrptr->Weir_Identx[source_index_qx] == -1)) // don't add the sub-grid calculation where there is a weir)
./lisflood2/lisflood_processing.cpp:382:						if ((Arrptr->SGCwidth[source_index_below] > C(0.0)) &&
./lisflood2/lisflood_processing.cpp:383:							(Arrptr->DEM[source_index_below] != DEM_NO_DATA || Arrptr->ChanMask[source_index_below] > 0) &&
./lisflood2/lisflood_processing.cpp:384:							(Statesptr->weirs != ON || Arrptr->Weir_Identy[source_index_qy] == -1)) // don't add the sub-grid calculation where there is a weir)
./lisflood2/lisflood_processing.cpp:484:			if (Arrptr->SGCwidth[source_index_this] > C(0.0) && (Arrptr->DEM[source_index_this] != DEM_NO_DATA || Arrptr->ChanMask[source_index_this] > 0))
./lisflood2/lisflood_processing.cpp:547:			if (Arrptr->SGCwidth[source_index_this] > C(0.0) && (Arrptr->DEM[source_index_this] != DEM_NO_DATA || Arrptr->ChanMask[source_index_this] > 0))
./lisflood2/lisflood_processing.cpp:569:				//Arrptr->SGCbfH[source_index] = 0;
./lisflood2/lisflood_processing.cpp:580:		const NUMERIC_TYPE row_dx = Arrptr->dx[source_row_index];
./lisflood2/lisflood_processing.cpp:581:		const NUMERIC_TYPE row_dy = Arrptr->dy[source_row_index];
./lisflood2/lisflood_processing.cpp:596:			if (Arrptr->SGCwidth[source_index_this] > C(0.0) && (Arrptr->DEM[source_index_this] != DEM_NO_DATA || Arrptr->ChanMask[source_index_this] > 0))
./lisflood2/lisflood_processing.cpp:599:					(Arrptr->SGCwidth[source_index_right] > C(0.0)) &&
./lisflood2/lisflood_processing.cpp:600:					(Arrptr->DEM[source_index_right] != DEM_NO_DATA || Arrptr->ChanMask[source_index_right] > 0)  &&
./lisflood2/lisflood_processing.cpp:601:					(Statesptr->weirs != ON || Arrptr->Weir_Identx[source_index_right_q] == -1)) // don't add the sub-grid calculation where there is a weir)
./lisflood2/lisflood_processing.cpp:637:					if ((Arrptr->SGCwidth[source_index_below] > C(0.0)) &&
./lisflood2/lisflood_processing.cpp:638:						(Arrptr->DEM[source_index_below] != DEM_NO_DATA || Arrptr->ChanMask[source_index_below] > 0) &&
./lisflood2/lisflood_processing.cpp:639:						(Statesptr->weirs != ON || Arrptr->Weir_Identy[source_index_below_q] == -1)) // don't add the sub-grid calculation where there is a weir)
./lisflood2/lisflood_processing.cpp:703:	if (Arrptr->Manningsn != NULL)
./lisflood2/lisflood_processing.cpp:704:		n = Arrptr->Manningsn[source_index];
./lisflood2/lisflood_processing.cpp:709:	if (Arrptr->SGCManningsn != NULL)
./lisflood2/lisflood_processing.cpp:710:		n = Arrptr->SGCManningsn[source_index] * Arrptr->SGCManningsn[source_index];
./lisflood2/lisflood_processing.cpp:713:		int group = Arrptr->SGCgroup[source_index];
./lisflood2/lisflood_processing.cpp:740:	if (Arrptr->Manningsn != NULL)
./lisflood2/lisflood_processing.cpp:741:		n = Arrptr->Manningsn[source_index];
./lisflood2/lisflood_processing.cpp:746:	if (Arrptr->SGCManningsn != NULL)
./lisflood2/lisflood_processing.cpp:747:		n = Arrptr->SGCManningsn[source_index] * Arrptr->SGCManningsn[source_index];
./lisflood2/lisflood_processing.cpp:750:		int group = Arrptr->SGCgroup[source_index];
./lisflood2/lisflood_processing.cpp:908:	weirs->weir_count = Arrptr->weir_count;
./lisflood2/lisflood_processing.cpp:910:	weirs->Weir_hc = Arrptr->Weir_hc;
./lisflood2/lisflood_processing.cpp:911:	weirs->Weir_Cd = Arrptr->Weir_Cd;
./lisflood2/lisflood_processing.cpp:912:	weirs->Weir_m = Arrptr->Weir_m;
./lisflood2/lisflood_processing.cpp:913:	weirs->Weir_w = Arrptr->Weir_w;
./lisflood2/lisflood_processing.cpp:914:	weirs->Weir_Fixdir = Arrptr->Weir_Fixdir;
./lisflood2/lisflood_processing.cpp:915:	weirs->Weir_Typ = Arrptr->Weir_Typ;
./lisflood2/lisflood_processing.cpp:926:			int weir_id = Arrptr->Weir_Identx[source_q_index];
./lisflood2/lisflood_processing.cpp:949:			int weir_id = Arrptr->Weir_Identy[source_q_index];
./lisflood2/lisflood_processing.cpp:955:					int weir_id = Arrptr->Weir_Identy[source_q_index];
./lisflood2/lisflood_processing.cpp:997:			int weir_id = Arrptr->Weir_Identx[source_q_index];
./lisflood2/lisflood_processing.cpp:1003:				weirs->Weir_Q_old_SG[weir_id] = Arrptr->QxSGold[source_q_index]; // copy from saved q if any
./lisflood2/lisflood_processing.cpp:1037:				int group0 = Arrptr->SGCgroup[source_index];
./lisflood2/lisflood_processing.cpp:1038:				int group1 = Arrptr->SGCgroup[source_index + 1];
./lisflood2/lisflood_processing.cpp:1056:				int weir_id = Arrptr->Weir_Identy[source_q_index];
./lisflood2/lisflood_processing.cpp:1063:					weirs->Weir_Q_old_SG[weir_id] = Arrptr->QySGold[source_q_index]; // copy from saved q if any
./lisflood2/lisflood_processing.cpp:1097:					int group0 = Arrptr->SGCgroup[source_index];
./lisflood2/lisflood_processing.cpp:1098:					int group1 = Arrptr->SGCgroup[source_index + grid_cols];
./lisflood2/lisflood_processing.cpp:1132:		if (Arrptr->DEM[source_index] > Arrptr->DEM[source_index_next] &&
./lisflood2/lisflood_processing.cpp:1133:			Arrptr->FlowDir[source_index] == source_index_next)
./lisflood2/lisflood_processing.cpp:1135:			route_V_ratio_per_sec_qx[dest_q_index] = -1 / Arrptr->RouteInt[source_index];
./lisflood2/lisflood_processing.cpp:1137:		else if (Arrptr->DEM[source_index] < Arrptr->DEM[source_index_next] &&
./lisflood2/lisflood_processing.cpp:1138:			Arrptr->FlowDir[source_index_next] == source_index)
./lisflood2/lisflood_processing.cpp:1140:			route_V_ratio_per_sec_qx[dest_q_index] = 1 / Arrptr->RouteInt[source_index_next];
./lisflood2/lisflood_processing.cpp:1151:			if (Arrptr->DEM[source_index] > Arrptr->DEM[source_index_next] &&
./lisflood2/lisflood_processing.cpp:1152:				Arrptr->FlowDir[source_index] == source_index_next)
./lisflood2/lisflood_processing.cpp:1154:				route_V_ratio_per_sec_qy[dest_q_index] = -1 / Arrptr->RouteInt[source_index];
./lisflood2/lisflood_processing.cpp:1156:			else if (Arrptr->DEM[source_index] < Arrptr->DEM[source_index_next] &&
./lisflood2/lisflood_processing.cpp:1157:				Arrptr->FlowDir[source_index_next] == source_index)
./lisflood2/lisflood_processing.cpp:1159:				route_V_ratio_per_sec_qy[dest_q_index] = 1 / Arrptr->RouteInt[source_index_next];
./lisflood2/lisflood_processing.cpp:1181:		if (Arrptr->DamMask[i + j*grid_cols] > C(0.0))
./lisflood2/lisflood_processing.cpp:1184:			NUMERIC_TYPE cell_lenght = (Arrptr->dx[j*grid_cols] + Arrptr->dy[j*grid_cols]) / C(2.0);
./lisflood2/lisflood_processing.cpp:1186:			gr = Arrptr->SGCgroup[source_index];
./lisflood2/lisflood_processing.cpp:1189:			Damptr->DynamicEdge[(2 * n) + 1] = Arrptr->DamMask[i + j*grid_cols];
./lisflood2/lisflood_processing.cpp:1194:			Damptr->DynamicEdgeData[12 * n + 3] = Arrptr->Manningsn[source_index]; //nfp
./lisflood2/lisflood_processing.cpp:1195:			Damptr->DynamicEdgeData[12 * n + 4] = Arrptr->DEM[source_index]; // Zfp
./lisflood2/lisflood_processing.cpp:1197:			Damptr->DynamicEdgeData[12 * n + 6] = Arrptr->SGCz[source_index]; // BankFullDepth
./lisflood2/lisflood_processing.cpp:1202:			Damptr->DynamicEdgeData[12 * n + 11] = Arrptr->SGCwidth[source_index];; // widthSGC
./lisflood2/lisflood_processing.cpp:1205:			if (i > C(0.0) && Arrptr->DamMask[i-1 + j*grid_cols] < C(0.0))
./lisflood2/lisflood_processing.cpp:1207:				Damptr->DynamicEdgeData[12 * n + 2] += Arrptr->dx[j*grid_cols];
./lisflood2/lisflood_processing.cpp:1209:			if (i < grid_cols && Arrptr->DamMask[i + 1 + j*grid_cols] < C(0.0))
./lisflood2/lisflood_processing.cpp:1211:				Damptr->DynamicEdgeData[12 * n + 2] += Arrptr->dx[j*grid_cols];
./lisflood2/lisflood_processing.cpp:1213:			if (j > C(0.0) && Arrptr->DamMask[i + (j - 1)*grid_cols] < C(0.0))
./lisflood2/lisflood_processing.cpp:1215:				Damptr->DynamicEdgeData[12 * n + 2] += Arrptr->dy[(j-1)*grid_cols];
./lisflood2/lisflood_processing.cpp:1217:			if (j < grid_rows && Arrptr->DamMask[i + (j + 1)*grid_cols] < C(0.0))
./lisflood2/lisflood_processing.cpp:1219:				Damptr->DynamicEdgeData[12 * n + 2] += Arrptr->dy[(j+1)*grid_cols];
./lisflood2/lisflood_processing.cpp:1240:	//memory_free_legacy(&Arrptr->DEM ); 
./lisflood2/lisflood_processing.cpp:1241:	//memory_free_legacy(&Arrptr->H );
./lisflood2/lisflood_processing.cpp:1242:	memory_free_legacy(&Arrptr->Qx); //todo copy in case of checkpoint
./lisflood2/lisflood_processing.cpp:1243:	memory_free_legacy(&Arrptr->Qy); //todo copy in case of checkpoint
./lisflood2/lisflood_processing.cpp:1244:	memory_free_legacy(&Arrptr->Qxold); //todo copy in case of checkpoint?
./lisflood2/lisflood_processing.cpp:1245:	memory_free_legacy(&Arrptr->Qyold); //todo copy in case of checkpoint?
./lisflood2/lisflood_processing.cpp:1246:	memory_free_legacy(&Arrptr->U);
./lisflood2/lisflood_processing.cpp:1247:	//memory_free_legacy(&Arrptr->V);
./lisflood2/lisflood_processing.cpp:1250:	memory_free_legacy(&Arrptr->HU);
./lisflood2/lisflood_processing.cpp:1251:	memory_free_legacy(&Arrptr->HV);
./lisflood2/lisflood_processing.cpp:1252:	memory_free_legacy(&Arrptr->RSHU);
./lisflood2/lisflood_processing.cpp:1253:	memory_free_legacy(&Arrptr->LSHU);
./lisflood2/lisflood_processing.cpp:1254:	memory_free_legacy(&Arrptr->RSHV);
./lisflood2/lisflood_processing.cpp:1255:	memory_free_legacy(&Arrptr->LSHV);
./lisflood2/lisflood_processing.cpp:1256:	memory_free_legacy(&Arrptr->BSHU);
./lisflood2/lisflood_processing.cpp:1257:	memory_free_legacy(&Arrptr->TSHU);
./lisflood2/lisflood_processing.cpp:1258:	memory_free_legacy(&Arrptr->BSHV);
./lisflood2/lisflood_processing.cpp:1259:	memory_free_legacy(&Arrptr->TSHV);
./lisflood2/lisflood_processing.cpp:1260:	memory_free_legacy(&Arrptr->FHx);
./lisflood2/lisflood_processing.cpp:1261:	memory_free_legacy(&Arrptr->FHUx);
./lisflood2/lisflood_processing.cpp:1262:	memory_free_legacy(&Arrptr->FHVx);
./lisflood2/lisflood_processing.cpp:1263:	memory_free_legacy(&Arrptr->FHy);
./lisflood2/lisflood_processing.cpp:1264:	memory_free_legacy(&Arrptr->FHUy);
./lisflood2/lisflood_processing.cpp:1265:	memory_free_legacy(&Arrptr->FHVy);
./lisflood2/lisflood_processing.cpp:1267:	//memory_free_legacy(&Arrptr->FlowDir);
./lisflood2/lisflood_processing.cpp:1268:	memory_free_legacy(&Arrptr->Route_dH);
./lisflood2/lisflood_processing.cpp:1269:	//memory_free_legacy(&Arrptr->RouteInt);
./lisflood2/lisflood_processing.cpp:1272:	memory_free_legacy(&Arrptr->maxH); //todo copy in case of checkpoint
./lisflood2/lisflood_processing.cpp:1273:	memory_free_legacy(&Arrptr->maxHtm); //todo copy in case of checkpoint
./lisflood2/lisflood_processing.cpp:1274:	memory_free_legacy(&Arrptr->initHtm); //todo copy in case of checkpoint
./lisflood2/lisflood_processing.cpp:1275:	memory_free_legacy(&Arrptr->totalHtm); //todo copy in case of checkpoint
./lisflood2/lisflood_processing.cpp:1276:	//memory_free_legacy(&Arrptr->Manningsn );
./lisflood2/lisflood_processing.cpp:1277:	//memory_free_legacy(&Arrptr->SGCManningsn );
./lisflood2/lisflood_processing.cpp:1278:	memory_free_legacy(&Arrptr->paerial);
./lisflood2/lisflood_processing.cpp:1279:	memory_free_legacy(&Arrptr->pbound);
./lisflood2/lisflood_processing.cpp:1280:	//memory_free_legacy(&Arrptr->Weir_hc); // lists of weirs used
./lisflood2/lisflood_processing.cpp:1281:	//memory_free_legacy(&Arrptr->Weir_Cd);
./lisflood2/lisflood_processing.cpp:1282:	//memory_free_legacy(&Arrptr->Weir_m);
./lisflood2/lisflood_processing.cpp:1283:	//memory_free_legacy(&Arrptr->Weir_w);
./lisflood2/lisflood_processing.cpp:1284:	//memory_free_legacy(&Arrptr->Weir_Fixdir);
./lisflood2/lisflood_processing.cpp:1285:	//memory_free_legacy(&Arrptr->Weir_Typ);
./lisflood2/lisflood_processing.cpp:1287:	//memory_free_legacy(&Arrptr->evap );
./lisflood2/lisflood_processing.cpp:1288:	//memory_free_legacy(&Arrptr->rain );
./lisflood2/lisflood_processing.cpp:1290:	//memory_free_legacy(&Arrptr->ChanMask);
./lisflood2/lisflood_processing.cpp:1291:	memory_free_legacy(&Arrptr->SegMask);
./lisflood2/lisflood_processing.cpp:1293:	memory_free_legacy(&Arrptr->TRecx);
./lisflood2/lisflood_processing.cpp:1294:	memory_free_legacy(&Arrptr->TRecy);
./lisflood2/lisflood_processing.cpp:1296:	memory_free_legacy(&Arrptr->LimQx);
./lisflood2/lisflood_processing.cpp:1297:	memory_free_legacy(&Arrptr->LimQy);
./lisflood2/lisflood_processing.cpp:1298:	memory_free_legacy(&Arrptr->Vx);
./lisflood2/lisflood_processing.cpp:1299:	memory_free_legacy(&Arrptr->Vy);
./lisflood2/lisflood_processing.cpp:1300:	memory_free_legacy(&Arrptr->maxVx);
./lisflood2/lisflood_processing.cpp:1301:	memory_free_legacy(&Arrptr->maxVy);
./lisflood2/lisflood_processing.cpp:1302:	memory_free_legacy(&Arrptr->Vc);
./lisflood2/lisflood_processing.cpp:1303:	memory_free_legacy(&Arrptr->maxVc);
./lisflood2/lisflood_processing.cpp:1304:	memory_free_legacy(&Arrptr->maxVcH);
./lisflood2/lisflood_processing.cpp:1305:	memory_free_legacy(&Arrptr->maxHaz);
./lisflood2/lisflood_processing.cpp:1306:	//memory_free_legacy(&Arrptr->SGCwidth );
./lisflood2/lisflood_processing.cpp:1307:	//memory_free_legacy(&Arrptr->SGCz);
./lisflood2/lisflood_processing.cpp:1309:	//memory_free_legacy(&Arrptr->SGCbfH );
./lisflood2/lisflood_processing.cpp:1310:	//memory_free_legacy(&Arrptr->SGCVol );
./lisflood2/lisflood_processing.cpp:1311:	memory_free_legacy(&Arrptr->SGCdVol);
./lisflood2/lisflood_processing.cpp:1312:	//memory_free_legacy(&Arrptr->SGCbfV );
./lisflood2/lisflood_processing.cpp:1313:	//memory_free_legacy(&Arrptr->SGCc );
./lisflood2/lisflood_processing.cpp:1314:	memory_free_legacy(&Arrptr->SGCFlowWidth);
./lisflood2/lisflood_processing.cpp:1315:	memory_free_legacy(&Arrptr->SGCdx);
./lisflood2/lisflood_processing.cpp:1316:	memory_free_legacy(&Arrptr->SGCcat_area);
./lisflood2/lisflood_processing.cpp:1317:	//memory_free_legacy(&Arrptr->dx );
./lisflood2/lisflood_processing.cpp:1318:	//memory_free_legacy(&Arrptr->dy );
./lisflood2/lisflood_processing.cpp:1319:	//memory_free_legacy(&Arrptr->dA ); 
./lisflood2/lisflood_processing.cpp:1321:	//memory_free_legacy(&Arrptr->SGCgroup);
./lisflood2/lisflood_processing.cpp:1327:	TimeSeries * evap_time_series = Arrptr->evap;
./lisflood2/lisflood_processing.cpp:1328:	TimeSeries * rain_time_series = Arrptr->rain;
./lisflood2/lisflood_processing.cpp:1412:	//if (Arrptr->SGCManningsn != NULL)
./lisflood2/lisflood_processing.cpp:1519:		//memory_free_legacy(&Arrptr->ChanMask);
./lisflood2/lisflood_processing.cpp:1521:	memory_free_legacy(&Arrptr->SGCz);
./lisflood2/lisflood_processing.cpp:1582:				if (start == -1 && Arrptr->DEM[source_row_index + i] != DEM_NO_DATA)
./lisflood2/lisflood_processing.cpp:1584:				if (Arrptr->DEM[source_row_index + i] != DEM_NO_DATA)
./lisflood2/lisflood_processing.cpp:1603:			memcpy(h_grid + dest_row_index, Arrptr->H + source_row_index, source_bytes_per_row);
./lisflood2/lisflood_processing.cpp:1607:			memcpy(volume_grid + dest_row_index, Arrptr->SGCVol + source_row_index, source_bytes_per_row);
./lisflood2/lisflood_processing.cpp:1610:			memcpy(dem_grid + dest_row_index, Arrptr->DEM + source_row_index, source_bytes_per_row);
./lisflood2/lisflood_processing.cpp:1616:				memcpy(rain_grid + dest_row_index, Arrptr->Rainmask + source_row_index, source_bytes_per_row);
./lisflood2/lisflood_processing.cpp:1621:				memcpy(dist_infil_grid + dest_row_index, Arrptr->dist_infiltration+ source_row_index, source_bytes_per_row);
./lisflood2/lisflood_processing.cpp:1632:			//memcpy(SGC_width_grid + dest_row_index, Arrptr->SGCwidth + source_row_index, source_bytes_per_row);
./lisflood2/lisflood_processing.cpp:1634:			memcpy(SGC_BankFullHeight_grid + dest_row_index, Arrptr->SGCbfH + source_row_index, source_bytes_per_row);
./lisflood2/lisflood_processing.cpp:1637:			//memcpy(ChanMask_grid + dest_row_index, Arrptr->ChanMask + source_row_index, sizeof(int) * grid_cols);
./lisflood2/lisflood_processing.cpp:1640:			//memcpy(SGC_BankFullVolume_grid + dest_row_index, Arrptr->SGCbfV + source_row_index, source_bytes_per_row);
./lisflood2/lisflood_processing.cpp:1643:			//memcpy(SGC_c_grid + dest_row_index, Arrptr->SGCc + source_row_index, source_bytes_per_row);
./lisflood2/lisflood_processing.cpp:1649:			//	memcpy(SGC_mannings + dest_row_index, Arrptr->SGCManningsn + source_row_index, source_bytes_per_row);
./lisflood2/lisflood_processing.cpp:1653:			//memcpy(SGC_group_grid + dest_row_index, Arrptr->SGCgroup + source_row_index, sizeof(int) * grid_cols);
./lisflood2/lisflood_processing.cpp:1659:			dx_col[j] = Arrptr->dx[source_row_index];
./lisflood2/lisflood_processing.cpp:1660:			dy_col[j] = Arrptr->dy[source_row_index];
./lisflood2/lisflood_processing.cpp:1661:			cell_area_col[j] = Arrptr->dA[source_row_index];
./lisflood2/lisflood_processing.cpp:1662:			//memcpy(dx_col + dest_row_index, Arrptr->dx + source_row_index, source_bytes_per_row);
./lisflood2/lisflood_processing.cpp:1663:			//memcpy(dy_col + dest_row_index, Arrptr->dy + source_row_index, source_bytes_per_row);
./lisflood2/lisflood_processing.cpp:1688:				if (Arrptr->Manningsn != NULL)
./lisflood2/lisflood_processing.cpp:1690:					fn_x = C(0.5)*(Arrptr->Manningsn[source_index] + Arrptr->Manningsn[source_index + 1]);
./lisflood2/lisflood_processing.cpp:1702:					if (Arrptr->Manningsn != NULL)
./lisflood2/lisflood_processing.cpp:1704:						fn_y = C(0.5)*(Arrptr->Manningsn[source_index] + Arrptr->Manningsn[source_index + grid_cols]);
./lisflood2/lisflood_processing.cpp:1717:					dx_col[j + 1] = Arrptr->dx[source_row_index];
./lisflood2/lisflood_processing.cpp:1718:					dy_col[j + 1] = Arrptr->dy[source_row_index];
./lisflood2/lisflood_processing.cpp:1719:					cell_area_col[j + 1] = Arrptr->dA[source_row_index];
./lisflood2/lisflood_processing.cpp:1784:	memory_free_legacy(&Arrptr->Weir_Identx); //Weir_Identx converted to list, grid no longer needed
./lisflood2/lisflood_processing.cpp:1785:	memory_free_legacy(&Arrptr->Weir_Identy); //Weir_Identy converted to list, grid no longer needed
./lisflood2/lisflood_processing.cpp:1788:	memory_free_legacy(&Arrptr->FlowDir);
./lisflood2/lisflood_processing.cpp:1789:	memory_free_legacy(&Arrptr->RouteInt);
./lisflood2/lisflood_processing.cpp:1790:	memory_free_legacy(&Arrptr->H);
./lisflood2/lisflood_processing.cpp:1791:	//memory_free_legacy(& Arrptr->H);
./lisflood2/lisflood_processing.cpp:1792:	memory_free_legacy(&Arrptr->DEM);
./lisflood2/lisflood_processing.cpp:1793:	memory_free_legacy(&Arrptr->DEM);
./lisflood2/lisflood_processing.cpp:1794:	if (Arrptr->Manningsn != NULL)
./lisflood2/lisflood_processing.cpp:1795:		memory_free_legacy(&Arrptr->Manningsn);
./lisflood2/lisflood_processing.cpp:1796:	if (Arrptr->SGCManningsn != NULL)
./lisflood2/lisflood_processing.cpp:1797:		memory_free_legacy(&Arrptr->SGCManningsn);
./lisflood2/lisflood_processing.cpp:1800:	memory_free_legacy(&Arrptr->QxSGold);
./lisflood2/lisflood_processing.cpp:1801:	memory_free_legacy(&Arrptr->QySGold);
./lisflood2/lisflood_processing.cpp:1803:	memory_free_legacy(&Arrptr->SGCwidth);
./lisflood2/lisflood_processing.cpp:1804:	memory_free_legacy(&Arrptr->SGCz);
./lisflood2/lisflood_processing.cpp:1805:	memory_free_legacy(&Arrptr->SGCc);
./lisflood2/lisflood_processing.cpp:1806:	memory_free_legacy(&Arrptr->SGCbfH);
./lisflood2/lisflood_processing.cpp:1807:	memory_free_legacy(&Arrptr->SGCbfV);
./lisflood2/lisflood_processing.cpp:1809:	memory_free_legacy(&Arrptr->dx);
./lisflood2/lisflood_processing.cpp:1810:	memory_free_legacy(&Arrptr->dy);
./lisflood2/lisflood_processing.cpp:1811:	memory_free_legacy(&Arrptr->dA);
./lisflood2/lisflood_processing.cpp:1965:			Super_linksptr->DEM_z[i] = Arrptr->DEM[p0];
./lisflood2/lisflood_processing.cpp:1967:			Super_linksptr->SGC_z[i] = Arrptr->SGCz[p0];
./lisflood2/lisflood_processing.cpp:1968:			Super_linksptr->SGC_bfH[i] = Arrptr->SGCbfH[p0];
./lisflood2/lisflood_processing.cpp:1992:			if (Arrptr->ChanMask[p0] > 0) // ChanMask cell
./lisflood2/lisflood_processing.cpp:1994:				if (Arrptr->SGCwidth[p0] > C(0.0)) // identify if sub-grid channel cells // store location
./lisflood2/lisflood_processing.cpp:1998:					tmp_z_SGC[n_SGC_under_mask] = Arrptr->SGCz[p0];
./lisflood2/lisflood_processing.cpp:1999:					tmp_bfH[n_SGC_under_mask] = Arrptr->SGCbfH[p0];
./lisflood2/lisflood_processing.cpp:2003:			else if (Arrptr->SGCwidth[p0] == C(0.0))// 2D domain cell ... identify all locations on a ChanMask edge that do not include a sub-grid channel	 
./lisflood2/lisflood_processing.cpp:2010:				if (j > 0 && Arrptr->ChanMask[p0 - Parptr->xsz] > 0)
./lisflood2/lisflood_processing.cpp:2012:					adjacent_to_chanmask = 1; dx_n = Arrptr->dy[p0]; w_n = Arrptr->dx[p0];
./lisflood2/lisflood_processing.cpp:2015:				if (j + 1 < Parptr->ysz && Arrptr->ChanMask[p0 + Parptr->xsz] > 0)
./lisflood2/lisflood_processing.cpp:2017:					adjacent_to_chanmask = 1; dx_s = Arrptr->dy[p0]; w_s = Arrptr->dx[p0];
./lisflood2/lisflood_processing.cpp:2020:				if (i < Parptr->xsz - 1 && Arrptr->ChanMask[p0 + 1] > 0)
./lisflood2/lisflood_processing.cpp:2022:					adjacent_to_chanmask = 1; dx_e = Arrptr->dx[p0]; w_e = Arrptr->dy[p0];
./lisflood2/lisflood_processing.cpp:2025:				if (i > 0 && Arrptr->ChanMask[p0 - 1] > 0)
./lisflood2/lisflood_processing.cpp:2027:					adjacent_to_chanmask = 1; dx_w = Arrptr->dx[p0]; w_w = Arrptr->dy[p0];
./lisflood2/lisflood_processing.cpp:2036:					tmp_z_2D[n_links] = Arrptr->DEM[p0]; // DEM z
./lisflood2/lisflood_processing.cpp:2037:					if (Arrptr->Manningsn != NULL)   tmp_gn2[n_links] = (Arrptr->Manningsn[p0] * Arrptr->Manningsn[p0]); // Manning's n
./lisflood2/sgm_fast.cpp:463:	//h1 = Arrptr->H[Arrptr->FlowDir[p0]] - Arrptr->SGCbfH[Arrptr->FlowDir[p0]];
./lisflood2/sgm_fast.cpp:469:	//z0 = Arrptr->DEM[p0]; //cell DEM height
./lisflood2/sgm_fast.cpp:470:	//z1 = Arrptr->DEM[Arrptr->FlowDir[p0]]; //lowest neighbour cell DEM height 
./lisflood2/sgm_fast.cpp:4145:			NUMERIC_TYPE delta = h_tmp - Arrptr->H[index_old];
./lisflood2/sgm_fast.cpp:4149:				printf("h new: %" NUM_FMT" original:%" NUM_FMT" (%.4e) \n", h_tmp, Arrptr->H[index_old], delta);
./lisflood2/sgm_fast.cpp:4154:				delta = volume_grid[index_new] - Arrptr->SGCVol[index_old];
./lisflood2/sgm_fast.cpp:4155:				printf("vol new: %" NUM_FMT" original:%" NUM_FMT" (%.4e) \n", volume_grid[index_new], Arrptr->SGCVol[index_old], delta);
./lisflood2/sgm_fast.cpp:4157:				//printf("vol new: %" NUM_FMT" original:%" NUM_FMT" (%.4e) \n", volume_grid[index_new], Arrptr->SGCbfH[index_old], delta);
./lisflood2/sgm_fast.cpp:4305:							NUMERIC_TYPE delta = Qy_grid[index_new_q] - Arrptr->Qy[index_old_q];
./lisflood2/sgm_fast.cpp:4316:								NUMERIC_TYPE q_old_m3 = (Arrptr->Qyold[index_old_q] * dx_col[j]);
./lisflood2/sgm_fast.cpp:4318:								printf("Qy    new: %" NUM_FMT" original:%" NUM_FMT" (%.4e) \n", Qy_grid[index_new_q], Arrptr->Qy[index_old_q], delta);
./lisflood2/sgm_fast.cpp:4323:								NUMERIC_TYPE old_non_fp = Arrptr->Qy[index_old_q] - q_old_m3;
./lisflood2/sgm_fast.cpp:4338:							NUMERIC_TYPE delta = Qx_grid[index_new_q] - Arrptr->Qx[index_old_q];
./lisflood2/sgm_fast.cpp:4349:								NUMERIC_TYPE q_old_m3 = (Arrptr->Qxold[index_old_q] * dy_col[j]);
./lisflood2/sgm_fast.cpp:4351:								printf("Qx    new: %" NUM_FMT" original:%" NUM_FMT" (%.4e) \n", Qx_grid[index_new_q], Arrptr->Qx[index_old_q], delta);
./lisflood2/sgm_fast.cpp:4356:								NUMERIC_TYPE old_non_fp = Arrptr->Qx[index_old_q] - q_old_m3;
./lisflood2/sgm_fast.cpp:4373:								NUMERIC_TYPE delta = maxVc_grid[index_new] - Arrptr->maxVc[index_old];
./lisflood2/sgm_fast.cpp:4391:							NUMERIC_TYPE delta = h_tmp - Arrptr->H[index_old];
./lisflood2/sgm_fast.cpp:4396:								printf("h new: %" NUM_FMT" original:%" NUM_FMT" (%.4e) \n", h_tmp, Arrptr->H[index_old], delta);
./lisflood2/sgm_fast.cpp:4404:								delta = volume_grid[index_new] - Arrptr->SGCVol[index_old];
./lisflood2/sgm_fast.cpp:4405:								printf("vol new: %" NUM_FMT" original:%" NUM_FMT" (%.4e) \n", volume_grid[index_new], Arrptr->SGCVol[index_old], delta);
./lisflood2/sgm_fast.cpp:4407:								//printf("vol new: %" NUM_FMT" original:%" NUM_FMT" (%.4e) \n", volume_grid[index_new], Arrptr->SGCbfH[index_old], delta);
./lisflood2/sgm_fast.cpp:4429:								delta = Qx_grid[index_new_q] - Arrptr->Qx[index_old_q];
./lisflood2/sgm_fast.cpp:4430:								q_old_m3 = (Arrptr->Qxold[index_old_q] * dy_col[j]);
./lisflood2/sgm_fast.cpp:4431:								printf("Qx    new: %" NUM_FMT" original:%" NUM_FMT" (%.4e) \n", Qx_grid[index_new_q], Arrptr->Qx[index_old_q], delta);
./lisflood2/sgm_fast.cpp:4435:								old_non_fp = Arrptr->Qx[index_old_q] - q_old_m3;
./lisflood2/sgm_fast.cpp:4439:								q_total_old += Arrptr->Qx[index_old_q];
./lisflood2/sgm_fast.cpp:4445:								delta = Qx_grid[index_new_q] - Arrptr->Qx[index_old_q];
./lisflood2/sgm_fast.cpp:4446:								q_old_m3 = (Arrptr->Qxold[index_old_q] * dy_col[j]);
./lisflood2/sgm_fast.cpp:4447:								printf("Qx    new: %" NUM_FMT" original:%" NUM_FMT" (%.4e) \n", Qx_grid[index_new_q], Arrptr->Qx[index_old_q], delta);
./lisflood2/sgm_fast.cpp:4452:								old_non_fp = Arrptr->Qx[index_old_q] - q_old_m3;
./lisflood2/sgm_fast.cpp:4456:								q_total_old -= Arrptr->Qx[index_old_q];
./lisflood2/sgm_fast.cpp:4462:								delta = Qy_grid[index_new_q] - Arrptr->Qy[index_old_q];
./lisflood2/sgm_fast.cpp:4463:								q_old_m3 = (Arrptr->Qyold[index_old_q] * dx_col[j]);
./lisflood2/sgm_fast.cpp:4464:								printf("Qy    new: %" NUM_FMT" original:%" NUM_FMT" (%.4e) \n", Qy_grid[index_new_q], Arrptr->Qy[index_old_q], delta);
./lisflood2/sgm_fast.cpp:4469:								old_non_fp = Arrptr->Qy[index_old_q] - q_old_m3;
./lisflood2/sgm_fast.cpp:4473:								q_total_old += Arrptr->Qy[index_old_q];
./lisflood2/sgm_fast.cpp:4478:								delta = Qy_grid[index_new_q] - Arrptr->Qy[index_old_q];
./lisflood2/sgm_fast.cpp:4479:								q_old_m3 = (Arrptr->Qyold[index_old_q] * dx_col[j]);
./lisflood2/sgm_fast.cpp:4480:								printf("Qy    new: %" NUM_FMT" original:%" NUM_FMT" (%.4e) \n", Qy_grid[index_new_q], Arrptr->Qy[index_old_q], delta);
./lisflood2/sgm_fast.cpp:4484:								old_non_fp = Arrptr->Qy[index_old_q] - q_old_m3;
./lisflood2/sgm_fast.cpp:4488:								q_total_old -= Arrptr->Qy[index_old_q];
./test/test_fv1.cpp:21:	Arrptr->DEM = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./test/test_fv1.cpp:22:	Arrptr->DEM[0*Parptr->xsz + 0] = C(1.0);
./test/test_fv1.cpp:23:	Arrptr->DEM[0*Parptr->xsz + 1] = C(4.0);
./test/test_fv1.cpp:24:	Arrptr->DEM[1*Parptr->xsz + 0] = C(3.0);
./test/test_fv1.cpp:25:	Arrptr->DEM[1*Parptr->xsz + 1] = C(2.0);
./test/test_fv1.cpp:31:	CHECK( Arrptr->Zstar_x[0*(Parptr->xsz+1) + 1] == approx(C(4.0)) );
./test/test_fv1.cpp:32:	CHECK( Arrptr->Zstar_x[1*(Parptr->xsz+1) + 1] == approx(C(3.0)) );
./test/test_fv1.cpp:34:	CHECK( Arrptr->Zstar_y[1*(Parptr->xsz+1) + 0] == approx(C(3.0)) );
./test/test_fv1.cpp:35:	CHECK( Arrptr->Zstar_y[1*(Parptr->xsz+1) + 1] == approx(C(4.0)) );
./test/test_fv1.cpp:38:	CHECK( Arrptr->Zstar_x[0*(Parptr->xsz+1) + 0] == approx(C(1.0)) );
./test/test_fv1.cpp:39:	CHECK( Arrptr->Zstar_x[0*(Parptr->xsz+1) + 2] == approx(C(4.0)) );
./test/test_fv1.cpp:40:	CHECK( Arrptr->Zstar_x[1*(Parptr->xsz+1) + 0] == approx(C(3.0)) );
./test/test_fv1.cpp:41:	CHECK( Arrptr->Zstar_x[1*(Parptr->xsz+1) + 2] == approx(C(2.0)) );
./test/test_fv1.cpp:43:	CHECK( Arrptr->Zstar_y[0*(Parptr->xsz+1) + 0] == approx(C(1.0)) );
./test/test_fv1.cpp:44:	CHECK( Arrptr->Zstar_y[0*(Parptr->xsz+1) + 1] == approx(C(4.0)) );
./test/test_fv1.cpp:45:	CHECK( Arrptr->Zstar_y[2*(Parptr->xsz+1) + 0] == approx(C(3.0)) );
./test/test_fv1.cpp:46:	CHECK( Arrptr->Zstar_y[2*(Parptr->xsz+1) + 1] == approx(C(2.0)) );
./test/test_fv1.cpp:48:	memory_free_legacy(&Arrptr->DEM);
./test/test_fv1.cpp:62:	Arrptr->DEM = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./test/test_fv1.cpp:63:	Arrptr->DEM[0*Parptr->xsz + 0] = C(1.0);
./test/test_fv1.cpp:64:	Arrptr->DEM[0*Parptr->xsz + 1] = C(3.0);
./test/test_fv1.cpp:65:	Arrptr->DEM[1*Parptr->xsz + 0] = C(2.0);
./test/test_fv1.cpp:66:	Arrptr->DEM[1*Parptr->xsz + 1] = C(0.0);
./test/test_fv1.cpp:68:	Arrptr->H = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./test/test_fv1.cpp:69:	Arrptr->H[0*Parptr->xsz + 0] = C(0.5);
./test/test_fv1.cpp:70:	Arrptr->H[0*Parptr->xsz + 1] = C(1.0);
./test/test_fv1.cpp:71:	Arrptr->H[1*Parptr->xsz + 0] = C(1.0);
./test/test_fv1.cpp:72:	Arrptr->H[1*Parptr->xsz + 1] = C(0.0);
./test/test_fv1.cpp:78:	CHECK( Arrptr->Hstar_neg_x[0*Parptr->xsz + 0] == approx(C(0.0)) );
./test/test_fv1.cpp:79:	CHECK( Arrptr->Hstar_neg_x[0*Parptr->xsz + 1] == approx(C(1.0)) );
./test/test_fv1.cpp:81:	CHECK( Arrptr->Hstar_pos_x[0*Parptr->xsz + 0] == approx(C(0.5)) );
./test/test_fv1.cpp:82:	CHECK( Arrptr->Hstar_pos_x[0*Parptr->xsz + 1] == approx(C(1.0)) );
./test/test_fv1.cpp:84:	CHECK( Arrptr->Hstar_neg_y[0*Parptr->xsz + 0] == approx(C(0.5)) );
./test/test_fv1.cpp:85:	CHECK( Arrptr->Hstar_neg_y[1*Parptr->xsz + 0] == approx(C(1.0)) );
./test/test_fv1.cpp:87:	CHECK( Arrptr->Hstar_pos_y[0*Parptr->xsz + 0] == approx(C(0.0)) );
./test/test_fv1.cpp:88:	CHECK( Arrptr->Hstar_pos_y[1*Parptr->xsz + 0] == approx(C(1.0)) );
./test/test_fv1.cpp:90:	memory_free_legacy(&Arrptr->DEM);
./test/test_fv1.cpp:91:	memory_free_legacy(&Arrptr->H);
./test/test_fv1.cpp:109:	Arrptr->DEM = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./test/test_fv1.cpp:110:	Arrptr->DEM[0*Parptr->xsz + 0] = C(1.0);
./test/test_fv1.cpp:111:	Arrptr->DEM[0*Parptr->xsz + 1] = C(3.0);
./test/test_fv1.cpp:112:	Arrptr->DEM[1*Parptr->xsz + 0] = C(2.0);
./test/test_fv1.cpp:113:	Arrptr->DEM[1*Parptr->xsz + 1] = C(0.0);
./test/test_fv1.cpp:115:	Arrptr->H = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./test/test_fv1.cpp:116:	Arrptr->H[0*Parptr->xsz + 0] = C(0.5);
./test/test_fv1.cpp:117:	Arrptr->H[0*Parptr->xsz + 1] = C(1.5);
./test/test_fv1.cpp:118:	Arrptr->H[1*Parptr->xsz + 0] = C(1.0);
./test/test_fv1.cpp:119:	Arrptr->H[1*Parptr->xsz + 1] = C(0.0);
./test/test_fv1.cpp:122:	Arrptr->HU[0*Parptr->xsz + 0] = C(0.5);
./test/test_fv1.cpp:123:	Arrptr->HU[0*Parptr->xsz + 1] = C(2.0);
./test/test_fv1.cpp:124:	Arrptr->HU[1*Parptr->xsz + 0] = C(1.5);
./test/test_fv1.cpp:125:	Arrptr->HU[1*Parptr->xsz + 1] = C(0.0);
./test/test_fv1.cpp:142:	memory_free_legacy(&Arrptr->DEM);
./test/test_fv1.cpp:143:	memory_free_legacy(&Arrptr->H);
./test/test_fv1.cpp:157:	Arrptr->DEM = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./test/test_fv1.cpp:158:	Arrptr->DEM[0*Parptr->xsz + 0] = C(1.0);
./test/test_fv1.cpp:159:	Arrptr->DEM[0*Parptr->xsz + 1] = C(4.0);
./test/test_fv1.cpp:160:	Arrptr->DEM[1*Parptr->xsz + 0] = C(3.0);
./test/test_fv1.cpp:161:	Arrptr->DEM[1*Parptr->xsz + 1] = C(2.0);
./test/test_fv1.cpp:163:	Arrptr->H = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./test/test_fv1.cpp:164:	Arrptr->H[0*Parptr->xsz + 0] = C(0.5);
./test/test_fv1.cpp:165:	Arrptr->H[0*Parptr->xsz + 1] = C(1.0);
./test/test_fv1.cpp:166:	Arrptr->H[1*Parptr->xsz + 0] = C(1.0);
./test/test_fv1.cpp:167:	Arrptr->H[1*Parptr->xsz + 1] = C(0.0);
./test/test_fv1.cpp:184:	memory_free_legacy(&Arrptr->DEM);
./test/test_fv1.cpp:185:	memory_free_legacy(&Arrptr->H);
./test/test_fv1.cpp:204:	Arrptr->DEM = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./test/test_fv1.cpp:205:	Arrptr->DEM[0*Parptr->xsz + 0] = C(2.0);
./test/test_fv1.cpp:206:	Arrptr->DEM[0*Parptr->xsz + 1] = C(4.0);
./test/test_fv1.cpp:208:	Arrptr->H = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./test/test_fv1.cpp:209:	Arrptr->H[0*Parptr->xsz + 0] = C(1.0);
./test/test_fv1.cpp:210:	Arrptr->H[0*Parptr->xsz + 1] = C(0.0);
./test/test_fv1.cpp:213:	Arrptr->Hstar_neg_x[0*Parptr->xsz + 0] = C(0.5);
./test/test_fv1.cpp:214:	Arrptr->Hstar_pos_x[0*Parptr->xsz + 0] = C(1.5);
./test/test_fv1.cpp:220:	memory_free_legacy(&Arrptr->DEM);
./test/test_fv1.cpp:221:	memory_free_legacy(&Arrptr->H);
./test/test_dg2.cpp:20:	Arrptr->H = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./test/test_dg2.cpp:23:	Arrptr->H[0*Parptr->xsz + 0] = C(3.5);
./test/test_dg2.cpp:24:	Arrptr->H1x[0*Parptr->xsz + 0] = C(0.5)/SQRT(C(3.0));
./test/test_dg2.cpp:25:	Arrptr->H1y[0*Parptr->xsz + 0] = C(1.0)/SQRT(C(3.0));
./test/test_dg2.cpp:27:	CHECK( limit_neg(Arrptr->H, Arrptr->H1x, Parptr, 0, 0) == approx(4.0) );
./test/test_dg2.cpp:28:	CHECK( limit_neg(Arrptr->H, Arrptr->H1y, Parptr, 0, 0) == approx(4.5) );
./test/test_dg2.cpp:29:	CHECK( limit_pos(Arrptr->H, Arrptr->H1x, Parptr, 0, 0) == approx(3.0) );
./test/test_dg2.cpp:30:	CHECK( limit_pos(Arrptr->H, Arrptr->H1y, Parptr, 0, 0) == approx(2.5) );
./test/test_dg2.cpp:32:	memory_free_legacy(&Arrptr->H);
./test/test_dg2.cpp:46:	Arrptr->H = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./test/test_dg2.cpp:49:	Arrptr->H[0*Parptr->xsz + 0] = C(3.5);
./test/test_dg2.cpp:50:	Arrptr->H1x[0*Parptr->xsz + 0] = C(0.5);
./test/test_dg2.cpp:51:	Arrptr->H1y[0*Parptr->xsz + 0] = C(1.0);
./test/test_dg2.cpp:53:	CHECK( gauss_lower(Arrptr->H, Arrptr->H1x, Parptr, 0, 0) == approx(3.0) );
./test/test_dg2.cpp:54:	CHECK( gauss_lower(Arrptr->H, Arrptr->H1y, Parptr, 0, 0) == approx(2.5) );
./test/test_dg2.cpp:55:	CHECK( gauss_upper(Arrptr->H, Arrptr->H1x, Parptr, 0, 0) == approx(4.0) );
./test/test_dg2.cpp:56:	CHECK( gauss_upper(Arrptr->H, Arrptr->H1y, Parptr, 0, 0) == approx(4.5) );
./test/test_dg2.cpp:58:	memory_free_legacy(&Arrptr->H);
./test/test_dg2.cpp:76:	Arrptr->H = memory_allocate_numeric_legacy(Parptr->xsz*Parptr->ysz);
./test/test_dg2.cpp:79:	Arrptr->H[0*Parptr->xsz + 0] = C(1.5);
./test/test_dg2.cpp:80:	Arrptr->HU[0*Parptr->xsz + 0] = C(4.0);
./test/test_dg2.cpp:81:	Arrptr->HU1x[0*Parptr->xsz + 0] = C(0.5)/SQRT(C(3.0));
./test/test_dg2.cpp:82:	Arrptr->HU1y[0*Parptr->xsz + 0] = C(1.0)/SQRT(C(3.0));
./test/test_dg2.cpp:83:	Arrptr->H1x[0*Parptr->xsz + 0] = C(1.5)/SQRT(C(3.0));
./test/test_dg2.cpp:84:	Arrptr->H1y[0*Parptr->xsz + 0] = C(-1.0)/SQRT(C(3.0));
./test/test_dg2.cpp:85:	Arrptr->Hstar_neg_x[0*Parptr->xsz + 0] = C(1.6);
./test/test_dg2.cpp:86:	Arrptr->Hstar_pos_x[0*Parptr->xsz + 0] = C(10.0);
./test/test_dg2.cpp:87:	Arrptr->Hstar_neg_y[0*Parptr->xsz + 0] = C(0.8);
./test/test_dg2.cpp:88:	Arrptr->Hstar_pos_y[0*Parptr->xsz + 0] = C(1.5);
./test/test_dg2.cpp:91:	U.H = Arrptr->H;
./test/test_dg2.cpp:92:	U.H1x = Arrptr->H1x;
./test/test_dg2.cpp:93:	U.H1y = Arrptr->H1y;
./test/test_dg2.cpp:94:	U.HU = Arrptr->HU;
./test/test_dg2.cpp:95:	U.HU1x = Arrptr->HU1x;
./test/test_dg2.cpp:96:	U.HU1y = Arrptr->HU1y;
./test/test_dg2.cpp:100:	CHECK( Arrptr->HUstar_neg_x[0*Parptr->xsz + 0] == approx(2.4) );
./test/test_dg2.cpp:101:	CHECK( Arrptr->HUstar_pos_x[0*Parptr->xsz + 0] == approx(0.0) );
./test/test_dg2.cpp:102:	CHECK( Arrptr->HUstar_neg_y[0*Parptr->xsz + 0] == approx(8.0) );
./test/test_dg2.cpp:103:	CHECK( Arrptr->HUstar_pos_y[0*Parptr->xsz + 0] == approx(1.8) );
./test/test_dg2.cpp:105:	memory_free_legacy(&Arrptr->H);
./weir_flow.cpp:57:  z0=Arrptr->DEM[p0];
./weir_flow.cpp:58:  z1=Arrptr->DEM[p1];
./weir_flow.cpp:59:  h0=Arrptr->H[p0];
./weir_flow.cpp:60:  h1=Arrptr->H[p1];
./weir_flow.cpp:61:  weir_id=Arrptr->Weir_Identx[i+1+j*(Parptr->xsz+1)];
./weir_flow.cpp:65:	  if (Arrptr->SGCwidth[p0] > C(0.0)) z0=Arrptr->SGCz[p0];
./weir_flow.cpp:66:	  if (Arrptr->SGCwidth[p1] > C(0.0)) z1=Arrptr->SGCz[p1];
./weir_flow.cpp:75:  if (Arrptr->Weir_Typ[weir_id] == EWeir_Weir) // simulate a weir
./weir_flow.cpp:79:		if ((h0+z0)>Arrptr->Weir_hc[weir_id]  && h0>0) // check depth is above weir and that the cell is wet
./weir_flow.cpp:81:		    if(Arrptr->Weir_Fixdir[weir_id]==0 || Arrptr->Weir_Fixdir[weir_id]==2) // check for one-directional flow (culvert)
./weir_flow.cpp:83:				hu=h0+z0-Arrptr->Weir_hc[weir_id]; // upstream head
./weir_flow.cpp:84:				hd=h1+z1-Arrptr->Weir_hc[weir_id]; // downstream head
./weir_flow.cpp:85:				if((hd/hu)<Arrptr->Weir_m[weir_id]) 
./weir_flow.cpp:86:					Q=Arrptr->Weir_Cd[weir_id]*Arrptr->Weir_w[weir_id]*pow(hu,(C(1.5))); // Free flow
./weir_flow.cpp:88:					Q=Arrptr->Weir_Cd[weir_id]*Arrptr->Weir_w[weir_id]*hu*(sqrt(hu-hd))/sqrt(Arrptr->Weir_m[weir_id]); // Drowned flow
./weir_flow.cpp:95:		if ((h1+z1)>Arrptr->Weir_hc[weir_id] && h1>0) // check depth is above weir and that the cell is wet
./weir_flow.cpp:97:			if(Arrptr->Weir_Fixdir[weir_id]==0 || Arrptr->Weir_Fixdir[weir_id]==4) // check for one-directional flow (culvert)
./weir_flow.cpp:99:				hu=h1+z1-Arrptr->Weir_hc[weir_id]; // upstream head
./weir_flow.cpp:100:				hd=h0+z0-Arrptr->Weir_hc[weir_id]; // downstream head
./weir_flow.cpp:101:				if((hd/hu)<Arrptr->Weir_m[weir_id]) 
./weir_flow.cpp:102:					Q=-Arrptr->Weir_Cd[weir_id]*Arrptr->Weir_w[weir_id]*pow(hu,(C(1.5))); // Free flow
./weir_flow.cpp:104:					Q=-Arrptr->Weir_Cd[weir_id]*Arrptr->Weir_w[weir_id]*hu*(sqrt(hu-hd))/sqrt(Arrptr->Weir_m[weir_id]); // Drowned flow
./weir_flow.cpp:109:  else if (Arrptr->Weir_Typ[weir_id] == EWeir_Bridge) // simulate a bridge
./weir_flow.cpp:115:		Tz = Arrptr->Weir_m[weir_id];
./weir_flow.cpp:116:		Soffit = Arrptr->Weir_hc[weir_id];
./weir_flow.cpp:117:		Cd = Arrptr->Weir_Cd[weir_id];
./weir_flow.cpp:118:		Width = Arrptr->Weir_w[weir_id];
./weir_flow.cpp:126:		cn = C(0.5)* (SGCptr->SGCn[Arrptr->SGCgroup[p0]] + SGCptr->SGCn[Arrptr->SGCgroup[p1]]); // mean mannings (note n2)
./weir_flow.cpp:129:		Sf=-dh/Arrptr->dx[p0]; // CCS added for subgrid lat long compatibility.
./weir_flow.cpp:136:		Qoc=(Arrptr->QxSGold[pq0]-g*A*dt*Sf) / (1+dt*g*cn*fabs(Arrptr->QxSGold[pq0]) / (pow(R,C(4.0)/C(3.0))*A)); // note mannings is squared by preprocessor
./weir_flow.cpp:141:			usVel = Arrptr->QxSGold[pQus] / (h0*Arrptr->SGCwidth[p0]); // MT calculate upstream velocity
./weir_flow.cpp:147:			usVel = Arrptr->QxSGold[pQds] / (h1*Arrptr->SGCwidth[p1]); // MT calculate upstream velocity
./weir_flow.cpp:175:  if (Statesptr->SGC==ON) Arrptr->QxSGold[pq0] = Q;
./weir_flow.cpp:216:  z0=Arrptr->DEM[p0];
./weir_flow.cpp:217:  z1=Arrptr->DEM[p1];
./weir_flow.cpp:218:  h0=Arrptr->H[p0];
./weir_flow.cpp:219:  h1=Arrptr->H[p1];
./weir_flow.cpp:220:  weir_id=Arrptr->Weir_Identy[i+(j+1)*(Parptr->xsz+1)];
./weir_flow.cpp:224:	  if (Arrptr->SGCwidth[p0] > C(0.0)) z0=Arrptr->SGCz[p0];
./weir_flow.cpp:225:	  if (Arrptr->SGCwidth[p1] > C(0.0)) z1=Arrptr->SGCz[p1];
./weir_flow.cpp:231:  if (Arrptr->Weir_Typ[weir_id] == EWeir_Weir)
./weir_flow.cpp:235:      if ((h0+z0)>Arrptr->Weir_hc[weir_id] && h0>0) // check depth is above weir and that the cell is wet
./weir_flow.cpp:237:		  if(Arrptr->Weir_Fixdir[weir_id]==0 || Arrptr->Weir_Fixdir[weir_id]==3)  // check for one-directional flow (culvert)
./weir_flow.cpp:239:			hu=h0+z0-Arrptr->Weir_hc[weir_id]; // upstream head
./weir_flow.cpp:240:			hd=h1+z1-Arrptr->Weir_hc[weir_id]; // downstream head
./weir_flow.cpp:241:			if((hd/hu)<Arrptr->Weir_m[weir_id]) 
./weir_flow.cpp:242:				Q=Arrptr->Weir_Cd[weir_id]*Arrptr->Weir_w[weir_id]*pow(hu,(C(1.5))); // Free flow
./weir_flow.cpp:244:				Q=Arrptr->Weir_Cd[weir_id]*Arrptr->Weir_w[weir_id]*(hu)*(sqrt(hu-hd))/sqrt(Arrptr->Weir_m[weir_id]); // Drowned flow
./weir_flow.cpp:251:      if ((h1+z1)>Arrptr->Weir_hc[weir_id] && h1>0) // check depth is above weir and that the cell is wet
./weir_flow.cpp:253:		  if(Arrptr->Weir_Fixdir[weir_id]==0 || Arrptr->Weir_Fixdir[weir_id]==1)  // check for one-directional flow (culvert)
./weir_flow.cpp:255:			hu=h1+z1-Arrptr->Weir_hc[weir_id]; // upstram head
./weir_flow.cpp:256:			hd=h0+z0-Arrptr->Weir_hc[weir_id]; // downstream head
./weir_flow.cpp:258:			if((hd/hu)<Arrptr->Weir_m[weir_id]) 
./weir_flow.cpp:259:				Q=-Arrptr->Weir_Cd[weir_id]*Arrptr->Weir_w[weir_id]*pow(hu,(C(1.5))); // Free flow
./weir_flow.cpp:261:				Q=-Arrptr->Weir_Cd[weir_id]*Arrptr->Weir_w[weir_id]*(hu)*(sqrt(hu-hd))/sqrt(Arrptr->Weir_m[weir_id]); // Drowned flow
./weir_flow.cpp:267:  else if (Arrptr->Weir_Typ[weir_id] == EWeir_Bridge && Statesptr->SGC == ON) // simulate a bridge
./weir_flow.cpp:274:		Tz = Arrptr->Weir_m[weir_id];
./weir_flow.cpp:275:		Soffit = Arrptr->Weir_hc[weir_id];
./weir_flow.cpp:276:		Cd = Arrptr->Weir_Cd[weir_id];
./weir_flow.cpp:277:		Width = Arrptr->Weir_w[weir_id];
./weir_flow.cpp:285:	    cn = C(0.5)* (SGCptr->SGCn[Arrptr->SGCgroup[p0]] + SGCptr->SGCn[Arrptr->SGCgroup[p1]]); // mean mannings (note n2)
./weir_flow.cpp:288:		Sf=-dh/Arrptr->dy[p0]; // CCS added for sub grid lat-long compatibility.
./weir_flow.cpp:295:		Qoc=(Arrptr->QySGold[pq0]-g*A*dt*Sf) / (1+dt*g*cn*fabs(Arrptr->QySGold[pq0]) / (pow(R,C(4.0)/C(3.0))*A)); // note mannings is squared
./weir_flow.cpp:300:			usVel = Arrptr->QySGold[pQus] / (h0*Arrptr->SGCwidth[p0]); // MT calculate upstream velocity
./weir_flow.cpp:306:			usVel = Arrptr->QySGold[pQds] / (h1*Arrptr->SGCwidth[p1]); // MT calculate upstream velocity
./weir_flow.cpp:335:  if (Statesptr->SGC==ON) Arrptr->QySGold[pq0] = Q;
./infevap.cpp:24:      if(Arrptr->ChanMask[i+j*Parptr->xsz]==-1) { //only on non-channel cells
./infevap.cpp:25:        h0=Arrptr->H[i+j*Parptr->xsz];
./infevap.cpp:37:          Arrptr->H[i+j*Parptr->xsz]=h0;
./infevap.cpp:56:  evap_rate=InterpolateTimeSeries(Arrptr->evap,Solverptr->t);//constant rate across whole floodplain
./infevap.cpp:64:      if(Arrptr->ChanMask[i+j*Parptr->xsz]==-1) 
./infevap.cpp:66:        h0=Arrptr->H[i+j*Parptr->xsz];
./infevap.cpp:77:          Arrptr->H[i+j*Parptr->xsz]=h0;
./infevap.cpp:96:  rain_rate=InterpolateTimeSeries(Arrptr->rain,Solverptr->t);//constant rate across whole floodplain
./infevap.cpp:107:		if(Arrptr->DEM[p0]!=DEM_NO_DATA)
./infevap.cpp:109:			h0=Arrptr->H[p0];
./infevap.cpp:118:			Arrptr->H[p0]=h0;			
./infevap.cpp:138:		Arrptr->RouteInt=memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz); // always create distributed RouteInt JCN
./infevap.cpp:153:			if (Arrptr->DEM[p0] != DEM_NO_DATA)
./infevap.cpp:165:				NUMERIC_TYPE dem_this = Arrptr->DEM[p0];
./infevap.cpp:166:				NUMERIC_TYPE north = (j - 1 >= 0) ? Arrptr->DEM[source_index_north] : DEM_NO_DATA;
./infevap.cpp:167:				NUMERIC_TYPE south = (j + 1 < Parptr->ysz) ? Arrptr->DEM[source_index_south] : DEM_NO_DATA;
./infevap.cpp:168:				NUMERIC_TYPE west = (i - 1 >= 0) ? Arrptr->DEM[source_index_west] : DEM_NO_DATA;
./infevap.cpp:169:				NUMERIC_TYPE east = (i + 1 < Parptr->xsz) ? Arrptr->DEM[source_index_east] : DEM_NO_DATA;
./infevap.cpp:172:				if (Statesptr->latlong==ON) {dx = Arrptr->dx[p0]; dy = Arrptr->dy[p0];}
./infevap.cpp:175:				if(north<=east && north<=south && north<=west && north<Arrptr->DEM[p0]) // flow to the north
./infevap.cpp:177:					if (Statesptr->weirs == ON && Arrptr->Weir_Identy[q_index_north] != -1)
./infevap.cpp:179:						Arrptr->FlowDir[p0] = p0;
./infevap.cpp:183:						Arrptr->FlowDir[p0] = i + (j - 1)*Parptr->xsz;
./infevap.cpp:187:							Routing_Speed = Parptr->Routing_Speed*sqrt((Arrptr->DEM[p0] - north) / dy); // If distributed routing is ON use slope dependent routing speed
./infevap.cpp:188:						Arrptr->RouteInt[p0] = dy / Routing_Speed; // calculate RouteInt
./infevap.cpp:191:				else if(east<=north && east<=south && east<=west && east<Arrptr->DEM[p0]) // flow to east
./infevap.cpp:193:					if (Statesptr->weirs == ON && Arrptr->Weir_Identx[q_index_east] != -1)
./infevap.cpp:195:						Arrptr->FlowDir[p0] = p0;
./infevap.cpp:199:						Arrptr->FlowDir[p0] = (i + 1) + j*Parptr->xsz;
./infevap.cpp:203:							Routing_Speed = Parptr->Routing_Speed*sqrt((Arrptr->DEM[p0] - east) / dx); // If distributed routing is ON use slope dependent routing speed
./infevap.cpp:204:						Arrptr->RouteInt[p0] = dx / Routing_Speed; // calculate RouteInt
./infevap.cpp:207:				else if(south<=north && south<=east && south<=west && south<Arrptr->DEM[p0]) // flow to south
./infevap.cpp:209:					if (Statesptr->weirs == ON && Arrptr->Weir_Identy[q_index_south] != -1)
./infevap.cpp:211:						Arrptr->FlowDir[p0] = p0;
./infevap.cpp:215:						Arrptr->FlowDir[p0] = i + (j + 1)*Parptr->xsz;
./infevap.cpp:219:							Routing_Speed = Parptr->Routing_Speed*sqrt((Arrptr->DEM[p0] - south) / dy); // If distributed routing is ON use slope dependent routing speed
./infevap.cpp:220:						Arrptr->RouteInt[p0] = dy / Routing_Speed; // calculate RouteInt
./infevap.cpp:223:				else if(west<=north && west<=east && west<=south && west<Arrptr->DEM[p0]) // flow to west
./infevap.cpp:225:					if (Statesptr->weirs == ON && Arrptr->Weir_Identx[q_index_west] != -1)
./infevap.cpp:227:						Arrptr->FlowDir[p0] = p0;
./infevap.cpp:231:						Arrptr->FlowDir[p0] = (i - 1) + j*Parptr->xsz;
./infevap.cpp:235:							Routing_Speed = Parptr->Routing_Speed*sqrt((Arrptr->DEM[p0] - west) / dx); // If distributed routing is ON use slope dependent routing speed
./infevap.cpp:236:						Arrptr->RouteInt[p0] = dx / Routing_Speed; // calculate RouteInt
./infevap.cpp:245:					Arrptr->FlowDir[p0] = p0;
./infevap.cpp:252:					if (Arrptr->SGCwidth[p0]>C(0.0))
./infevap.cpp:254:						Arrptr->FlowDir[p0]=p0; 
./infevap.cpp:286:			Arrptr->FlowDir[p0]=p0; // Set recipient cell to be source cell where boundary is present
./infevap.cpp:294:	  Arrptr->FlowDir[p0]=p0; // Set recipient cell to be source cell where boundary is present
./infevap.cpp:303:		Arrptr->Route_dH=memory_allocate_zero_numeric_legacy(Parptr->xsz*Parptr->ysz);
./infevap.cpp:317:		rain_rate=InterpolateTimeSeries(Arrptr->rain,Solverptr->t);//constant rate across whole floodplain
./infevap.cpp:331:			if (Arrptr->DEM[p0] != DEM_NO_DATA)
./infevap.cpp:335:					Arrptr->H[p0]+=cell_rain; // Add cell rainfall
./infevap.cpp:339:				if(Arrptr->H[p0]>0) // Only proceed with rest of loop if cell is wet:
./infevap.cpp:341:					z0=Arrptr->DEM[p0];
./infevap.cpp:342:					h0=Arrptr->H[p0];
./infevap.cpp:349:						z1=Arrptr->DEM[p1]; 
./infevap.cpp:350:						h1=Arrptr->H[p1];
./infevap.cpp:359:						z1=Arrptr->DEM[p1]; 
./infevap.cpp:360:						h1=Arrptr->H[p1];
./infevap.cpp:367:					h0=Arrptr->H[p0];//cell water height
./infevap.cpp:372:						h1=Arrptr->H[Arrptr->FlowDir[p0]]; //lowest neighbour cell water height 
./infevap.cpp:373:						z0=Arrptr->DEM[p0]; //cell DEM height
./infevap.cpp:374:						z1=Arrptr->DEM[Arrptr->FlowDir[p0]]; //lowest neighbour cell DEM height 
./infevap.cpp:384:						flow_fraction=Solverptr->Tstep/Arrptr->RouteInt[p0]; // fraction of cell volume to route in this time step
./infevap.cpp:389:						Arrptr->Route_dH[p0]-=flow; // Record change in H in source cell 
./infevap.cpp:390:						Arrptr->Route_dH[Arrptr->FlowDir[p0]]+=flow; // Record change in H in recipient cell
./infevap.cpp:404:			Arrptr->H[p0]+=Arrptr->Route_dH[p0];
./infevap.cpp:405:			Arrptr->Route_dH[p0]=C(0.0);
./ch_flow.cpp:60:			Arrptr->H[pi+pj*Parptr->xsz]=Parptr->ch_start_h; 
./ch_flow.cpp:175:				csp->JunctionH=Arrptr->H[pi+pj*Parptr->xsz];
./ch_flow.cpp:211:						Arrptr->H[csp->ChanX[nodes-1]+csp->ChanY[nodes-1]*Parptr->xsz]=CalcA(csp->ChanN[nodes-1],csp->Shalf[nodes-1],csp->ChanWidth[nodes-1],csp->ChanQ[nodes-1])
./ch_flow.cpp:216:						Arrptr->H[csp->ChanX[nodes-1]+csp->ChanY[nodes-1]*Parptr->xsz]=CalcA(csp->ChanN[nodes-1],sqrt(csp->Q_Val[nodes-1]),csp->ChanWidth[nodes-1],csp->ChanQ[nodes-1])
./ch_flow.cpp:223:					Arrptr->H[csp->ChanX[nodes-1]+csp->ChanY[nodes-1]*Parptr->xsz] = WSbc - Arrptr->DEM[csp->ChanX[nodes-1]+csp->ChanY[nodes-1]*Parptr->xsz];
./ch_flow.cpp:229:					if(chseg==low) Arrptr->H[csp->ChanX[nodes-1]+csp->ChanY[nodes-1]*Parptr->xsz] = WSbc - Arrptr->DEM[csp->ChanX[nodes-1]+csp->ChanY[nodes-1]*Parptr->xsz]; // CCS
./ch_flow.cpp:230:					else         Arrptr->H[csp->ChanX[nodes-1]+csp->ChanY[nodes-1]*Parptr->xsz] = WSbc - csp->JunctionDEM; //trib uses dummy junction node
./ch_flow.cpp:243:				Arrptr->H[pi+pj*Parptr->xsz]=Arrptr->H[pid+pjd*Parptr->xsz];
./ch_flow.cpp:244:				Elevds=Arrptr->DEM[pid+pjd*Parptr->xsz]+Arrptr->H[pid+pjd*Parptr->xsz];
./ch_flow.cpp:245:				Jds=CalcEnergySlope(csp->ChanN[i+1],csp->ChanWidth[i+1],Arrptr->H[pid+pjd*Parptr->xsz],csp->ChanQ[i+1]);
./ch_flow.cpp:246:				Eds=Elevds+pow(csp->ChanQ[i+1]/(csp->ChanWidth[i+1]*Arrptr->H[pid+pjd*Parptr->xsz]),2)*divg*Solverptr->dynsw;
./ch_flow.cpp:253:					Arrptr->H[pi+pj*Parptr->xsz]=Arrptr->H[pi+pj*Parptr->xsz]+dh*signR(err_d);
./ch_flow.cpp:254:					Elevus=Arrptr->DEM[pi+pj*Parptr->xsz]+Arrptr->H[pi+pj*Parptr->xsz];
./ch_flow.cpp:255:					Jus=CalcEnergySlope(csp->ChanN[i],csp->ChanWidth[i],Arrptr->H[pi+pj*Parptr->xsz],csp->ChanQ[i]);
./ch_flow.cpp:256:					Eus=Elevus+pow(csp->ChanQ[i]/(csp->ChanWidth[i]*Arrptr->H[pi+pj*Parptr->xsz]),2)*divg*Solverptr->dynsw;
./ch_flow.cpp:297:				Arrptr->H[pi+pj*Parptr->xsz]=CalcA(csp->ChanN[i],csp->Shalf[i],csp->ChanWidth[i],csp->ChanQ[i])/csp->ChanWidth[i]; // calc new area from this flow and calc h
./ch_flow.cpp:368:				else                           csp->A[i]=Arrptr->H[csp->ChanX[i]+csp->ChanY[i]*Parptr->xsz]*csp->ChanWidth[i]; // all other points
./ch_flow.cpp:393:				&& Arrptr->DEM[pi+pj*Parptr->xsz]+Arrptr->H[pi+pj*Parptr->xsz]>csp->BankZ[i+1] //water elevation is above bank elevation
./ch_flow.cpp:438:				else                       Arrptr->H[csp->ChanX[i]+csp->ChanY[i]*Parptr->xsz]=csp->NewA[i]/csp->ChanWidth[i]; // all other points
./ch_flow.cpp:442:				csp->ChanWidth[i],Arrptr->H[csp->ChanX[i]+csp->ChanY[i]*Parptr->xsz]); 
./ch_flow.cpp:449:				Arrptr->H[csp->ChanX[csp->chsz-1]+csp->ChanY[csp->chsz-1]*Parptr->xsz]);
./ch_flow.cpp:468:				Solverptr->Hds=Arrptr->H[csp->ChanX[csp->chsz-1]+csp->ChanY[csp->chsz-1]*Parptr->xsz];
./ch_flow.cpp:514:  q0=Arrptr->Qx[pi0+1+pj0*(Parptr->xsz+1)];
./ch_flow.cpp:516:  q1=-Arrptr->Qx[pi0+pj0*(Parptr->xsz+1)];
./ch_flow.cpp:518:  q2=Arrptr->Qy[pi0+(pj0+1)*(Parptr->xsz+1)];
./ch_flow.cpp:520:  q3=-Arrptr->Qy[pi0+pj0*(Parptr->xsz+1)];
./ch_flow.cpp:557:      if(Arrptr->ChanMask[i+j*Parptr->xsz]!=-1) v+=Arrptr->H[i+j*Parptr->xsz]*Parptr->dA;
./ch_flow.cpp:636:			  else                         x[2*i]=xn[2*i]=Arrptr->H[csp->ChanX[i]+csp->ChanY[i]*Parptr->xsz]*csp->ChanWidth[i]; // all other points
./ch_flow.cpp:656:			  WSbc =   Arrptr->H[ChannelSegments[csp->Next_Segment].ChanX[csp->Next_Segment_Loc]+ChannelSegments[csp->Next_Segment].ChanY[csp->Next_Segment_Loc]*Parptr->xsz]
./ch_flow.cpp:657:			  + Arrptr->DEM[ChannelSegments[csp->Next_Segment].ChanX[csp->Next_Segment_Loc]+ChannelSegments[csp->Next_Segment].ChanY[csp->Next_Segment_Loc]*Parptr->xsz];
./ch_flow.cpp:732:				else						Arrptr->H[csp->ChanX[i]+csp->ChanY[i]*Parptr->xsz]=xn[2*i]/ csp->ChanWidth[i]; // all other points
./ch_flow.cpp:750:			  Solverptr->Hds=Arrptr->H[csp->ChanX[nodes-1]+csp->ChanY[nodes-1]*Parptr->xsz];
./ch_flow.cpp:900:    Hout = WSout - Arrptr->DEM[csp->ChanX[nodes-1]+csp->ChanY[nodes-1]*Parptr->xsz];
./ch_flow.cpp:906:	if(chseg==low) Hout = WSout - Arrptr->DEM[csp->ChanX[nodes-1]+csp->ChanY[nodes-1]*Parptr->xsz]; // CCS
./ch_flow.cpp:913:  else Arrptr->H[csp->ChanX[nodes-1]+csp->ChanY[nodes-1]*Parptr->xsz]=Hout;
./output.cpp:273:					fprintf(fp," %10.3" NUM_FMT" %10.3" NUM_FMT"", csptr->BankZ[j], Arrptr->DEM[pi+pj*Parptr->xsz]);
./output.cpp:274:					fprintf(fp," %10.3" NUM_FMT" %10.3" NUM_FMT"", Arrptr->DEM[pi+pj*Parptr->xsz]+Arrptr->H[pi+pj*Parptr->xsz], Arrptr->H[pi+pj*Parptr->xsz]);
./output.cpp:310:	write_binrasterfile(Fnameptr->resrootname,-1,".inittmb",Arrptr->initHtm,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:312:	write_binrasterfile(Fnameptr->resrootname,-1,".totaltmb",Arrptr->totalHtm,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:314:	write_binrasterfile(Fnameptr->resrootname,-1,".maxb",Arrptr->maxH,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:316:	write_binrasterfile(Fnameptr->resrootname,-1,".maxtmb",Arrptr->maxHtm,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:319:		write_binrasterfile(Fnameptr->resrootname,-1,".maxVxb",Arrptr->maxVx,Arrptr->DEM,1,Statesptr,Parptr);
./output.cpp:320:		write_binrasterfile(Fnameptr->resrootname,-1,".maxVyb",Arrptr->maxVy,Arrptr->DEM,2,Statesptr,Parptr);
./output.cpp:325:		write_binrasterfile(Fnameptr->resrootname,-1,".maxVcb",Arrptr->maxVc,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:326:		write_binrasterfile(Fnameptr->resrootname,-1,".maxVcdb",Arrptr->maxVcH,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:327:		write_binrasterfile(Fnameptr->resrootname,-1,".maxHazb",Arrptr->maxHaz,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:333:	write_ascfile(Fnameptr->resrootname,-1,".inittm",Arrptr->initHtm,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:335:	write_ascfile(Fnameptr->resrootname,-1,".totaltm",Arrptr->totalHtm,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:337:	write_ascfile(Fnameptr->resrootname,-1,".max",Arrptr->maxH,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:339:	write_ascfile(Fnameptr->resrootname,-1,".maxtm",Arrptr->maxHtm,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:342:		write_ascfile(Fnameptr->resrootname,-1,".maxVx",Arrptr->maxVx,Arrptr->DEM,1,Statesptr,Parptr);
./output.cpp:343:		write_ascfile(Fnameptr->resrootname,-1,".maxVy",Arrptr->maxVy,Arrptr->DEM,2,Statesptr,Parptr);
./output.cpp:348:		write_ascfile(Fnameptr->resrootname,-1,".maxVc",Arrptr->maxVc,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:349:		write_ascfile(Fnameptr->resrootname,-1,".maxVcd",Arrptr->maxVcH,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:350:		write_ascfile(Fnameptr->resrootname,-1,".maxHaz",Arrptr->maxHaz,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:373:		  TempChanMask[i + j*Parptr->xsz] = (NUMERIC_TYPE)Arrptr->ChanMask[i + j*Parptr->xsz];
./output.cpp:377:    write_ascfile(Fnameptr->resrootname,-1,".chmask",TempChanMask,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:383:		  TempChanMask[i + j*Parptr->xsz] = (NUMERIC_TYPE)Arrptr->SegMask[i + j*Parptr->xsz];
./output.cpp:387:    write_ascfile(Fnameptr->resrootname,-1,".segmask",TempChanMask,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:397:	write_ascfile(Fnameptr->resrootname,-1,"_SGC_bedZ.asc",Arrptr->SGCz,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:399:	write_ascfile(Fnameptr->resrootname,-1,"_SGC_width.asc",Arrptr->SGCwidth,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:401:	write_ascfile(Fnameptr->resrootname,-1,"_SGC_bfdepth.asc",Arrptr->SGCbfH,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:676:		if (Statesptr->binary_out==ON) write_binrasterfile(Fnameptr->resrootname,Parptr->SaveNo,".wdb",Arrptr->H,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:677:		else write_ascfile(Fnameptr->resrootname,Parptr->SaveNo,".wd",Arrptr->H,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:681:			if (Statesptr->binary_out==ON) write_binrasterfile_SGCf(Fnameptr->resrootname,Parptr->SaveNo, ".wdfpb", Arrptr->H, Arrptr->SGCbfH, Statesptr,Parptr); 
./output.cpp:682:			else write_ascfile_SGCf(Fnameptr->resrootname,Parptr->SaveNo, ".wdfp", Arrptr->H, Arrptr->SGCbfH, Statesptr,Parptr);
./output.cpp:692:		  if (Statesptr->binary_out == ON) write_binrasterfile(Fnameptr->resrootname, Parptr->SaveNo, ".elevb", Arrptr->H, Arrptr->SGCz, 3, Statesptr, Parptr, Solverptr->DepthThresh);
./output.cpp:693:		  else write_ascfile(Fnameptr->resrootname,Parptr->SaveNo,".elev",Arrptr->H,Arrptr->SGCz,3,Statesptr,Parptr, Solverptr->DepthThresh);
./output.cpp:698:		  if (Statesptr->binary_out == ON) write_binrasterfile(Fnameptr->resrootname, Parptr->SaveNo, ".elevb", Arrptr->H, Arrptr->DEM, 3, Statesptr, Parptr, Solverptr->DepthThresh);
./output.cpp:699:		  else write_ascfile(Fnameptr->resrootname, Parptr->SaveNo, ".elev", Arrptr->H, Arrptr->DEM, 3, Statesptr, Parptr, Solverptr->DepthThresh);
./output.cpp:708:			write_binrasterfile(Fnameptr->resrootname,Parptr->SaveNo,".Qxb",Arrptr->Qx,Arrptr->DEM,1,Statesptr,Parptr);
./output.cpp:709:			write_binrasterfile(Fnameptr->resrootname,Parptr->SaveNo,".Qyb",Arrptr->Qy,Arrptr->DEM,2,Statesptr,Parptr);
./output.cpp:713:			write_ascfile(Fnameptr->resrootname,Parptr->SaveNo,".Qx",Arrptr->Qx,Arrptr->DEM,1,Statesptr,Parptr);
./output.cpp:714:			write_ascfile(Fnameptr->resrootname,Parptr->SaveNo,".Qy",Arrptr->Qy,Arrptr->DEM,2,Statesptr,Parptr);
./output.cpp:722:				w0 = Arrptr->SGCwidth[ptr];
./output.cpp:723:				if (w0 > C(0.0) && Arrptr->H[ptr] > C(0.0))
./output.cpp:725:					CalcSGC_A(Arrptr->SGCgroup[ptr], Arrptr->H[ptr], Arrptr->SGCbfH[ptr], &A0,  &w0, SGCptr);
./output.cpp:726:					Arrptr->SGCFlowWidth[ptr] = w0;
./output.cpp:728:				else Arrptr->SGCFlowWidth[ptr] = C(0.0);
./output.cpp:732:				write_binrasterfile(Fnameptr->resrootname,Parptr->SaveNo,".Fwidthb",Arrptr->SGCFlowWidth,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:734:				write_binrasterfile(Fnameptr->resrootname,Parptr->SaveNo,".Qcxb",Arrptr->QxSGold,Arrptr->DEM,1,Statesptr,Parptr);
./output.cpp:735:				write_binrasterfile(Fnameptr->resrootname,Parptr->SaveNo,".Qcyb",Arrptr->QySGold,Arrptr->DEM,2,Statesptr,Parptr);
./output.cpp:739:				write_ascfile(Fnameptr->resrootname,Parptr->SaveNo,".Fwidth",Arrptr->SGCFlowWidth,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:741:				write_ascfile(Fnameptr->resrootname,Parptr->SaveNo,".Qcx",Arrptr->QxSGold,Arrptr->DEM,1,Statesptr,Parptr);
./output.cpp:742:				write_ascfile(Fnameptr->resrootname,Parptr->SaveNo,".Qcy",Arrptr->QySGold,Arrptr->DEM,2,Statesptr,Parptr);
./output.cpp:752:			write_binrasterfile(Fnameptr->resrootname,Parptr->SaveNo,".Vxb",Arrptr->Vx,Arrptr->DEM,1,Statesptr,Parptr);
./output.cpp:753:			write_binrasterfile(Fnameptr->resrootname,Parptr->SaveNo,".Vyb",Arrptr->Vy,Arrptr->DEM,2,Statesptr,Parptr);
./output.cpp:757:			write_ascfile(Fnameptr->resrootname,Parptr->SaveNo,".Vx",Arrptr->Vx,Arrptr->DEM,1,Statesptr,Parptr);
./output.cpp:758:			write_ascfile(Fnameptr->resrootname,Parptr->SaveNo,".Vy",Arrptr->Vy,Arrptr->DEM,2,Statesptr,Parptr);
./output.cpp:774:			w0=Arrptr->SGCwidth[p0]; w1=Arrptr->SGCwidth[p1];
./output.cpp:775:			zb0=Arrptr->SGCz[p0]; zb1=Arrptr->SGCz[p1];
./output.cpp:776:			h0=Arrptr->H[p0]; h1=Arrptr->H[p1];
./output.cpp:778:			bf0 = Arrptr->SGCbfH[p0];    bf1 = Arrptr->SGCbfH[p1];
./output.cpp:785:					qc=Arrptr->QxSGold[pq0]; // Get old q in m3/s
./output.cpp:786:					gr0 = Arrptr->SGCgroup[p0];	gr1 = Arrptr->SGCgroup[p1]; // get channel groups
./output.cpp:788:					if(Arrptr->SGCManningsn!=NULL)   cn=pow(C(0.5)*(Arrptr->SGCManningsn[p0]+Arrptr->SGCManningsn[p1]),2); // this could be pre-calculated
./output.cpp:793:					Sf=-dh/(Arrptr->dx[p0]*m); 
./output.cpp:801:						R = CalcSGC_R(gr0, hflow, bf0, w0, Arrptr->SGCwidth[p0], A0, SGCptr);
./output.cpp:809:						R = CalcSGC_R(gr1, hflow, bf1, w1, Arrptr->SGCwidth[p1], A1, SGCptr);
./output.cpp:825:			w0=Arrptr->SGCwidth[p0]; w1=Arrptr->SGCwidth[p1];
./output.cpp:826:			zb0=Arrptr->SGCz[p0]; zb1=Arrptr->SGCz[p1];
./output.cpp:827:			h0=Arrptr->H[p0]; h1=Arrptr->H[p1];
./output.cpp:829:			bf0 = Arrptr->SGCbfH[p0];    bf1 = Arrptr->SGCbfH[p1];
./output.cpp:836:					qc=Arrptr->QySGold[pq0]; // Get old q in m3/s
./output.cpp:837:					gr0 = Arrptr->SGCgroup[p0];	gr1 = Arrptr->SGCgroup[p1]; // get channel groups
./output.cpp:840:					if(Arrptr->SGCManningsn!=NULL)   cn=pow(C(0.5)*(Arrptr->SGCManningsn[p0]+Arrptr->SGCManningsn[p1]),2); // this could be pre-calculated
./output.cpp:845:					Sf=-dh/(Arrptr->dy[p0]*m);
./output.cpp:853:						R = CalcSGC_R(gr0, hflow, bf0, w0, Arrptr->SGCwidth[p0], A0, SGCptr);
./output.cpp:861:						R = CalcSGC_R(gr1, hflow, bf1, w1, Arrptr->SGCwidth[p1], A1, SGCptr);
./output.cpp:878:			write_binrasterfile(Fnameptr->resrootname,Parptr->SaveNo,".SGCVxb",SGCVx,Arrptr->DEM,1,Statesptr,Parptr);
./output.cpp:879:			write_binrasterfile(Fnameptr->resrootname,Parptr->SaveNo,".SGCVyb",SGCVy,Arrptr->DEM,2,Statesptr,Parptr);
./output.cpp:880:			write_binrasterfile(Fnameptr->resrootname,Parptr->SaveNo,".SGCVcb",SGCvoutput,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:884:			write_ascfile(Fnameptr->resrootname,Parptr->SaveNo,".SGCVx",SGCVx,Arrptr->DEM,1,Statesptr,Parptr);
./output.cpp:885:			write_ascfile(Fnameptr->resrootname,Parptr->SaveNo,".SGCVy",SGCVy,Arrptr->DEM,2,Statesptr,Parptr);
./output.cpp:886:			write_ascfile(Fnameptr->resrootname,Parptr->SaveNo,".SGCVc",SGCvoutput,Arrptr->DEM,0,Statesptr,Parptr);
./output.cpp:895:			write_binrasterfile(Fnameptr->resrootname,Parptr->SaveNo,".QLxb",Arrptr->LimQx,Arrptr->DEM,1,Statesptr,Parptr);
./output.cpp:896:			write_binrasterfile(Fnameptr->resrootname,Parptr->SaveNo,".QLyb",Arrptr->LimQy,Arrptr->DEM,2,Statesptr,Parptr);
./output.cpp:900:			write_ascfile(Fnameptr->resrootname,Parptr->SaveNo,".QLx",Arrptr->LimQx,Arrptr->DEM,1,Statesptr,Parptr);
./output.cpp:901:			write_ascfile(Fnameptr->resrootname,Parptr->SaveNo,".QLy",Arrptr->LimQy,Arrptr->DEM,2,Statesptr,Parptr);
